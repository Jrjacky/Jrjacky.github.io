<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>通俗易懂的斯特林数介绍</title>
    <url>/2020/04/22/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><a id="more"></a>
<p>将$n$个元素分成$m$个无标号的轮换$\begin{bmatrix}n\\m\end{bmatrix}$<br>什么叫轮换？<br>就是把一堆数放在一个圈上，如果可以通过旋转使得圈上的每个位置上数都和另一个圈上的数是相等的，那么这两个圈等价（意思就是它们是同一个轮换）<br>比如，现在有三个轮换：<br><img src="https://img-blog.csdnimg.cn/2020021616135437.png" alt="在这里插入图片描述"><br>第一个轮换和第二个轮换是等价的，第一个和第三个轮换不是等价的<br>那么，什么叫无标号的轮换？<br>就是如果一堆轮换调换顺序后和另一堆轮换完全相同（所有对应的轮换等价），那么这两堆轮换就是等价的<br>比如，现在有两堆轮换：<br><img src="https://img-blog.csdnimg.cn/20200216163715754.png" alt="在这里插入图片描述"><br>第一堆轮换和第二堆轮换完全相同，是等价的<br>为了让大家更了解第一类斯特林数，我们举一个例子：$\begin{bmatrix}3\\2\end{bmatrix}=3$<br>三种方法如下：<br><img src="https://img-blog.csdnimg.cn/20200216163047456.png" alt="在这里插入图片描述"><br>第一类斯特林数还有另一种定义，就是$\prod \limits_{i=0}^{n-1}(x-i)$的$m$次项系数叫$\begin{bmatrix}n\\m\end{bmatrix}$</p>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>将$n$个元素分成$m$个无标号的集合$\begin{Bmatrix}n\\m\end{Bmatrix}$<br>上面我们已经解释过了无标号的意思，相信大家都知道无标号集合的意思了<br>为了让大家更了解第一类斯特林数，我们举一个例子：$\begin{Bmatrix}3\\2\end{Bmatrix}=3$<br>三种方法如下：</p>
<ol>
<li>$\{\{1\},\{2,3\}\}$</li>
<li>$\{\{2\},\{1,3\}\}$</li>
<li>$\{\{3\},\{1,2\}\}$<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="通项"><a href="#通项" class="headerlink" title="通项"></a>通项</h2>第一类斯特林数貌似没有通项公式（或者是没用或者我太菜了不知道）<br>第二类斯特林数的通项为$\begin{Bmatrix}n\\m\end{Bmatrix}=\frac{1}{m^2}\sum \limits_{i=0}^m(-1)^i\binom{m}{k}(m-i)^n$貌似也没什么用……我不会证……记住就好了<del>我好像也记不住？？？</del><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><h3 id="第一类斯特林数-1"><a href="#第一类斯特林数-1" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3>$\begin{bmatrix}n\\m\end{bmatrix}=(n-1)\begin{bmatrix}n-1\\m\end{bmatrix}+\begin{bmatrix}n-1\\m-1\end{bmatrix}$<br>证明：假如$n-1$个元素构成了$m-1$个无标号的轮换，第$n$个元素独自构成一个无标号的轮换，有$\begin{bmatrix}n-1\\m-1\end{bmatrix}$种方法。如果$n-1$个元素构成了$m$个无标号的轮换，将第$n$个元素插入到任意元素的左边，有$(n-1)\begin{bmatrix}n-1\\m\end{bmatrix}$种方法<br>$\therefore \begin{bmatrix}n\\m\end{bmatrix}=(n-1)\begin{bmatrix}n-1\\m\end{bmatrix}+\begin{bmatrix}n-1\\m-1\end{bmatrix}$<h3 id="第二类斯特林数-1"><a href="#第二类斯特林数-1" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3>$\begin{Bmatrix}n\\m\end{Bmatrix}=m\begin{Bmatrix}n-1\\m\end{Bmatrix}+\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$<br>证明：假如$n-1$个元素构成了$m-1$个无标号的集合，第$n$个元素独自构成一个无标号的集合，有$\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$种方法。如果$n-1$个元素构成了$m$个集合，将第$n$个元素插入到任意集合中，有$m\begin{Bmatrix}n-1\\m\end{Bmatrix}$种方法<br>$\therefore \begin{Bmatrix}n\\m\end{Bmatrix}=m\begin{Bmatrix}n-1\\m\end{Bmatrix}+\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><h3 id="第一类斯特林数-2"><a href="#第一类斯特林数-2" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3>$\begin{bmatrix}n\\0\end{bmatrix}=0,\begin{bmatrix}n\\1\end{bmatrix}=1,\begin{bmatrix}n\\n-1\end{bmatrix}=\binom{n}{2},\begin{bmatrix}n\\n\end{bmatrix}=1$<br>自己想吧，太简单了，不证了<h3 id="第二类斯特林数-2"><a href="#第二类斯特林数-2" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3>$\begin{Bmatrix}n\\0\end{Bmatrix}=0,\begin{Bmatrix}n\\1\end{Bmatrix}=1,\begin{Bmatrix}n\\n-1\end{Bmatrix}=\binom{n}{2},\begin{Bmatrix}n\\n\end{Bmatrix}=1$<br>自己想吧，太简单了，不证了<h2 id="快速幂？？？"><a href="#快速幂？？？" class="headerlink" title="快速幂？？？"></a>快速幂？？？</h2>①$n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}$<br>其中$n^{\underline{i}}$表示$n$的$i$次下降幂，即$n^{\underline{i}}=\prod \limits_{k=0}^{i-1}(n-k)$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}=\begin{Bmatrix}1\\1\end{Bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{k+1}=n\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} n^{\underline{i}}=\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix}\left( n^{\underline{i+1}}+in^{\underline{i}}\right)=\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} n^{\underline{i+1}}+\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} in^{\underline{i}}=\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k\\i-1\end{Bmatrix} n^{\underline{i}}+\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k\\i\end{Bmatrix} in^{\underline{i}}=\sum \limits_{i=0}^{k+1} \left(\begin{Bmatrix}k\\i-1\end{Bmatrix}+i\begin{Bmatrix}k\\i\end{Bmatrix}\right) n^{\underline{i}}=\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k+1\\i\end{Bmatrix} n^{\underline{i}}$<br>$\therefore n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}$<br>②$n^{\overline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i$<br>其中$n^{\overline{m}}$表示$n$的$i$次上升幂，即$n^{\overline{m}}=\prod \limits_{i=0}^{m-1}(n+i)$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i=\begin{bmatrix}1\\1\end{bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{\overline{k+1}}=(n+k)n^{\overline{k}}=n\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} n^i+k\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k\\i-1\end{bmatrix} n^i+\sum \limits_{i=0}^{k+1} k\begin{bmatrix}k\\i\end{bmatrix} n^i=\sum \limits_{i=0}^{k+1} \left(\begin{bmatrix}k\\i-1\end{bmatrix}+k\begin{bmatrix}k\\i\end{bmatrix}\right) n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k+1\\i\end{bmatrix} n^i$<br>$\therefore n^{\overline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i$<br>③$n^{\underline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i=\begin{bmatrix}1\\1\end{bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{\underline{k+1}}=(n-k)n^{\underline{k}}=n\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} (-1)^{k-i} n^i-k\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} (-1)^{k-i} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k\\i-1\end{bmatrix} (-1)^{k+1-i} n^i+\sum \limits_{i=0}^{k+1} k\begin{bmatrix}k\\i\end{bmatrix} (-1)^{k+1-i} n^i=\sum \limits_{i=0}^{k+1} \left(\begin{bmatrix}k\\i-1\end{bmatrix}+k\begin{bmatrix}k\\i\end{bmatrix}\right) (-1)^{k+1-i} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k+1\\i\end{bmatrix} (-1)^{k+1-i} n^i$<br>$\therefore n^{\underline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i$<h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2>若$f(n)=\sum \limits_{i=1}^n\begin{Bmatrix}n\\i\end{Bmatrix}g(i)$，则$g(n)=\sum \limits_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}f(i)$<br>这个$-1$的次数怎么这么熟？<br>是的，这就是上面的③式中$-1$次数<br>可以用斯特林反演说明①式和③式是等价的<br>但是这玩意儿好像没啥用，至少我没用过<del>我就没做过几道斯特林数的题目</del>，所以我也不会证……<br><strong>ps：定义部分从百度百科上的内容删改而成</strong></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2162 magic</title>
    <url>/2020/04/22/DTOJ2162-magic/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>给定一个$n$个点，$m$条边的有向图<br>对于任意一个点$i$，都有两个权值$a_i,b_i$<br>你可以花费$b_i$的费用将这个点的$a_i$变成$0$<br>另外对于圈中的每个点你需要付出$wi=Max(i,j)\in E~aj$<br>请最小化所有费用之和</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数$n$，$m$<br>接下来一行$n$个数，表示$a_i$<br>接下来一行$n$个数，表示$b_i$<br>接下来$m$行，每行$2$个数$i,j$，表示一行$(i,j)$的边</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个数，表示最小化的费用</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">100000 10000</span><br><span class="line">100000 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>最优的方案是花费$1$的费用将$a_2$变成$0$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$n\leqslant 20$<br>对于$100\%$的数据，$n\leqslant 1000,m\leqslant 50000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>奇奇怪怪的建图、跑网络流方法……<br>对于原图中的每一个点，建$i$的出度个点，把这些点和终点连上流量为$b_i$的边，然后把这些个点按$a_i$的值从小到大排序<br>然后搞个差分，再在这些个点之间连上流量为<code>inf</code>的边<br>最后跑一个网络流就可以啦！<br><strong>注意，DFS中的取地址符非常重要，去掉了之后会超时，虽然我也不知道为啥<del>反正就是加了就过了</del>，因为我平常些Dinic的时候也不加这个取地址符</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,h;</span><br><span class="line">&#125;temp[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,ver;</span><br><span class="line">&#125;e[<span class="number">400010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t[<span class="number">200010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,tot=<span class="number">1</span>,len,ans,a[<span class="number">1010</span>],b[<span class="number">1010</span>],u[<span class="number">50010</span>],v[<span class="number">50010</span>],head[<span class="number">200010</span>],Head[<span class="number">200010</span>],d[<span class="number">200010</span>],vis[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>; <span class="keyword">bool</span> flag=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">0</span>; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ppap1 a,ppap1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].to=v,e[tot].ver=w;</span><br><span class="line">    e[++tot].nxt=head[v],head[v]=tot,e[tot].to=u,e[tot].ver=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++) d[i]=<span class="number">1e9</span>;</span><br><span class="line">    d[S]=<span class="number">0</span>,q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop(),Head[x]=head[x];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(d[e[i].to]&gt;d[x]+<span class="number">1</span>&amp;&amp;e[i].ver&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            d[e[i].to]=d[x]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[e[i].to]) vis[e[i].to]=<span class="number">1</span>,q.push(e[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T]!=<span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==T||(!Flow)) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> k,flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=Head[x];i;i=e[i].nxt) <span class="keyword">if</span>(d[e[i].to]==d[x]+<span class="number">1</span>&amp;&amp;(k=dfs(e[i].to,min(e[i].ver,Flow)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        e[i].ver-=k,e[i^<span class="number">1</span>].ver+=k,Flow-=k,flow+=k;</span><br><span class="line">        <span class="keyword">if</span>(!Flow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    S=<span class="number">200002</span>,T=S+<span class="number">1</span>,len=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]=read(),add(i,T,b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) u[i]=read(),v[i]=read(),t[u[i]].push_back(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,size;i&lt;=n;i++)&#123;</span><br><span class="line">        size=t[i].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++) temp[j].h=t[i][j],temp[j].v=a[t[i][j]];</span><br><span class="line">        sort(temp,temp+size,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,tem;j&lt;size;j++)&#123;</span><br><span class="line">            tem=++len;</span><br><span class="line">            <span class="keyword">if</span>(!j) add(S,tem,temp[j].v);</span><br><span class="line">            <span class="keyword">else</span> add(S,tem,temp[j].v-temp[j<span class="number">-1</span>].v),add(tem<span class="number">-1</span>,tem,<span class="number">1e9</span>);</span><br><span class="line">            add(tem,temp[j].h,<span class="number">1e9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(S,<span class="number">1e9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2161 Christmas</title>
    <url>/2020/04/22/DTOJ2161-Christmas/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>给出一个长度为$n$的整数序列。你的程序需要依次完成如下操作：</p>
<ol>
<li>$A~a~b~c$：将区间$[a,b]$中的每个数加上$c$</li>
<li>$M~a~b~c$: 对区间$[a,b]$中的每个数$x$，令$x=max(x,c)$</li>
<li>$Q~a$：求序列第$a$个数的值是多少，以及这个值在之前的询问中改变了多少次，你的程序需要输出这两个值<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>第一行输入一个数$n$，表示序列的长度<br>接下来一行$n$个数，表示最开始的序列<br>接下来一行输入一个数$m$，表示操作个数<br>接下来$m$行，每行一个询问，其中操作的形式如试题描述（参考样例）<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>对于每个询问输出两个数，分别为那个数的值，以及那个数被修改了多少次<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">5</span><br><span class="line">A 1 2 4</span><br><span class="line">M 2 3 5</span><br><span class="line">Q 1</span><br><span class="line">Q 2</span><br><span class="line">Q 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1</span><br><span class="line">6 1</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3>第一个操作后序列变成了$5,6,3$<br>第二次操作后序列变成了$5,6,5$<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>对于$30\%$的数据，$n,m \leqslant 10000$<br>对于另外$30\%$的数据，操作中的值均随机生成的<br>对于$100\%$的数据，$n,m \leqslant 10^5$<br>操作过程中所有数字在<code>int</code>范围内<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>我太菜了，只会分块……<br>这道题使用分块非常简单，代码超短（比如我的代码就是最短的），内存也很小（我的内存也是最小的），但是贼慢，跑了$3008ms$（居然还是第8名）<br>首先我们规定一些变量：$x_i$表示数值，$opt_i$表示操作次数，$xadd_i$表示数值的<code>lazy</code>标志，$optadd_i$表示操作次数的<code>lazy</code>标志，二维数组$q_{i,j}$表示第$i$块中，针对$M~a~b~c$操作的<code>lazy</code>标志，保证一维数组$q_i$中的数值单调递增，$l_i$表示一维数组$q_i$的长度<br>对于$A~a~b~c$操作，如果$a$和$b$在同一块中，那么就直接下传标记，直接暴力修改即可<br>如果$a$和$b$不在同一个块中，$a$和$b$所在的块中一样下传标记然后暴力修改，中间的直接$xadd_i+=c,optadd_i++$就可以了<br>对于$M~a~b~c$操作，如果$a$和$b$在同一块中，那么就直接下传标记，直接暴力修改即可<br>如果$a$和$b$不在同一个块中，$a$和$b$所在的块中一样下传标记然后暴力修改，对于中间的每一段，如果$c-add_i&gt;q_{i,l_i}$（因为如果小于就没有存储的必要了），就执行$q_{i,++l_i}=c-add_i$<br>值得一提的是，因为谁也不知道$l_i$等于几，所以当$l_i&gt;1000$时，我们就下传一下标记，清空$q_i$数组<br>对于$Q~a$，就直接下传标记然后输出$x_i$和$opt_i$即可<br>但是，整个程序的核心——下传标记还没有讲呢！<br>对，下面，我们就来讲讲这个函数<br>假设我们需要下传第$k$段的内容，那么，常规操作就是$x_i+=xadd_k,opt_i+=optadd_k$，但是我们还需要下传$q_i$呢！<br>我们首先找出比$x_i$大的$q_{k,j}$设它的下标为$(k,temp)$（因为数组中的值是单调递增的，所以直接使用<code>upper-bound</code>即可），如果没有这个$temp$，那就直接正常下传就好了，但是如果有，就说明这个数需要更新成$c$，并且操作次数要加上$l_k-temp+1$（因为单调递增，这个$c-add_k$更新了，后面的肯定都要更新）<br>听起来很难理解，看看代码实现吧！<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,d,x[<span class="number">100010</span>],opt[<span class="number">100010</span>],add[<span class="number">330</span>],Add[<span class="number">330</span>],q[<span class="number">330</span>][<span class="number">1010</span>],l[<span class="number">330</span>];</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;b;i++) x[i]+=c,opt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;b;i++) <span class="keyword">if</span>(x[i]&lt;c) x[i]=c,opt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d*k,temp;i&lt;d*k+d;i++)&#123;</span><br><span class="line">    	temp=upper_bound(q[k]+<span class="number">1</span>,q[k]+l[k]+<span class="number">1</span>,x[i])-q[k];</span><br><span class="line">    	<span class="keyword">if</span>(temp&lt;=l[k]) x[i]=q[k][l[k]],opt[i]+=l[k]-temp+<span class="number">1</span>;</span><br><span class="line">    	opt[i]+=Add[k],x[i]+=add[k];</span><br><span class="line">    &#125;</span><br><span class="line">    l[k]=add[k]=Add[k]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n,d=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++) q[i][<span class="number">0</span>]=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)&#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;op&gt;&gt;a,a--;</span><br><span class="line">    	<span class="keyword">if</span>(op==<span class="string">'A'</span>)&#123;</span><br><span class="line">    		<span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c,b--;</span><br><span class="line">    		<span class="keyword">if</span>(!c) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">if</span>(a/d==b/d)&#123;spread(a/d),change1(a,b+<span class="number">1</span>,c);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            spread(a/d),change1(a,(a/d+<span class="number">1</span>)*d,c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a/d+<span class="number">1</span>;i&lt;b/d;i++) add[i]+=c,Add[i]++;</span><br><span class="line">            spread(b/d),change1((b/d)*d,b+<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'M'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c,b--;</span><br><span class="line">            <span class="keyword">if</span>(a/d==b/d)&#123;spread(a/d),change2(a,b+<span class="number">1</span>,c);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            spread(a/d),change2(a,(a/d+<span class="number">1</span>)*d,c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a/d+<span class="number">1</span>;i&lt;b/d;i++)&#123;</span><br><span class="line">        		<span class="keyword">if</span>(c-add[i]&gt;q[i][l[i]]) q[i][++l[i]]=c-add[i];</span><br><span class="line">        		<span class="keyword">if</span>(l[i]&gt;<span class="number">1000</span>) spread(i);</span><br><span class="line">            &#125;</span><br><span class="line">            spread(b/d),change2((b/d)*d,b+<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> spread(a/d),<span class="built_in">cout</span>&lt;&lt;x[a]&lt;&lt;<span class="string">" "</span>&lt;&lt;opt[a]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2444 祖玛</title>
    <url>/2020/04/22/DTOJ2444-%E7%A5%96%E7%8E%9B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>祖玛是一款曾经风靡全球的游戏，其玩法是：在一条轨道上初始排列着若干个彩色珠子，其中任意三个相邻的珠子不会完全同色<br>此后，你可以发射珠子到轨道上并加入原有序列中<br>一旦有三个或更多同色的珠子变成相邻，它们就会立即消失<br>这类消除现象可能会连锁式发生，其间你将暂时不能发射珠子<br><img src="https://img-blog.csdnimg.cn/20200422112913278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开发商最近准备为玩家写一个游戏过程的回放工具<br>他们已经在游戏内完成了过程记录的功能，而回放功能的实现则委托你来完成<br>游戏过程的记录中，首先是轨道上初始的珠子序列，然后是玩家接下来所做的一系列操作<br>你的任务是，在各次操作之后及时计算出新的珠子序列</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个由大写字母<code>A~Z</code>组成的字符串，表示轨道上初始的珠子序列，不同的字母表示不同的颜色<br>第二行是一个数字$n$，表示整个回放过程共有$n$次操作<br>接下来的$n$行依次对应于各次操作<br>每次操作由一个数字k和一个大写字母$\Sigma$描述，以空格分隔。其中，$\Sigma$为新珠子的颜色<br>若插入前共有$m$颗珠子，则$k\in [0,m]$表示新珠子嵌入之后（尚未发生消除之前）在轨道上的位序</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$n$行，依次给出各次操作（及可能随即发生的消除现象）之后轨道上的珠子序列<br>如果轨道上已没有珠子，则以<code>-</code>表示。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ACCBA</span><br><span class="line">5</span><br><span class="line">1 B</span><br><span class="line">0 A</span><br><span class="line">2 B</span><br><span class="line">4 C</span><br><span class="line">0 A</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCCBA</span><br><span class="line">AABCCBA</span><br><span class="line">AABBCCBA</span><br><span class="line">-</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$100 \%$的数据满足$1 \leqslant n \leqslant 10^3,1 \leqslant m \leqslant 2 \times 10^3$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>太TMD坑了，初始的珠子序列居然可以是<strong>空串！空串！空串！</strong><br>考试使用<code>scanf</code>的我差点气死，本来可以第一名的……<br>这道题其实很简单，插入的时候使用<code>strcpy</code>直接插入，再判断一下插入后是否有连续的$3$个相同的字母<br>因为每次插入以后只改变插入的位置的字母，所以只需要判断插入的位置旁边是否有连续的$3$个的相同字母<br>因为有可能有连锁反应，所以修改后将当前的位置设为插入的位置前和插入的位置的颜色相同的位置<del>我自己都被绕晕了</del><br>然后使用<code>while</code>即可<br>具体的实现看代码吧<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,ns,x;</span><br><span class="line"><span class="keyword">char</span> c,s[<span class="number">2010</span>],temp[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xc</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=p,l=p;</span><br><span class="line">    <span class="keyword">while</span>(s[f]==s[p]&amp;&amp;f) f--;</span><br><span class="line">    <span class="keyword">if</span>(f||s[f]!=s[p]) f++;</span><br><span class="line">    <span class="keyword">while</span>(s[l]==s[p]&amp;&amp;l&lt;ns) l++;</span><br><span class="line">    <span class="keyword">if</span>(l-f&gt;<span class="number">2</span>)&#123;<span class="built_in">strcpy</span>(temp,s+l),<span class="built_in">strcpy</span>(s+f,temp),ns=ns+f-l,x=f;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(s);</span><br><span class="line">    ns=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>,&amp;x,&amp;c);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp,s+x),<span class="built_in">strcpy</span>(s+x+<span class="number">1</span>,temp),s[x]=c,ns++;</span><br><span class="line">        <span class="keyword">while</span>(xc(x)&amp;&amp;ns);</span><br><span class="line">        <span class="keyword">if</span>(ns) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3373 约会</title>
    <url>/2020/04/20/DTOJ3373-%E7%BA%A6%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Vincent</code>和他的大学<code>GF</code>不在同一个院系中，但他们每天都要约在校园中的同一个地方见面<br><code>THU</code>的地图可以抽象为一个$n$个结点的一棵树，即有$n$个地点，$n-1$条无向边，每条边的长度为$1$，任意两个地点之间是连通的<del>树还能不连通！？</del><br>由于每天的课程不同，他们每天所在的位置也不同，第$i$天，<code>Vincent</code>在地点$x_i$，他的<code>GF</code>在地点$y_i$<br>由于不能让某一方走的路程过多，所以他们约会的地点有个要求，必须与两人的位置之间的距离相等，距离指在树上的最短路径<br>请你帮<code>Vincent</code>算算每天他们有多少种可选的约会地点</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$<br>接下来$n-1$行，每行两个整数$u$和$v$，表示树上有一条$u$和$v$之间的边<br>接下来一行一个整数$m$，表示他们有$m$天要约会见面<br>接下来$m$行，每行两个整数$x_i,y_i$，表示第$i$天，他们各自的位置</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一天，输出一行一个整数，表示第$i$天可行的约会地点有多少个</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>约会地点$1$是可行的</p>
<h3 id="数据范围及约定"><a href="#数据范围及约定" class="headerlink" title="数据范围及约定"></a>数据范围及约定</h3><p>对于$25 \%$的数据，$n,m \leqslant 100$<br>对于$50 \%$的数据，$n,m \leqslant 10^3$<br>另外存在$20 \%$的数据，树是一条链<br>另外存在$15 \%$的数据，树是随机生成的<br>对于$100 \%$的数据，$n,m \leqslant 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，以编号为$1$的点为根<br>对于一组询问$x,y$，如果$x$的深度小于$y$，那就交换他们的顺序<br>接着，求出它们的LCA，就可以求出链的长度<br>如果链的长度是偶数，那就没有中点，答案是$0$<br>如果链的长度是奇数，就求出链的中点<br>如果中点是它们的LCA，那么深度比LCA小的节点和不包含$x$和$y$的LCA的子树是可行的约会地点<br>若中点不是LCA，那么深度小于中点的点都不是可行的约会地点，深度大于中点的节点用类似于上面的求法求出来就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,head[<span class="number">100010</span>],nxt[<span class="number">200010</span>],to[<span class="number">200010</span>],dep[<span class="number">100010</span>],Fa[<span class="number">100010</span>][<span class="number">25</span>],size[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[a],head[a]=tot,to[tot]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=dep[fa]+<span class="number">1</span>,size[x]=<span class="number">1</span>,Fa[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) Fa[x][i]=Fa[Fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]^fa) dfs(to[i],x),size[x]+=size[to[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;~i;i--) <span class="keyword">if</span>(dep[Fa[x][i]]&gt;=dep[y]) x=Fa[x][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;~i;i--) <span class="keyword">if</span>(Fa[x][i]^Fa[y][i]) x=Fa[x][i],y=Fa[y][i];</span><br><span class="line">    <span class="keyword">if</span>(x^y) <span class="keyword">return</span> Fa[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;~i;i--) <span class="keyword">if</span>(y&gt;&gt;i&amp;<span class="number">1</span>) x=Fa[x][i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,add(x,y),add(y,x);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,len,LCA;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">        LCA=lca(x,y),len=dep[x]+dep[y]<span class="number">-2</span>*dep[LCA];</span><br><span class="line">        <span class="keyword">if</span>(len&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid=find(x,len);</span><br><span class="line">            <span class="keyword">if</span>(mid==x) <span class="built_in">cout</span>&lt;&lt;n;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid==LCA) <span class="built_in">cout</span>&lt;&lt;size[<span class="number">1</span>]-size[find(x,len<span class="number">-1</span>)]-size[find(y,len<span class="number">-1</span>)];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;size[mid]-size[find(x,len<span class="number">-1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3311 寻找</title>
    <url>/2020/04/20/DTOJ3311-%E5%AF%BB%E6%89%BE/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>“我有个愿望，我希望穿越一切找到你”<br>这是个二维平面世界，平面上有$n$个特殊的果实，我从$(0,0)$点出发，希望得到尽量多的果实，但是出于某种特殊的原因，我的运动方式只有三种（假设当前我在$(x,y)$）：</p>
<ol>
<li>我可以走到$(x+1,y)$</li>
<li>我可以走到$(x,y+1)$</li>
<li>我可以走到$(x+1,y+1)$</li>
</ol>
<p>现在我需要你的帮助，帮我找出我最多能够得到多少个果实</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$表示有多少个被标记的点<br>接下来$n$行每行两个整数$x,y$表示一个点的坐标</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数表示答案，表示我最多能够得到多少个果实</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">-2 -1</span><br><span class="line">-2 -3</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>样例输入的点如图所示：<br><img src="https://img-blog.csdnimg.cn/20200420101030935.png" alt="在这里插入图片描述"></p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$70 \%$的数据$1 \leqslant n \leqslant 10^3$<br>对于$100 \%$的数据$1 \leqslant n \leqslant 10^5,-10^9 \leqslant x,y \leqslant 10^9$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然，只有在第一象限、$x$轴和$y$轴的正半轴或者原点上的点可以到达<br>所以去掉不是第一象限、$x$轴和$y$轴的正半轴或者原点上的点，把剩下的点按照$x$坐标排序，求$y$坐标的最长上升子序列即可<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n,len,ans,lcs[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        a[++len].x=x,a[len].y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+len,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].x&gt;=lcs[ans]) lcs[++ans]=a[i].x;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=lower_bound(lcs+<span class="number">1</span>,lcs+<span class="number">1</span>+ans,a[i].x)-lcs;</span><br><span class="line">            lcs[temp]=a[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3302 星座</title>
    <url>/2020/04/20/DTOJ3302-%E6%98%9F%E5%BA%A7/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>为了探索我们头顶那美丽的星空，伟大的<code>C</code>学给了我们一张星图，这张星图可以看做一个平面，其中包含了$n$颗星星，每颗星星可以用平面上的一个点来表示，<code>C</code>学告诉我们这张星图中包含着多种神奇的$\alpha - \beta - \gamma$星座，这些星座在平面内构成了很多平行四边形，它们的都有一组边长为$\gamma$的对边平行于$x$轴，且另一组对边平行于一斜率为$\frac{\beta}{\alpha}$的直线，现在<code>C</code>学给了我们若干组询问，每组询问包含$3$个整数$\alpha,\beta,\gamma$，对于每组询问请你求出$x$轴上方和下方中$\alpha - \beta - \gamma$星座的个数 (平行四边形不能与$x$轴有相交的部分)</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第$1$行$2$个正整数$n,m$表示星星的个数和询问的个数$(4 \leqslant n \leqslant 100,000,1 \leqslant m \leqslant 10)$<br>第$2 \sim n+1$行每行$2$个整数$x,y$表示每颗星星的横纵坐标$(-1,000 \leqslant x,y \leqslant 1,000)$(数据保证不会有两颗星星在同一个位置)<br>第$n+2 \sim n+m+1$行每行$3$个整数$\alpha,\beta,\gamma(1 \leqslant \alpha \leqslant 2,000,-2,000 \leqslant \beta \leqslant 2,000,1 \leqslant \gamma \leqslant 2,000)$(当$\beta=0$时，表示一条平行于 y轴的直线)</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$m$行<br>每行两个整数，表示$x$轴上方满足条件星座个数和$x$轴下方满足条件星座个数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 1</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">1 -1</span><br><span class="line">2 -1</span><br><span class="line">1 -2</span><br><span class="line">2 -2</span><br><span class="line">1 0 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看看这个坐标这么小，它不香吗？<br>我们用$v_{x,y}$表示$(x,y)$有没有点<br>算出有几条边平行$x$轴，然后每条边选择左边那个点<br>算出斜率投影到$x$轴上得到一个坐标，这个坐标相同的两条边可以组合成一个平行四边形（就是横截距相同而且斜率相同的直线只有一条）<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,len1,len2,ans1,ans2,x[<span class="number">100010</span>],y[<span class="number">100010</span>],v[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">double</span> eps=<span class="number">1e-7</span>,d1[<span class="number">100010</span>],d2[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]),v[x[i]+<span class="number">1000</span>][y[i]+<span class="number">1000</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c,s;i&lt;=m;i++)&#123;</span><br><span class="line">        ans1=ans2=len1=len2=s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(x[i]+c&lt;=<span class="number">1000</span>&amp;&amp;v[x[i]+<span class="number">1000</span>+c][y[i]+<span class="number">1000</span>])&#123;</span><br><span class="line">    		<span class="keyword">if</span>(y[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                d1[++len1]=x[i];</span><br><span class="line">                <span class="keyword">if</span>(b) d1[len1]-=<span class="number">1.0</span>*a*y[i]/b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d2[++len2]=x[i];</span><br><span class="line">                <span class="keyword">if</span>(b) d2[len2]-=<span class="number">1.0</span>*a*y[i]/b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d1+<span class="number">1</span>,d1+<span class="number">1</span>+len1),sort(d2+<span class="number">1</span>,d2+<span class="number">1</span>+len2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len1;++i)</span><br><span class="line">            <span class="keyword">if</span>(d1[i]-d1[i<span class="number">-1</span>]&lt;=eps) ++s;</span><br><span class="line">            <span class="keyword">else</span> ans1+=s*(s+<span class="number">1</span>)/<span class="number">2</span>,s=<span class="number">0</span>;</span><br><span class="line">        ans1+=s*(s+<span class="number">1</span>)/<span class="number">2</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len2;++i)</span><br><span class="line">            <span class="keyword">if</span>(d2[i]-d2[i<span class="number">-1</span>]&lt;=eps) ++s;</span><br><span class="line">            <span class="keyword">else</span> ans2+=s*(s+<span class="number">1</span>)/<span class="number">2</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans1,ans2+s*(s+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3308 从今以后</title>
    <url>/2020/04/16/DTOJ3308-%E4%BB%8E%E4%BB%8A%E4%BB%A5%E5%90%8E/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小果有一个数列<br>定义这个数列是合法的，指对于这个数列的每个子序列，都存在一个元素在在这个子序列中，只出现了一次<br>请帮小果判断这个数列是否合法</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$T$，表示数据组数<br>接下来$T$组数据，每组数据第一行有一个整数$n$，表示该组数据的序列长度，之后一行有$n$个非负整数$a_i$，表示该序列中每个元素的值</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$T$行，每行为<code>yes</code>或者<code>no</code>，表示这个序列合法或不合法</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5</span><br><span class="line">1 1 1 1 1</span><br><span class="line">5</span><br><span class="line">1 2 3 2 1</span><br><span class="line">5</span><br><span class="line">1 1 2 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">no</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据$\sum n \leqslant 5000$<br>对于$100\%$的数据$\sum n \leqslant 2 \times 10^6,n \leqslant 2 \times 10^5$<br>所有的$a_i$满足$0 \leqslant a_i \leqslant 10^9$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我的方法比较奇怪，如果你想看常规方法，可以看看<a href="https://blog.csdn.net/CSDNzhanghongyu/article/details/105522023" target="_blank" rel="noopener">这个神犇的博客</a><br>首先，先离散化，没啥好说的吧<br>接着，我们计算出$pre_i$和$nxt_i$分别表示前一个值为$a_i$的位置的下标和后一个值为$a_i$的位置的下标（也就是$a_{pre_i}=a_i$且$\forall j\in(pre_i,i),a_j\neq a_i$，$a_{nxt_i}=a_i$且$\forall j\in(i,nxt_i),a_j\neq a_i$）<br>所以，$\forall l\in (pre_i,i],r\in[i,nxt_i)$，区间$[l,r]$是合法的<br>所以，我们只需要找到这个区域内只出现一次的数，然后分别把数列从这个数劈成两半，分别考虑两个数列，如果都是合法的，那么这个数列就是合法的，进行递归即可<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">200010</span>],A[<span class="number">200010</span>],pre[<span class="number">200010</span>],nxt[<span class="number">200010</span>],q[<span class="number">200010</span>],h[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dg</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mid;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[l+i]&lt;l&amp;&amp;nxt[l+i]&gt;r) <span class="keyword">return</span> (dg(l,l+i<span class="number">-1</span>)&amp;&amp;dg(l+i+<span class="number">1</span>,r));</span><br><span class="line">        <span class="keyword">if</span>(pre[r-i]&lt;l&amp;&amp;nxt[r-i]&gt;r) <span class="keyword">return</span> (dg(l,r-i<span class="number">-1</span>)&amp;&amp;dg(r-i+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],A[i]=a[i],pre[i]=nxt[i]=<span class="number">0</span>;</span><br><span class="line">        sort(A+<span class="number">1</span>,A+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=unique(A+<span class="number">1</span>,A+n+<span class="number">1</span>)-(A+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=lower_bound(A+<span class="number">1</span>,A+len+<span class="number">1</span>,a[i])-A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) q[i]=<span class="number">0</span>,h[i]=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=q[a[i]],q[a[i]]=i,nxt[n-i+<span class="number">1</span>]=h[a[n-i+<span class="number">1</span>]],h[a[n-i+<span class="number">1</span>]]=n-i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dg(<span class="number">1</span>,n)?<span class="string">"yes"</span>:<span class="string">"no"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3303 W的火星工程</title>
    <url>/2020/04/16/DTOJ3303-W%E7%9A%84%E7%81%AB%E6%98%9F%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>大老板<code>W</code>的伟大工程扩大到了火星，他准备在火星建立一个自己的度假村<br>在他的度假村里，有两个大饭店<code>A</code>,<code>B</code><br>对于<code>W</code>来说，修建度假村必不可少的就是从<code>A</code>饭店向<code>B</code>饭店修路,以保证他可以短时间内享受各种美味<br>火星上有一些中转站，中转站之间以及它们与饭店之间有路径使得能从一个到达另一个（路径为单向）<br>对于每一条路径，工程师<code>ZQ</code>给出了它的两个消费参数$a,b$<br><code>W</code>会从<code>A</code>饭店出发，经过其中的一些路径，最终到达<code>B</code>饭店<br><code>W</code>希望他走过的所有道路的$\frac{\sum{a}}{\sum{b}}$最小，也就是那些道路的$a$值之和除以他们的$b$值之和最小<br>可是路径实在太多了，<code>W</code>不知道该如何选择<br>聪明的你需要帮助他计算出这个最小值<br>至于路径的选取方法你就不需要告诉他了</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个整数$n,m$，表示中转站的数量和边的数量<br>随后$m$行，每行四个整数$x,y,a,b$，分别表示路径的两端，路径的$a,b$消费参数<br>其中$0$号点与$n+1$号点分别表示<code>W</code>的两个饭店<code>A</code>，<code>B</code><br>注意你并不需要把所有中转站都连入路中，只要保证从<code>A</code>饭店可以到达<code>B</code>饭店就行了</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个小数，表示所求的最小值。误差不超过$10^{-6}$即可</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">0 1 1 2</span><br><span class="line">0 2 2 3</span><br><span class="line">1 3 1 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.400000</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$20 \%$的数据，$n,m \leqslant 100$<br>对于$50 \%$的数据，$n \leqslant 1000$<br>对于$100 \%$的数据， $1 \leqslant n \leqslant 10000,1 \leqslant m \leqslant 100,000,0 \leqslant x,y \leqslant n+1$<br>数据保证$0$号饭店可以到达$n+1$号饭店，任意两个中转站或饭店间最多有一条边，且保证没有路可以构成环</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>0/1分数规划裸题<br>考虑二分答案，记$dis_i$表示从0到i的路径$\sum a_i-b_i\times mid$的最小值，用类似最短路的方法更新，判断一下$dis_{n+1}$的值是否大于$0$，更改二分的范围<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,nxt[<span class="number">100010</span>],head[<span class="number">10010</span>],to[<span class="number">100010</span>],a[<span class="number">100010</span>],b[<span class="number">100010</span>],v[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">double</span> L,R=<span class="number">1e9</span>,w[<span class="number">100010</span>],dis[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">2</span>;i++) dis[i]=<span class="number">1e9</span>,v[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) w[i]=(<span class="keyword">double</span>)a[i]-(<span class="keyword">double</span>)b[i]*x;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>,q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop(),v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(dis[to[i]]&gt;dis[x]+w[i])&#123;</span><br><span class="line">            dis[to[i]]=dis[x]+w[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[to[i]]) q.push(to[i]);</span><br><span class="line">            v[to[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n+<span class="number">1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;u,&amp;v,&amp;a[i],&amp;b[i]),add(u,v);</span><br><span class="line">    <span class="keyword">while</span>(L+<span class="number">0.000000001</span>&lt;R)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(pd(mid)) L=mid;</span><br><span class="line">        <span class="keyword">else</span> R=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>数学</tag>
        <tag>最短路</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3026 geronimo</title>
    <url>/2020/04/16/DTOJ3026-geronimo/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>“Geronimo∼”<br>时间还很多，让我们慢慢来。<br>不如听首开心的歌再看题？……算了，直接看题吧<br>给定一个整数$n$，以及一个$n$阶的排列$p_1,p_2,…,p_n$<br>我们定义重组过程如下：如果当前的排列是$a_1,a_2,…,a_n$，经过一次重组，就会变成$p_{a_1},p_{a_2},…,p_{a_n}$<br>问一个排列至少要经过多少次重组才会恢复成重组前的状态<br>由于答案可能很大，输出其对一个给定的正整数$q$取模的值即可</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数$n,q$<br>第二行一共$n$个整数，依次表示$p_1,p_2,…,p_n$<br>同一行相邻的数间用一个空格隔开</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示答案对$q$取模的值</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 1000000207</span><br><span class="line">2 6 5 1 3 4 7</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于全部的数据，$q\leqslant 2\times 10^9$<br>对于$10\%$的数据，$q=1$<br>对于另外$20\%$的数据，$n\leqslant 9$<br>对于另外$40\%$的数据，$n\leqslant 10^3$<br>对于剩下$30\%$的数据，$n\leqslant 5\times 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先求出每一个点要循环几次才能回到原位，然后直接去一个LCM就好了<br><strong>不能用传统的GCD，因为需要取模！必须用唯一分解定理</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,MOD,s,maxs,a[<span class="number">500010</span>],f[<span class="number">500010</span>],sum[<span class="number">500010</span>],p[<span class="number">500010</span>],v[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>,P[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]) <span class="keyword">continue</span>;</span><br><span class="line">        x=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[x]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(!f[x]) f[x]=j;</span><br><span class="line">            <span class="keyword">else</span> sum[x]=j-f[x];</span><br><span class="line">            x=a[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) maxs=max(maxs,sum[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxs;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        p[++s]=i,P[s]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=maxs;j+=i) v[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[i]==sum[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ppa=<span class="number">1</span>,Sum=sum[i];</span><br><span class="line">            <span class="keyword">while</span>(Sum%p[j]==<span class="number">0</span>) Sum/=p[j],ppa=ppa*p[j]%MOD;</span><br><span class="line">            P[j]=max(P[j],ppa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) ans*=P[i],ans%=MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2281 圈地为王</title>
    <url>/2020/04/11/DTOJ2281-%E5%9C%88%E5%9C%B0%E4%B8%BA%E7%8E%8B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>在$n$行$m$列的网格中，你要圈一些地<br>你从左上角出发，最后返回左上角，路径内部的区域视为被你圈住<br>你不可以进入网格内部，只能在边上行走<br>你的路径不能在左上角以外自交，但是边足够宽，你可以重复经过而不自交<br>网格中有一些格子对你很重要，你要尽量圈住它；而另一些格子对你有坏处，你不能圈住它<br>求圈住$i$个重要的格子的最小路径长度</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>$n$行，每行$m$个字符<br><code>I</code>表示重要的格子，<code>X</code>表示有坏处的格子，<code>.</code>表示其他格子</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出重要的格子数行，第i行表示圈住i个重要的格子的最小路径长度</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X.I</span><br><span class="line">.I.</span><br><span class="line">I..</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">10</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p><img src="https://img-blog.csdnimg.cn/20200411090009782.png" alt="在这里插入图片描述"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看到这个非<code>.</code>的格子这么少，让我想到了压缩最短路算法的状态<br>如何判断一个点是否在多边形内？很简单，只需要使用射线法<br>即从这个点随便引出一条射线，如果这条射线与多边形有奇数个交点，那么这个点就在多边形内<br>所以，我们用状态$s$表示路径下方某个重要格（或坏格）上方被该路径覆盖的次数的奇偶，$f_{x,y,s}$表示圈住这些点并且现在在$(x,y)$上的路径最短长度<br>然后直接跑最短路，对于左（或右）移操作，就查看一遍移动经过的这一段下方的重要格和坏格，更新$s$<br>统计答案的时候就遍历所有状态，取最小值即可<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;ppap&gt; q;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sp[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,sum,dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,k[<span class="number">20</span>],f[<span class="number">60</span>][<span class="number">60</span>][<span class="number">2100</span>],v[<span class="number">60</span>][<span class="number">60</span>][<span class="number">2100</span>],ans[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(y==sp[i].second&amp;&amp;x&lt;=sp[i].first) s^=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,<span class="built_in">map</span>[n++]));</span><br><span class="line">    m=<span class="built_in">strlen</span>(<span class="built_in">map</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'X'</span>) k[++cnt]=<span class="number">0</span>,sp[cnt]=make_pair(i,j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'I'</span>) k[++cnt]=<span class="number">1</span>,sp[cnt]=make_pair(i,j),sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(f)),<span class="built_in">memset</span>(ans,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(ans)),q.push((ppap)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;),f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ppap u=q.front();</span><br><span class="line">        q.pop(),v[u.x][u.y][u.s]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=u.x+dx[i],y=u.y+dy[i],s;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;n||y&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||i==<span class="number">1</span>) s=get(u.s,u.x,min(y,u.y));</span><br><span class="line">            <span class="keyword">else</span> s=u.s;</span><br><span class="line">            <span class="keyword">if</span>(f[x][y][s]&gt;f[u.x][u.y][u.s]+<span class="number">1</span>)&#123;</span><br><span class="line">                f[x][y][s]=f[u.x][u.y][u.s]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!v[x][y][s]) v[x][y][s]=<span class="number">1</span>,q.push((ppap)&#123;x,y,s&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s;i&lt;(<span class="number">1</span>&lt;&lt;cnt);i++)&#123;</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!k[j])&#123;s=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="number">-1</span>) ans[s]=min(ans[s],f[<span class="number">0</span>][<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4284 DTOJ1862 BZOJ3566 [SHOI2014]概率充电器</title>
    <url>/2020/04/11/%E6%B4%9B%E8%B0%B7P4284-DTOJ1862-BZOJ3566-SHOI2014-%E6%A6%82%E7%8E%87%E5%85%85%E7%94%B5%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P4284" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br>著名的电子产品品牌<code>SHOI</code>刚刚发布了引领世界潮流的下一代电子产品——概率充电器：<br>“采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决定！SHOI概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看吧！”<br><code>SHOI</code>概率充电器由$n-1$条导线连通了$n$个充电元件。进行充电时，每条导线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率决定<br>随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电<br>作为<code>SHOI</code>公司的忠实客户，你无法抑制自己购买<code>SHOI</code>产品的冲动。在排了一个星期的长队之后终于入手了最新型号的<code>SHOI</code>概率充电器<br>你迫不及待地将<code>SHOI</code>概率充电器插入电源——这时你突然想知道，进入充电状态的元件个数的期望是多少呢？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数：$n$，概率充电器的充电元件个数，充电元件由$1,2,\cdots \cdots ,n$编号<br>之后的$n-1$行每行三个整数$a,b,p$，描述了一根导线连接了编号为$a$和$b$的充电元件，通电概率为$p\%$<br>第$n+2$行$n$个整数：$q_i$，表示$i$号元件直接充电的概率为$q_i\%$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个实数，为能进入充电状态的元件个数的期望，四舍五入到小数点后$6$位小数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 50</span><br><span class="line">1 3 50</span><br><span class="line">50 0 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.000000</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据， $n\leqslant 5000$<br>对于$100\%$的数据，$n\leqslant 500000,0\leqslant p,q_i\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一个概率DP<br>首先，我们需要用到两个概率的公式：</p>
<ol>
<li>$P(A+B)=P(A)+P(B)-P(A\times B)=P(A)+P(B)-P(A)\times P(B)$</li>
<li>$P(A)=\frac{P(A+B)-P(B)}{1-P(B)}$（这个公式可以由第一个公式推导出来）</li>
</ol>
<p>接着，我们假设根是编号为$1$的节点，那么每一个点的充电方法有三种：</p>
<ol>
<li>自己给自己充</li>
<li>子节点给它充</li>
<li>父节点给他充</li>
</ol>
<p>所以，我们分别进行两次DFS：</p>
<ol>
<li>统计前两种充电方法的总和，使用第一个公式</li>
<li>由于第一个DFS在计算$fa_x$（当前遍历到的节点$x$的父节点）时已经包含了$x$给$fa_x$充电的情况了，所以我们需要先利用公式二减掉这一部分的概率，再利用公式一计算出$x$的概率</li>
</ol>
<p>附上代码：<br>```cpp</p>
<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<cstdio></h1><p>using namespace std;<br>int n,tot,head[1000010],nxt[1000010],to[1000010];<br>double ans,ver[1000010],p[1000010],q[1000010];<br>void add(int x,int y,double z)<br>{<br>    nxt[++tot]=head[x],head[x]=tot,to[tot]=y,ver[tot]=z;<br>}<br>void dfs1(int x,int fa)<br>{<br>    for(int i=head[x];i;i=nxt[i]) if(to[i]!=fa) dfs1(to[i],x),p[x]=p[x]+p[to[i]]<em>ver[i]-p[x]</em>p[to[i]]<em>ver[i];<br>}<br>void dfs2(int x,int fa)<br>{<br>    ans+=q[x];<br>    for(int i=head[x];i;i=nxt[i]) if(to[i]!=fa){<br>        double temp1=1.0-p[to[i]]</em>ver[i];<br>        if(!temp1) q[to[i]]=1.0;<br>        else{<br>            double temp2=(q[x]-p[to[i]]<em>ver[i])/temp1;<br>            q[to[i]]=p[to[i]]+temp2</em>ver[i]-p[to[i]]<em>temp2</em>ver[i];<br>        }<br>        dfs2(to[i],x);<br>    }<br>}<br>int main()<br>{<br>    scanf(“%d”,&amp;n);<br>    for(int i=1,x,y,z;i&lt;n;i++) scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z),add(x,y,z/100.0),add(y,x,z/100.0);<br>    for(int i=1;i&lt;=n;i++) scanf(“%lf”,&amp;p[i]),p[i]/=100.0;<br>    dfs1(1,0),q[1]=p[1],dfs2(1,0);<br>    printf(“%.6lf\n”,ans);<br>}</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>概率DP</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1053 爱博饼的翔霸</title>
    <url>/2020/04/11/DTOJ1053-%E7%88%B1%E5%8D%9A%E9%A5%BC%E7%9A%84%E7%BF%94%E9%9C%B8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>背景：“$10$月$6$日那天，电脑组组织了博饼活动，博饼结束后碗和骰子就放在了机房<br>结果喜感的翔霸整天有事没事地就跑去玩那骰子，搞得叮当叮当响的<br>终于有一天，翔霸再次去玩那些骰子的时候，曾大实在受不了了，就跟翔霸比赛博饼，如果翔霸输了，以后就不能在机房博饼<br>当然了，翔霸那么神，怎么可能输呢？哈哈<br>翔霸在赢得了跟曾大的比赛后，为了庆祝以后能在机房继续玩那些骰子，决定组织大家博饼<br>由于受到涛霸和学霸比赛谁先博到状元这个游戏的启发，翔霸也准备组织一个类似的比赛，他在电脑组里面选出$2\times n$个人，分成$n$组，一组$2$人，比赛谁先博到状元<br>作为每组幸运成为状元王中王那个人的奖励，翔霸将会教他神奇的翔状数组<br>但是平常大家都很忙的，所以只能在周末组织了<br>电脑组里每个神犇的家都很神奇地能用坐标$(x,y)$表示，两两神犇的家的距离定义为两个点之间的直线距离，被分为同一组的两个神犇商量其中一个人到另一个人家里去比赛<br>电脑组里的神犇都希望自己能到离自己家尽量近的人家里去比赛<br>作为组织者的翔霸想知道，如何分组才能让每组里要走到另一个人家里去博饼的人走的路径的和最小（保留两位小数）？<br>因为翔霸比较神，所以可能会组织好多次比赛，但具体组织多少次比赛要看翔霸的心情，因此翔霸决定当他选$0$个人的时候表示他不准备组织比赛了</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组数据，当$n$为$0$时表示输入结束<br>对于每组数据：<br>第一行一个正整数$n$<br>第$i+1$行$2$个正整数，表示每个人的坐标$x_i,y_i$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据：<br>仅一行，表示最优分组方案下的路径和</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">zx 10 10</span><br><span class="line">lx 20 10</span><br><span class="line">xy 5 5</span><br><span class="line">hta 1 1</span><br><span class="line">zkc 120 3</span><br><span class="line">cxy 6 6</span><br><span class="line">fz 50 60</span><br><span class="line">cyx 3 24</span><br><span class="line">lht 6 9</span><br><span class="line">lyq 0 0</span><br><span class="line">1</span><br><span class="line">taoba 9 9</span><br><span class="line">xueba 10 10</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">118.40</span><br><span class="line">1.41</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$n\leqslant 8且n\in \N^*$<br>$0\leqslant x,y\leqslant 1000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><del>这题目背景是真的长</del><br>看一下数据范围：$n\leqslant 8且n\in \N^*$，显然就是状压<br>假设状态$s$表示哪些人参加了博饼，$f_s$表示这些人参加博饼时，最短的距离<br>状态转移时就直接暴力枚举两个人作为一对（记得要是包含在状态$s$中的），答案就是这两个人的距离加上去掉这两个人以后的剩下的人最短距离<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;h[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">65540</span>];</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(h[a].x-h[b].x)*(h[a].x-h[b].x)+(<span class="keyword">double</span>)(h[a].y-h[b].y)*(h[a].y-h[b].y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[step]!=<span class="number">1e9</span>) <span class="keyword">return</span> f[step];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">if</span>(step&amp;(<span class="number">1</span>&lt;&lt;i)) <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;m;j++) <span class="keyword">if</span>(step&amp;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">        f[step]=min(f[step],dfs(step-(<span class="number">1</span>&lt;&lt;j)-(<span class="number">1</span>&lt;&lt;i))+dis(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> f[step];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),m=n*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">" %s%d%d"</span>,name,&amp;h[i].x,&amp;h[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) f[i]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,dfs((<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3410 splay.one</title>
    <url>/2020/04/05/DTOJ3410-splay-one/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>某神犇正在打<code>splay.one</code>，打出了$0-233$的超鬼战绩，并为之愤怒<br>神犇怎么可能超鬼呢？<br>神犇立马黑进了服务器，把<code>if(x≤0) 死亡;（x为生命值）</code>这句话删掉了<br>神犇觉得不太好，就改成了<code>if(x==0) 死亡；</code><br>众所周知神犇沉迷写题不会打游戏，只要$x$有可能为$0$，神犇依然会超鬼<br>现在神犇正处于混战当中，有$n$个塔，分别为炮塔和治疗塔，每秒只会有一个炮塔对神犇造成伤害或者一个治疗塔给神犇加奶<br>神犇只会屠题，所以打游戏时便会眼花缭乱，看不清哪个是炮塔哪个是治疗塔<br>不过因为神犇黑进了服务器，所以他获得了所有塔的伤害量或者奶量<br>神犇想知道他会不会超鬼</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两个正整数$n,q$<br>接下来$n$个整数$A_i$，表示塔的奶量或伤害；<br>接下来$q$个询问，每次格式如下：<br><code>insert x</code>表示加入一个塔，塔的伤害量或奶量；<br><code>delete x</code>表示删除一个塔，塔的伤害量或奶量（保证能删）；<br><code>ask x</code>表示若神犇的初始生命值为$x$，询问神犇会不会超鬼</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问，如果会输出<code>WTF</code>，否则输出<code>Nice</code></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">6 4 2 18</span><br><span class="line">ask 3</span><br><span class="line">insert 9</span><br><span class="line">delete 4</span><br><span class="line">ask 8</span><br><span class="line">delete 2</span><br><span class="line">ask 6</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nice </span><br><span class="line">WTF</span><br><span class="line">WTF</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$n,q\leqslant 200000$<br>$a_i \leqslant 10^9$<br>输入保证任何时候至少有一个塔</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><del>话说这题和Splay有啥关系呢</del><br>在不考虑加减炮塔的情况下，这道题就相当于在问你：给你$n+1$个正整数$a_1,a_2,\cdots\cdots a_n$和$b$，是否存在$n$个整数（因为有不同的两种塔，所以不需要一定为正整数）$x_1,x_2,\cdots\cdots x_n$，使得$\sum\limits_{i=1}^na_ix_i=b$<br>那么，我们由裴蜀定理可以知道：只要$gcd(a_1,a_2,\cdots \cdots,a_n)|b$就有解<br>所以我们就可以直接用线段树维护gcd就可以了<br><strong>记得动态开点！</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,x,s;</span><br><span class="line">&#125;t[<span class="number">12000000</span>];</span><br><span class="line"><span class="keyword">int</span> n,q,cnt,root,a[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> X,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;	</span><br><span class="line">        t[p].s+=f;</span><br><span class="line">        <span class="keyword">if</span>(t[p].s) t[p].x=X;</span><br><span class="line">        <span class="keyword">else</span> t[p].x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(X&lt;=mid) change(t[p].ls,l,mid,X,f);</span><br><span class="line">    <span class="keyword">else</span> change(t[p].rs,mid+<span class="number">1</span>,r,X,f);</span><br><span class="line">    t[p].x=__gcd(t[t[p].ls].x,t[t[p].rs].x);</span><br><span class="line">    t[p].s=t[t[p].ls].s+t[t[p].rs].s;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),change(root,<span class="number">1</span>,<span class="number">1e9</span>,a[i],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s %d"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'a'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%t[root].x==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"WTF\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Nice\n"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'i'</span>) change(root,<span class="number">1</span>,<span class="number">1e9</span>,x,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> change(root,<span class="number">1</span>,<span class="number">1e9</span>,x,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3493 加帕里图书馆</title>
    <url>/2020/04/05/DTOJ3493-%E5%8A%A0%E5%B8%95%E9%87%8C%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>博士经常阅读图书馆里的书籍。有一天，她在书中看到了一个长长的只由小写字母组成的字符串$S$<br>博士发现这个串有很多子序列都是回文串，非常优美，于是便列出了这个串的所有非空回文子序列<br>可是，博士忽然发现，她列出了很多相同的回文串<br>博士想知道，如果她只想把每种重复的串保留一个，一共需要从她的列表中移除多少回文串？<br>子序列$S$的一个子序列可以用一个数组$p$表示，构成的子序列为$S_{p_1}S_{p_2} \cdots \cdots S_{p_m}$，其中$m$为该子序列的长度<br>满足$0 &lt; p_1 &lt; p_2 &lt; \cdots \cdots &lt; p_m \leqslant |S|$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行一个非空字符串$S$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示博士一共需要移除多少重复的回文串。由于答案可能很大，请对$10^9+7$取模</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bccb</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">679266098</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h3><p>对于第一组样例，非空子序列一共有：<br>$\{b,c,c,b,bc,bc,bb,cc,cb,cb,bcc,bcb,bcb,ccb,bccb\}$<br>其中回文子序列有：<br>$\{b,c,c,b,bb,cc,bcb,bcb,bccb\}$<br>需要删去$3$个重复的回文子序列</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30 \%$的数据，$|S| \leqslant 20$<br>对于$60 \%$的数据，$|S| \leqslant 100$<br>对于$100 \%$的数据， $1 \leqslant |S| \leqslant 2000$，$S$只会包含小写字母</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>毒瘤区间DP……<br>我们用$f_{i,j}$表示$S_iS_{i+1}\cdots \cdots S_j$中回文串的总个数，$g_{i,j}$表示不重复回文串的个数，$to_i$表示$s_{to_i}=s_i$且$to_i$为最小的满足$s_j=s_i$的数，同理有$fr_i$<br>接着，我们可以得到转移方程：<br>$f_{i,j}=\begin{cases}1                                          i=j\\f_{i,j-1}+f_{i+1,j}+1              s_i=s_j\\f_{i,j-1}+f_{i+1,j}-f_{i+1,j-1}   \,s_i\neq s_j\end{cases}$<br>$g_{i,j}=\begin{cases}1                                          i=j\\g_{i,j-1}+g_{i+1,j}-g_{i+1,j-1}    s_i\neq s_j\\2\times g_{i+1,j-1}+2                 \,s_i=s_j且to_i=j\\2\times g_{i+1,j-1}+1                 \,s_i=s_j且to_i=fr_j\\2\times g_{i+1,j-1}-g_{to_i+1,fr_j-1} \,\,s_i=s_j且to_i\neq fr_j,to_i\neq j\end{cases}$<br>那么，答案就是$f_{1,n}-f_{1,g}$了！<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,to[<span class="number">2010</span>],fr[<span class="number">2010</span>],pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>,f[<span class="number">2010</span>][<span class="number">2010</span>],g[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;(a+<span class="number">1</span>),n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) f[j][j+i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==a[j+i<span class="number">-1</span>]) f[j][j+i<span class="number">-1</span>]=(f[j][j+i<span class="number">-1</span><span class="number">-1</span>]+f[j+<span class="number">1</span>][j+i<span class="number">-1</span>]+<span class="number">1</span>)%MOD;</span><br><span class="line">            <span class="keyword">else</span> f[j][j+i<span class="number">-1</span>]=(f[j][j+i<span class="number">-1</span><span class="number">-1</span>]+f[j+<span class="number">1</span>][j+i<span class="number">-1</span>]-f[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fr[i]=pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>],pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++) pos[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) to[i]=pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>],pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) g[j][j+i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]!=a[j+i<span class="number">-1</span>]) g[j][j+i<span class="number">-1</span>]=(g[j][j+i<span class="number">-1</span><span class="number">-1</span>]+g[j+<span class="number">1</span>][j+i<span class="number">-1</span>]-g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>])%MOD;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="keyword">if</span>(to[j]==j+i<span class="number">-1</span>) g[j][j+i<span class="number">-1</span>]=(<span class="number">2</span>*g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>]+<span class="number">2</span>)%MOD;</span><br><span class="line">            	<span class="keyword">if</span>(to[j]==fr[j+i<span class="number">-1</span>]) g[j][j+i<span class="number">-1</span>]=(<span class="number">2</span>*g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>]+<span class="number">1</span>)%MOD;</span><br><span class="line">            	<span class="keyword">if</span>(to[j]!=j+i<span class="number">-1</span>&amp;&amp;to[j]!=fr[j+i<span class="number">-1</span>]) g[j][j+i<span class="number">-1</span>]=(<span class="number">2</span>*g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>]-g[to[j]+<span class="number">1</span>][fr[j+i<span class="number">-1</span>]<span class="number">-1</span>])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(f[<span class="number">1</span>][n]-g[<span class="number">1</span>][n]+MOD)%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1039 吃蛋糕</title>
    <url>/2020/04/05/DTOJ1039-%E5%90%83%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小明是个蛋糕爱好者，连做梦都想着吃蛋糕——然后，他真的作了这样一个梦：<br>现在他在一个长为$L$的管道里，坐标从$0\sim L$，开始时，他在$0$这个位置<br>一些事件依次发生，比如说，小明想吃蛋糕，或者是蛋糕出现了<br>如果小明想吃蛋糕，那么他会挑选最近的那个蛋糕吃掉<br>如果左右两个蛋糕的距离是一样的，那么他就选择跟吃上一个蛋糕同样移动方向上的<br>否则，他就选那个距离较近的蛋糕<br>要是一个蛋糕都没出现，那么他就呆在原地不动<br>蛋糕会随机出现在管道的任何位置<br>请你统计一下，小明一共走了多少距离</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行是两个整数$L,N$<br>$L$是管道的长度，$N$是事件的数量$(1\leqslant L,N\leqslant 100000)$<br>接下来$N$行，首先是一个整数，表示事件的种类：如果是$1$，表示小明要吃蛋糕，后面什么也没有；如果是$0$，表示有个蛋糕出现了，后面跟一个整数，表示蛋糕出现的位置$(0\leqslant x\leqslant L)$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示小明一共走了多少距离</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 8</span><br><span class="line">0 1</span><br><span class="line">0 5</span><br><span class="line">1</span><br><span class="line">0 2</span><br><span class="line">0 0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 7</span><br><span class="line">0 1</span><br><span class="line">0 5</span><br><span class="line">1</span><br><span class="line">0 2</span><br><span class="line">0 0</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2-1"><a href="#样例输出2-1" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$50\%$的数据， $L,N\leqslant 5000$<br>对于$100\%$的数据， $L,N\leqslant 100000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接两个优先队列，分别存小明左边和右边的蛋糕的位置（一个从小到大，一个从大到小），吃蛋糕时就直接弹出，并且把小明的位置换到蛋糕的位置，更新答案；加蛋糕时就看蛋糕在小明的那一边，直接加就好了<br>当然，你也可以用一些平衡树什么之类的，但是那样比较麻烦<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; qx;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; qd;</span><br><span class="line"><span class="keyword">int</span> l,n,a,ans,flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,op,x;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;a) qx.push(x);</span><br><span class="line">            <span class="keyword">else</span> qd.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!qd.empty()&amp;&amp;!qx.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(a-qx.top()==qd.top()-a)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag) ans+=a-qx.top(),flag=<span class="number">0</span>,a=qx.top(),qx.pop();</span><br><span class="line">                    <span class="keyword">else</span> ans+=qd.top()-a,flag=<span class="number">1</span>,a=qd.top(),qd.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a-qx.top()&lt;qd.top()-a) ans+=a-qx.top(),flag=<span class="number">0</span>,a=qx.top(),qx.pop();</span><br><span class="line">                <span class="keyword">else</span> ans+=qd.top()-a,flag=<span class="number">1</span>,a=qd.top(),qd.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qd.empty()&amp;&amp;!qx.empty())&#123;ans+=a-qx.top(),flag=<span class="number">0</span>,a=qx.top(),qx.pop();<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!qd.empty()&amp;&amp;qx.empty())&#123;ans+=qd.top()-a,flag=<span class="number">1</span>,a=qd.top(),qd.pop();<span class="keyword">continue</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4155 BZOJ4444 DTOJ2347 [SCOI2015]国旗计划</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P4155-BZOJ4444-DTOJ2347-SCOI2015-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>A国</code>正在开展一项伟大的计划——国旗计划<br>这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈<br>这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了$n$名优秀的边防战士作为这项计划的候选人<br><code>A国</code>幅员辽阔，边境线上设有$m$个边防站，顺时针编号$1$至$m$<br>每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这两个边防战士的奔袭区间<br>$N$名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含<br>现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划<br>不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利完成国旗计划</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第$1$行，包含$2$个正整数$n$、$m$，分别表示边防战士数量和边防站数量。<br>随后$n$行，每行包含$2$个正整数<br>其中，第i行包含的两个正整数$C_i$、$D_i$分别表示i号边防战士常驻的两个边防站编号，$C_i$号边防站沿顺时针方向至$D_i$号边防站为他的奔袭区间<br>数据保证整个边境线都是可被覆盖的</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出数据仅$1$行，需要包含$n$个正整数<br>其中，第$i$个正整数表示$i$号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">2 5</span><br><span class="line">4 7</span><br><span class="line">6 1</span><br><span class="line">7 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 4 3</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>若$1$号边防战士必须参加，$1$、$2$、$4$号边防战士可覆盖整个边境线，因此至少需要$3$名边防战士完成国旗计划<br>同理，若$2$号边防战士或$4$号边防战士必须参加，也需要$3$名边防战士完成国旗计划<br>若3号边防战士必须参加，则需要$1$、$2$、$3$、$4$号边防战士才能完成国旗计划，因此至少需要$4$名边防战士</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$40\%$的数据，$n\leqslant 2000,m\leqslant 5000$<br>另有$30\%$的数据，保证所有答案不超过$100$<br>对于$100\%$的数据，$n\leqslant 2×10^5,m\leqslant 109,1\leqslant C_i,D_i\leqslant m$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为区间互相不包含，所以可以把区间按照左端点排序，这样右端点一定也是单调的<br>然后将环拆成一条链，也就是将所以区间在复制一遍<br>贪心求出每个区间可以走到的下个区间的最远右端点<br>用$f[x][i]$表示从第$x$个区间出发，走$2^i$个区间到达的区间<br>用倍增思想，只要右端点$\geqslant$出发的左端点$+m$就可以了<br>注意要<strong>预先保存第</strong>$\textbf{i}$<strong>个区间的原始下标</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,h;</span><br><span class="line">&#125;a[<span class="number">500010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;t[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len,tot,head[<span class="number">500010</span>],ans[<span class="number">500010</span>],f[<span class="number">500010</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap1 &amp;a,<span class="keyword">const</span> ppap1 &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l&lt;b.l||(a.l==b.l&amp;&amp;a.r&lt;b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[++tot].nxt=head[u],head[u]=tot,t[tot].to=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">js</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,temp=a[x].l+m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(f[x][i]&amp;&amp;a[f[x][i]].r&lt;temp) x=f[x][i],ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="keyword">return</span> ans+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),len=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].l,&amp;a[i].r),a[i].h=i;</span><br><span class="line">        <span class="keyword">if</span>(a[i].l&gt;a[i].r) a[i].r+=m;</span><br><span class="line">        <span class="keyword">else</span> a[++len]=(ppap1)&#123;a[i].l+m,a[i].r+m,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+len+<span class="number">1</span>,cmp),a[len+<span class="number">1</span>].r=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,z=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(z&lt;=len&amp;&amp;a[z+<span class="number">1</span>].l&lt;=a[i].r) z++;</span><br><span class="line">        f[i][<span class="number">0</span>]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="keyword">if</span>(a[i].l&lt;=m) ans[a[i].h]=js(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3258 BZOJ3631 DTOJ2250 [JLOI2014]松鼠的新家</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P3258-BZOJ3631-DTOJ2250-JLOI2014-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的<br>天哪，他居然真的住在“树”上<br>松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，……，最后到$a_n$，去参观新家<br>可是这样会导致维尼重复走很多房间，懒惰的维尼不听地推辞<br>可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃<br>维尼是个馋家伙，立马就答应了<br>现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果<br>因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$，表示房间个数<br>第二行$n$个整数，依次描述$a_1-a_n$<br>接下来$n-1$行，每行两个整数$x$，$y$，表示标号$x$和$y$的两个房间之间有树枝相连</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一共$n$行，第$i$行输出标号为$i$的房间至少需要放多少个糖果，才能让维尼有糖果吃</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 4 5 3 2</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$30\%$的数据，$n\leqslant 4000$<br>$80\%$的数据，$n\leqslant 50000$<br>100%的数据，$2\leqslant n\leqslant 300000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>其实这题是可以直接树剖的，但是我太懒(làn)<del>主要是板子背不下来</del><br>从$a_i$走到$a_{i+1}$时，在$a_i$和$a_{i+1}$上面打上$+1$标记，在它们的LCA和LCA的父亲节点上面打上$-1$标记，这样从下往上传标记即可得出每个点需要经过次数<br>但是要注意每次经过的点会重复算，因此最后要把$a_2\sim a_n$计算得到的值<strong>减一</strong>才是答案<br>其实这个做法的本质就是差分<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,a[<span class="number">300010</span>],head[<span class="number">300010</span>],dep[<span class="number">300010</span>],fa[<span class="number">300010</span>][<span class="number">20</span>],ans[<span class="number">300010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[<span class="number">600010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].to=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&gt;=(<span class="number">1</span>&lt;&lt;i)) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa[x][<span class="number">0</span>]) dep[e[i].to]=dep[x]+<span class="number">1</span>,fa[e[i].to][<span class="number">0</span>]=x,dfs1(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">int</span> t=dep[x]-dep[y];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">18</span>;i++) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;t)x=fa[x][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa[x][<span class="number">0</span>]) dfs2(e[i].to),ans[x]+=ans[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),add(u,v),add(v,u);</span><br><span class="line">    dfs1(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,LCA;i&lt;n;i++) LCA=lca(a[i],a[i+<span class="number">1</span>]),ans[a[i]]++,ans[a[i+<span class="number">1</span>]]++,ans[LCA]--,ans[fa[LCA][<span class="number">0</span>]]--;</span><br><span class="line">    dfs2(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) ans[a[i]]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4582 BZOJ4015 DTOJ1748 [FJOI2014]树的重心</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P4582-BZOJ4015-DTOJ1748-FJOI2014-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>给定一个$n$个点的树，每个点的编号从$1$至$n$，问这个树有多少不同的连通子树，和这个树有相同的重心<br>其中$n$个点的树指的是$n$个点的最小连通图，显然$n$个点的树有$n-1$条边，去掉这$n-1$条边中的任何一条，原图都不再联通，任意两个点之间由唯一一条路径相连<br>对于一个树，树的重心定义为：删掉某点$i$后，若剩余$k$个连通分量，那么定义$d(i)$为这些连通分量中点的个数的最大值，所谓重心，就是使得$d(i)$最小的点$i$<br>基于以上定义，一个树的重心可能会有一个或者两个，题中所要求的联通子树，其重心编号和个数必须和原树的完全一样<br>编程任务：找出给定的树中有多少连通的子树和这个树有相同的重心</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行：正整数$Q$，表示该组数据中有多少组测试样例<br>每组样例首先输入一个整数$n (0 &lt; n \leqslant 200)$，表示该组样例中输入的树包含$n$个点<br>之后$n-1$行，每行输入两整数数$x, y(1 \leqslant x , y \leqslant n )$，表示编号为$x$的点和编号为$y$的点之间存在一条边，所有点的编号从$1$到$n$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>首先输出样例编号，之后输出满足条件的子树的个数，由于这个数字较大，你只需要输出这个数字对$10007$取模后的结果，即$mod 10007$<br>详见输出示例，请严格按照输出实例中的格式输出</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">1 3 </span><br><span class="line">2 3</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 2</span><br><span class="line">Case 3: 6</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$20\%$的数据满足$n\leqslant 10$<br>$10\%$的数据满足给定的树中任意一个节点最多只有两个相邻节点<br>$100\%$的数据满足$Q\leqslant 50, n\leqslant 200$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们可以分别讨论1个和2个两个中心的情况：</p>
<ol>
<li>1个：考虑用树形dp来求最终的答案，直接以重心为根，枚举节点数，用$f_{i,j}$表示以$i$为根，选$j$个节点的答案数，dp的状态转移和<a href="http://jrjacky.github.io/2020/04/05/%E6%B4%9B%E8%B0%B7P4322-BZOJ4753-DTOJ3156-JSOI2016-%E6%9C%80%E4%BD%B3%E5%9B%A2%E4%BD%93/#more">洛谷P4322&amp;&amp;BZOJ4753&amp;&amp;DTOJ3156 最佳团体</a>有点像</li>
<li>2个：直接对两个重心分别求出答案，利用乘法原理求出最终的答案</li>
</ol>
<p>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,root,ans,MOD=<span class="number">10007</span>,head[<span class="number">210</span>],big[<span class="number">210</span>],size[<span class="number">210</span>],f[<span class="number">210</span>][<span class="number">210</span>],temp[<span class="number">210</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[<span class="number">410</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],e[tot].to=v,head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>,big[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        getroot(e[i].to,x),size[x]+=size[e[i].to],big[x]=max(big[x],size[e[i].to]);</span><br><span class="line">    big[x]=max(big[x],n-size[x]);</span><br><span class="line">    <span class="keyword">if</span>(big[x]&lt;=big[root]||(!root)) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=f[x][<span class="number">0</span>]=f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa)&#123; </span><br><span class="line">        dfs(e[i].to,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x]+size[e[i].to];j++) temp[j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x];j++) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=size[e[i].to];k++)</span><br><span class="line">            temp[j+k]=(temp[j+k]+f[x][j]*f[e[i].to][k]%MOD)%MOD;</span><br><span class="line">        size[x]+=size[e[i].to];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x];j++) f[x][j]=temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    dfs(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[x],<span class="number">0</span>,<span class="keyword">sizeof</span>(f[x])),size[x]=f[x][<span class="number">0</span>]=f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[x];j;j=e[j].nxt)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=size[x]+size[e[j].to];k++) temp[k]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=size[x];k++) <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=size[e[j].to];l++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l*<span class="number">2</span>&gt;=i) <span class="keyword">break</span>;</span><br><span class="line">                temp[k+l]=(temp[k+l]+f[x][k]*f[e[j].to][l]%MOD)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            size[x]+=size[e[j].to];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=size[x];k++) f[x][k]=temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+f[x][i])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    dfs(x,y),dfs(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans+f[x][i]*f[y][i]%MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test=<span class="number">0</span>,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        test++,<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),tot=ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">        root=<span class="number">0</span>,getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(big[root]*<span class="number">2</span>&lt;n) solve1(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i&gt;<span class="number">0</span>;i=e[i].nxt)&#123;</span><br><span class="line">                y=e[i].to;</span><br><span class="line">                <span class="keyword">if</span>(big[root]==size[y]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            solve2(root,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,test,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4322 BZOJ4753 DTOJ3156 [JSOI2016]最佳团体</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P4322-BZOJ4753-DTOJ3156-JSOI2016-%E6%9C%80%E4%BD%B3%E5%9B%A2%E4%BD%93/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P4322" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br><code>JSOI</code>信息学代表队一共有$N$名候选人，这些候选人从$1$到$N$编号<br>方便起见，<code>JYY</code>的编号是$0$号<br>每个候选人都由一位编号比他小的候选人$R_i$推荐。如果$R_i=0$则说明这个候选人是<code>JYY</code>自己看上的<br>为了保证团队的和谐，<code>JYY</code>需要保证，如果招募了候选人$i$，那么候选人$R_i$也一定需要在团队中<br>当然了，<code>JYY</code>自己总是在团队里的。每一个候选人都有一个战斗值$P_i$，也有一个招募费用$S_i$<br><code>JYY</code>希望招募$K$个候选人（<code>JYY</code>自己不算），组成一个性价比最高的团队<br>也就是，这$K$个被<code>JYY</code>选择的候选人的总战斗值与总招募总费用的比值最大</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 输入一行包含两个正整数$K$和$N$<br>接下来$N$行，其中第$i$行包含$3$个整数$S_i,P_i,R_i$表示候选人i的招募费用，战斗值和推荐人编号</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个实数，表示最佳比值，答案保留三位小数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1000 1 0</span><br><span class="line">1 1000 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.001</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$100\%$的数据满足$1\leqslant K\leqslant N\leqslant 2500,0&lt;S_i,P_i\leqslant 10^4,0\leqslant R_i&lt;i$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题意就是选一个大小为$k$的连通块，使得这个连通块的总战斗值与总招募费用的比值最大<br>因为要求的是最大值，所以可以采用二分答案（<strong>实数二分！实数二分！实数二分！</strong>），所以只需要考虑如何检验这个性价比是否可达到<br>这个检验就是一个树形DP，我们用$f_{i,j}$表示根为i的子树中选$j$个人的相当于最高性价比减去二分的性价比的量（因为为了避免精度差，计算的不是两个数真正的差，而是01分数规划后的结果），递推的部分就是一个常规的树形DP的递推了<br>值得注意的是，最后的答案是$f_{0,k+1}$，不是$f_{0,k}$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,tot,s[<span class="number">2510</span>],p[<span class="number">2510</span>],r[<span class="number">2510</span>],head[<span class="number">2510</span>],nxt[<span class="number">2510</span>],to[<span class="number">2510</span>],size[<span class="number">2510</span>];</span><br><span class="line"><span class="keyword">double</span> L,R=<span class="number">1e4</span>,mid,eps=<span class="number">1e-5</span>,f[<span class="number">2510</span>][<span class="number">2510</span>],F[<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[r[x]],head[r[x]]=tot,to[tot]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>,f[x][<span class="number">1</span>]=p[x]-s[x]*mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        dfs(to[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x]+size[to[i]];j++) F[j]=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x];j++) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=size[to[i]];k++) F[j+k]=max(F[j+k],f[x][j]+f[to[i]][k]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x]+size[to[i]];j++) f[x][j]=F[j];</span><br><span class="line">        size[x]+=size[to[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[i][j]=<span class="number">-1e9</span>;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][k+<span class="number">1</span>]&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s[i],&amp;p[i],&amp;r[i]),add(i);</span><br><span class="line">    <span class="keyword">while</span>(L+eps&lt;R)&#123;</span><br><span class="line">        mid=(L+R)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pd()) R=mid;</span><br><span class="line">        <span class="keyword">else</span> L=mid+eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>01分数规划</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3043 沉没林地</title>
    <url>/2020/04/05/DTOJ3043-%E6%B2%89%E6%B2%A1%E6%9E%97%E5%9C%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Ori</code>复活了<br>沉没林地，这是他旅途的起点<br>沉没林地可以用一条长度为$n$序列表示，存在两种东西，一个是树木，一个是小山丘，这些分别有一个高度<br>有$m$天，每一天，沉没林地从左至右有水涌入，每次水涌入都由一个参数$t_i$表示，从左至右高度第一个$\geqslant t_i$的山丘挡住（树木不会挡住水），否则，林地将会被淹没直到水的高度到达$t_i$为止。在第二天开始时，第一天的水又会瞬间消失<br><code>Ori</code>想要知道每天没有被淹没的树的个数是多少</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：$n,m$<br>第二行：$n$个整数，每个$h_i$表示这个林地，假如$h_i&gt;0$，那么此地为树木，如果$h_i&lt;0$，那么此地为山丘<br>高度为$|h_i|$<br>第三行：$m$个整数，分别表示一天水涌入的参数$t_i$<br>此外此题强制在线，输入的真实的$t_i$为$t_i\land lastans$，$lastans$表示上次询问的答案，一开始$lastans=0$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>有$m$行，对于每一个$t_i$输出答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">-2 4 -4 3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>真实的$t_i$分别为$2$、$3$、$5$<br>第一天：水越不过第一个山丘，树木没有被淹没，答案为$2$<br>第二天：水越过第一个小山丘，没有把树木淹没，答案为$2$<br>第三天：水越过第二个小山丘，把所有树木淹没，答案为$0$<br>对于$30\%$的数据，$n,m\leqslant 3000$<br>对于另外$20\%$的数据，$h_i&gt;0$<br>对于前$80\%$的数据，内存限制为128MB<br>对于$100\%$的数据，$n,m\leq 5*10^5 ,h_i\leq 10^9$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于每个$h_i$有两种情况：</p>
<ol>
<li>山丘：更新前面所有山丘的高度的最大值$maxs$</li>
<li>树：更新$t_{++len}$，表示这棵树的前面的所有山丘的高度的最大值（就是上面记录的$maxs$）和$h_i$这两个数中的最大值</li>
</ol>
<p>将$t$数组排序，二分查找（可以手写，也可以直接<code>upper_bound</code>）出每次水被淹没的树是排序后的第几棵树，用总数减一下就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,ans,maxs,a[<span class="number">500010</span>],t[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)&#123;maxs=max(maxs,-a[i]+<span class="number">1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        t[++s]=max(maxs,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(t+<span class="number">1</span>,t+s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),x^=ans,ans=upper_bound(t+<span class="number">1</span>,t+s+<span class="number">1</span>,x)-t,ans=s-ans+<span class="number">1</span>,<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2873 挑战K神</title>
    <url>/2020/04/05/DTOJ2873-%E6%8C%91%E6%88%98K%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>小Y</code>在<code>OIER</code>中是个菜鸟，作为一名菜鸟，如果能挑战K神是个有荣誉感的事<br><code>小Y</code>怎么会放过呢？于是<code>小Y</code>来到了<code>OIER</code>们的活动场所——<code>Playground</code>开始了挑战赛<br><code>小Y</code>看了看，<code>Playground</code>的地图是一个$N*M$的矩形($N，M\leqslant 100$)，里面遍布了障碍和一些传送带<br>例如，<code>1</code>表示该位置有障碍，<code>0</code>表示无障碍，大写字母表示传送带<br>传送带：例如，走到<code>B</code>传送带，将传送到另一个<code>B</code>传送带（次数无限，但每次进入传送带只会传送过去，不会再传送回来）<br>| 入口 | 0 | 0 | 0 |<br>|—|—|—|—|<br>| 0 | 0 | A | 0 |<br>| A | 0 | 0 | <code>K神</code> |</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行$2$个数据$n,m$<br>下面$n$行，每行$m$个数（入口点、<code>K神</code>、障碍、无障碍的空地和传送带），表示<code>Playground</code>的地图。地图数据之间无空格<br>每步只能走一格，方向为上下左右，左上角为入口点，右下角为出口点(<code>K神</code>）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示<code>小Y</code>最少需要走多少步<br>如果<code>小Y</code>不能走到目标，则输出<code>No Solution.</code> </p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">0000</span><br><span class="line">00A0</span><br><span class="line">A000</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>路线如图：<br><img src="https://img-blog.csdnimg.cn/20200331213025361.png" alt="在这里插入图片描述"></p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对$60\%$的数据：$n,m\leqslant 20$<br>对$100\%$的数据：$n,m\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>基本的搜索题……<br>就是一个宽搜，记录下所有的传送带的坐标，遇到传送带就直接传送就好了<br>没有什么好说的了，附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,s;</span><br><span class="line">&#125;q[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,l,r,dx[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,c1[<span class="number">30</span>][<span class="number">5</span>],c2[<span class="number">30</span>][<span class="number">5</span>],v[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;=<span class="string">'A'</span>&amp;&amp;<span class="built_in">map</span>[i][j]&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!c1[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">1</span>]) c1[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">1</span>]=i,c1[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">2</span>]=j;</span><br><span class="line">            <span class="keyword">else</span> c2[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">1</span>]=i,c2[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">2</span>]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r=q[<span class="number">1</span>].x=q[<span class="number">1</span>].y=v[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[++l].x,y=q[l].y;</span><br><span class="line">        <span class="keyword">if</span>(x==n&amp;&amp;y==m)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,q[l].s);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;=<span class="string">'A'</span>&amp;&amp;<span class="built_in">map</span>[x][y]&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="built_in">map</span>[x][y]-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c1[temp][<span class="number">1</span>]==x&amp;&amp;c1[temp][<span class="number">2</span>]==y) x=c2[temp][<span class="number">1</span>],y=c2[temp][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> x=c1[temp][<span class="number">1</span>],y=c1[temp][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> X=x+dx[i],Y=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(X&gt;<span class="number">0</span>&amp;&amp;X&lt;=n&amp;&amp;Y&gt;<span class="number">0</span>&amp;&amp;Y&lt;=m&amp;&amp;(!v[X][Y])&amp;&amp;<span class="built_in">map</span>[X][Y]!=<span class="string">'1'</span>) q[++r].x=X,q[r].y=Y,q[r].s=q[l].s+<span class="number">1</span>,v[X][Y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No Solution."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2603 不稳定的传送门</title>
    <url>/2020/03/30/DTOJ2603-%E4%B8%8D%E7%A8%B3%E5%AE%9A%E7%9A%84%E4%BC%A0%E9%80%81%E9%97%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>C</code>国里一共有$N$个城镇，编号为$1$到$N$<br>其中第$i$个城镇与第$i+1$个城镇连接着一条收费为$c_i$的从$i$到$i+1$的单向道路$(1\leqslant i&lt;n)$<br>现在，杰杰作为一个旅行者，他的任务就是从第$1$个城镇出发，到达编号为$N$的城镇<br>他觉得这样会很无聊，海克斯科技公司也是这么认为的，所以该公司在若干个城镇里设置了共$M$个单向传送门<br>每个传送门有$4$个参数$s,t,p,w$<br>$s$表示传送门的出发城镇，$t$表示传送门的传送目标城镇，保证$t$大于$s$，$w$表示使用该传送门的花费，$p$为传送成功的概率，若传送失败会自动返回出发的城市而且该传送门会永久损坏；而且无论传送成功与否，只要使用了该传送门就得花费$w$<br>现在，杰杰正在规划他的旅行方案。请你帮他规划一条最优策略，使得旅途期望花费最小</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数$N$和$M$<br>第二行有$N-1$个用空格隔开的整数，第$i$个数为$c_i$，意义如上述所示<br>接下来有$M$行，每行有$4$个数$s,t,p,w$，表示一个传送门的属性，意义如上述所示，其中$s,t,w$为整数</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，表示期望最小花费，小数点后四舍五入保留两位小数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">30 30 30</span><br><span class="line">1 4 0.5 30</span><br><span class="line">2 3 0.9 10</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">66.50</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据，每个城镇出发的传送门不超过$5$, 且$n\leqslant 1000$<br>对于$100\%$的数据，$1\leqslant n\leqslant 10^5,1\leqslant m\leqslant 10^5, 1\leqslant w\leqslant 100, 0\leqslant p\leqslant 1, 1\leqslant ci\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从题目中，我们可以看出这是个概率DP，并且是单向行走的<br>因此我们从$N$向$1$进行DP<br>我们可以建一个图，对于每一条边，存储$p$（概率）和$w$（花费）（对于从$i$到$i+1$的边，概率就是$1$）<br>分别写出对于同一个点的任意两条边$x$和$y$不同选择顺序的式子，化简后可以得到得：如果$dp[x.to]+\frac{x.w}{x.p}\leqslant dp[y.to]+\frac{y.w}{y.p}$，那么x比y更优，所以优先选择$x$<br>但是在计算$x$时，要用到$y$的结果，所以虽然优先选择$x$，但是在计算顺序上$y$在$x$之前<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自己写的太难看了，贴的是同学的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> x;<span class="keyword">double</span> p,val;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ed[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[x.x]+x.val/x.p&gt;dp[y.x]+y.val/y.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"portal.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"portal.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    node x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a);</span><br><span class="line">        x.x=i+<span class="number">1</span>;</span><br><span class="line">        x.p=<span class="number">1</span>;</span><br><span class="line">        x.val=a;</span><br><span class="line">        ed[i].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %lf %lf"</span>,&amp;st,&amp;x.x,&amp;x.p,&amp;x.val);</span><br><span class="line">        ed[st].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) dp[i]=<span class="number">999999999</span>;</span><br><span class="line">    dp[N]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(ed[i].begin(),ed[i].end(),cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ed[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            x=ed[i][j];</span><br><span class="line">            dp[i]=min(dp[i],</span><br><span class="line">                       dp[i]*(<span class="number">1</span>-x.p)+dp[x.x]*x.p+x.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2146 DTOJ2409 [NOI2015]软件包管理器</title>
    <url>/2020/03/28/%E6%B4%9B%E8%B0%B7P2146-DTOJ2409-NOI2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Linux</code>用户和<code>OS X</code>用户一定对软件包管理器不会陌生<br>通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置<br><code>Debian/Ubuntu</code>使用的<code>apt-get</code>，<code>Fedora/CentOS</code>使用的<code>yum</code>，以及<code>OS X</code>下可用的<code>homebrew</code>都是优秀的软件包管理器<br>你决定设计你自己的软件包管理器<br>不可避免地，你要解决软件包之间的依赖问题<br>如果软件包<code>A</code>依赖软件包<code>B</code>，那么安装软件包<code>A</code>以前，必须先安装软件包<code>B</code><br>同时，如果想要卸载软件包<code>B</code>，则必须卸载软件包<code>A</code><br>现在你已经获得了所有的软件包之间的依赖关系，而且，由于你之前的工作，除<code>0</code>号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而<code>0</code>号软件包不依赖任何一个软件包<br>依赖关系不存在环（若有$m(m\geqslant 2)$个软件包$A_1,A_2,A_3,\cdots \cdots,A_m$，其中$A_1$依赖$A_2$，$A_2$依赖$A_3$，$A_3$依赖$A_4$，……，$A_{m−1}$依赖$A_m$，而$A_m$依赖$A_1$，则称这$m$个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己<br>现在你要为你的软件包管理器写一个依赖解决程序<br>根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分<br>注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为$0$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第$1$行包含$1$个正整数$n$，表示软件包的总数，软件包从$0$开始编号<br>随后一行包含$n−1$个整数，相邻整数之间用单个空格隔开，分别表示$1,2,3,\cdots \cdots,n−2,n−1$号软件包依赖的软件包的编号<br>接下来一行包含$1$个正整数$q$，表示询问的总数<br>之后$q$行，每行$1$个询问<br>询问分为两种：<br><code>install x</code>：表示安装软件包$x$<br><code>uninstall x</code>：表示卸载软件包$x$<br>你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态<br>对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件包括$q$行<br>输出文件的第$i$行输出$1$个整数，为第$i$步操作中改变安装状态的软件包数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0 0 0 1 1 5</span><br><span class="line">5</span><br><span class="line">install 5</span><br><span class="line">install 6</span><br><span class="line">uninstall 1</span><br><span class="line">install 4</span><br><span class="line">uninstall 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">0 1 2 1 3 0 0 3 2</span><br><span class="line">10</span><br><span class="line">install 0</span><br><span class="line">install 3</span><br><span class="line">uninstall 2</span><br><span class="line">install 7</span><br><span class="line">install 5</span><br><span class="line">install 9</span><br><span class="line">uninstall 9</span><br><span class="line">install 4</span><br><span class="line">install 1</span><br><span class="line">install 9</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例1说明"><a href="#样例1说明" class="headerlink" title="样例1说明"></a>样例1说明</h3><p><img src="https://img-blog.csdnimg.cn/20200328145201656.png" alt="在这里插入图片描述"><br>一开始所有的软件包都处于未安装状态<br>安装$5$号软件包，需要安装$0,1,5$三个软件包<br>之后安装$6$号软件包，只需要安装$6$号软件包<br>此时安装了$0,1,5,6$四个软件包<br>卸载 1 号软件包需要卸载$1,5,6$三个软件包<br>此时只有$0$号软件包还处于安装状态<br>之后安装$4$号软件包，需要安装$1,4$两个软件包<br>此时$0,1,4$处在安装状态<br>最后，卸载$0$号软件包会卸载所有的软件包</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p><img src="https://img-blog.csdnimg.cn/20200328145429836.png" alt="在这里插入图片描述"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树剖裸题……<br>建线段树记录相应一段DFS序中安装软件的数量<br>安装软件的时候就直接把这个软件到根节点的路径上的所有点的权值全部修改为$1$<br>卸载软件的时候就直接把这个软件的所有子树上的所有点的权值全部修改为$0$就可以了<br>剩下的细节我就不说了，反正是个很裸的题<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(x) t[x].add</span></span><br><span class="line"><span class="keyword">int</span> n,q,tot,cnt,head[<span class="number">100010</span>],to[<span class="number">100010</span>],nxt[<span class="number">100010</span>],fa[<span class="number">100010</span>],size[<span class="number">100010</span>],dep[<span class="number">100010</span>],big[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">100010</span>],dfn[<span class="number">100010</span>],dfn2[<span class="number">100010</span>],sor[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,add;</span><br><span class="line">&#125;t[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=deep,size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        dfs1(to[i],deep+<span class="number">1</span>),size[x]+=size[to[i]];</span><br><span class="line">        <span class="keyword">if</span>(size[to[i]]&gt;size[big[x]]) big[x]=to[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=Top,dfn[x]=++cnt,sor[cnt]=x;</span><br><span class="line">    <span class="keyword">if</span>(big[x]==<span class="number">100001</span>)&#123;dfn2[x]=cnt;<span class="keyword">return</span>;&#125;</span><br><span class="line">    dfs2(big[x],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=big[x]) dfs2(to[i],to[i]);</span><br><span class="line">    dfn2[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a(p))&#123;</span><br><span class="line">        a(p*<span class="number">2</span>)=a(p*<span class="number">2</span>+<span class="number">1</span>)=a(p);</span><br><span class="line">        <span class="keyword">if</span>(a(p)==<span class="number">1</span>) s(p*<span class="number">2</span>)=r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>,s(p*<span class="number">2</span>+<span class="number">1</span>)=r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a(p)==<span class="number">2</span>) s(p*<span class="number">2</span>)=s(p*<span class="number">2</span>+<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">        a(p)=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l(p)=l,r(p)=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=l(p)&amp;&amp;r&gt;=r(p)) <span class="keyword">return</span> s(p);</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=l(p)&amp;&amp;r&gt;=r(p))&#123;</span><br><span class="line">        <span class="keyword">if</span>(x) a(p)=<span class="number">1</span>,s(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a(p)=<span class="number">2</span>,s(p)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) change(p*<span class="number">2</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">    s(p)=s(p*<span class="number">2</span>)+s(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Install</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=dep[x],u=x;</span><br><span class="line">    <span class="keyword">while</span>(top[u]) ans-=ask(<span class="number">1</span>,dfn[top[u]],dfn[u]),change(<span class="number">1</span>,dfn[top[u]],dfn[u],<span class="number">1</span>),u=fa[top[u]];</span><br><span class="line">    ans-=ask(<span class="number">1</span>,dfn[<span class="number">0</span>],dfn[u]),change(<span class="number">1</span>,dfn[<span class="number">0</span>],dfn[u],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Uninstall</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    ans=ask(<span class="number">1</span>,dfn[x],dfn2[x]),change(<span class="number">1</span>,dfn[x],dfn2[x],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"manager.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"manager.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),big[<span class="number">0</span>]=<span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),add(x,i),fa[i]=x,big[i]=<span class="number">100001</span>;</span><br><span class="line">    dfs1(<span class="number">0</span>,<span class="number">1</span>),dfs2(<span class="number">0</span>,<span class="number">0</span>),build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'i'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Install(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Uninstall(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树剖</tag>
        <tag>洛谷</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3919 DTOJ2308 Portals</title>
    <url>/2020/03/28/BZOJ3919-DTOJ2308-Portals/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h3><a id="more"></a>
<p>There is a cake placed in a labyrinth and you desperately want to eat it. You have a map of the labyrinth, which is a grid of R rows and C columns. Each grid cell contains one of the following characters:</p>
<ul>
<li><h1 id="number-sign-which-denotes-a-wall-block"><a href="#number-sign-which-denotes-a-wall-block" class="headerlink" title="(number sign) which denotes a wall block,"></a>(number sign) which denotes a wall block,</h1></li>
<li>. (dot) which denotes an open square,</li>
<li>S (uppercase letter s) which denotes an open square of your current location,</li>
<li>C (uppercase letter c) which denotes an open square with the cake.</li>
</ul>
<p>You may only walk on the open squares and move from one open square to another if they share a side. Additionally, the rectangular area depicted on the map is completely surrounded by wall blocks.<br>In order to reach the cake faster you have acquired a portal gun from Aperture ScienceTM, which operates as follows. At any time it can fire a portal in one of the four directions up,left, down and right. When a portal is fired in some direction, it will fly in that direction until it reaches the first wall. When this happens, a portal will be spawned on the wall block, on the side that faces you.<br>At most two portals can exist at any given time. If two portals are already placed in the labyrinth, then one of them (selected by you) will be removed immediately upon using the portal gun again. Firing a portal at an existing portal will replace it (there may be at most one portal per side of wall block). Note that there may be two portals placed on different sides of the same wall block.<br>Once two portals are placed in the labyrinth you can use them to teleport yourself. When standing next to one of the portals, you can walk into it and end up at the open square next to the other portal. Doing this takes as much time as moving between two adjacent squares.You may assume that firing portals does not take time and moving between two adjacent squares or teleporting through portals takes one unit of time.<br>Task<br>Given the map of the labyrinth together with your starting location and the location of the cake, calculate the minimum possible time needed for you to reach the cake.</p>
<h3 id="中文翻译"><a href="#中文翻译" class="headerlink" title="中文翻译"></a>中文翻译</h3><p>给出一张四连通的网格图，<code>#</code>代表墙，<code>.</code>代表空地，<code>S</code>代表出发点，<code>C</code>代表目的地，地图四周都是墙,求<code>S</code>到<code>C</code>的最短路<br>走的时候可以向上下左右中的某个方向发射奇怪的东西(<code>portals</code>)，<code>portals</code>会贴在发射方向的墙上<br>地图上只允许同时存在两个<code>portals</code>，如果已经发射了两个再发射第三个，那么你需要在之前的那两个中的选一个使它消失<br>两个<code>portals</code>可以存在于一块墙的两面，但不能存在于一块墙的同面<br>当你身边是墙且那块墙上有面向你的<code>portals</code>时，你可以走进那个<code>portals</code>，从另一个<code>portals</code>出来<br>相邻两点距离为$1$，走<code>portals</code>距离也为$1$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行2个数$R,C$，表示矩形的长和宽<br>接下来$R$行，每行一个长为$C$的字符串，表示这张图</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行表示答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">.#.C</span><br><span class="line">.#.#</span><br><span class="line">....</span><br><span class="line">S...</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p><img src="https://img-blog.csdnimg.cn/20200328142334334.png" alt="在这里插入图片描述"><br>One quickest sequence of moves is as follows:</p>
<ol>
<li>move right,</li>
<li>move right, shootone portal up, and one portal down,</li>
<li>move through the bottom portal,</li>
<li>moveone square right and reach the cake.<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3>Subtask $1$ ($11$ points): $1 \leqslant R \leqslant 10, 1 \leqslant C \leqslant 10$.<br>Subtask $2$ ($20$ points): $1 \leqslant R \leqslant 50, 1 \leqslant C \leqslant 50$.<br>Subtask $3$ ($20$ points): $1 \leqslant R \leqslant 200, 1 \leqslant C \leqslant 200$. Every open square has at least one wall block adjacent to it.<br>Subtask $4$ ($19$ points): $1 \leqslant R \leqslant 200, 1 \leqslant C \leqslant 200$.<br>Subtask $5$ ($30$ points): $1 \leqslant R \leqslant 1000, 1 \leqslant C \leqslant 1000$.<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>因为所有的传送门都只能放在墙前面的那一格，所以对于每一个点，我们可以预处理出每个点四个方向最远的不是墙的点（就是最近的墙的前面一格）和到这个点的距离的最小值$w_{i,j}$<br>那么，移动的时候就考虑放传送门，就是走到四个方向的最远点，距离就是$w_{i,j}+1$（有点类似于<code>Dijkstra</code>算法）<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;ppap&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,sx,sy,ex,ey,w[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">5</span>],d[<span class="number">1010</span>][<span class="number">1010</span>],flag[<span class="number">1010</span>][<span class="number">1010</span>],dis[<span class="number">1010</span>][<span class="number">1010</span>],v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'S'</span>) sx=i,sy=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'C'</span>) ex=i,ey=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        w[i][j][<span class="number">0</span>]=w[i<span class="number">-1</span>][j][<span class="number">0</span>]+<span class="number">1</span>,w[i][j][<span class="number">3</span>]=w[i][j<span class="number">-1</span>][<span class="number">3</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'#'</span>) q.push((ppap)&#123;i,j&#125;),w[i][j][<span class="number">0</span>]=w[i][j][<span class="number">3</span>]=d[i][j]=<span class="number">-1</span>,flag[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) w[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>) w[i][j][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j;j--)&#123;</span><br><span class="line">        w[i][j][<span class="number">1</span>]=w[i][j+<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1</span>,w[i][j][<span class="number">2</span>]=w[i+<span class="number">1</span>][j][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'#'</span>) q.push((ppap)&#123;i,j&#125;),w[i][j][<span class="number">1</span>]=w[i][j][<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n) w[i][j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==m) w[i][j][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="number">1</span>][i]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;<span class="number">1</span>,i&#125;),flag[<span class="number">1</span>][i]=<span class="number">1</span>,d[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][<span class="number">1</span>]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;i,<span class="number">1</span>&#125;),flag[i][<span class="number">1</span>]=<span class="number">1</span>,d[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[n][i]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;n,i&#125;),flag[n][i]=<span class="number">1</span>,d[n][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][m]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;i,m&#125;),flag[i][m]=<span class="number">1</span>,d[i][m]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ppap t=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,X,Y;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            X=t.x+dx[i],Y=t.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(X&lt;<span class="number">1</span>||X&gt;n||Y&lt;<span class="number">1</span>||Y&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[X][Y]!=<span class="string">'#'</span>&amp;&amp;(!flag[X][Y]))&#123;</span><br><span class="line">                d[X][Y]=d[t.x][t.y]+<span class="number">1</span>,q.push((ppap)&#123;X,Y&#125;),flag[X][Y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dis[i][j]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    q.push((ppap)&#123;sx,sy&#125;),dis[sx][sy]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ppap t=q.front();q.pop();</span><br><span class="line">        v[t.x][t.y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,X,Y;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            X=t.x+dx[i],Y=t.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[X][Y]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[X][Y]&gt;dis[t.x][t.y]+<span class="number">1</span>)&#123;</span><br><span class="line">                dis[X][Y]=dis[t.x][t.y]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!v[X][Y]) q.push((ppap)&#123;X,Y&#125;);</span><br><span class="line">                v[X][Y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,X,Y;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            X=t.x+w[t.x][t.y][i]*dx[i],Y=t.y+w[t.x][t.y][i]*dy[i];</span><br><span class="line">            <span class="keyword">if</span>(w[t.x][t.y][i]&gt;d[t.x][t.y]+<span class="number">1</span>&amp;&amp;dis[X][Y]&gt;dis[t.x][t.y]+d[t.x][t.y]+<span class="number">1</span>)&#123;</span><br><span class="line">                dis[X][Y]=dis[t.x][t.y]+d[t.x][t.y]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!v[X][Y]) q.push((ppap)&#123;X,Y&#125;);</span><br><span class="line">                v[X][Y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[ex][ey]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2384 跃动的串</title>
    <url>/2020/03/27/DTOJ2384-%E8%B7%83%E5%8A%A8%E7%9A%84%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>最近Ori收到了Efi的一个礼物，具体如下:<br>一开始Ori有$n$个$01$串，这些串的总长为$S$，之后Efi会进行$m$次操作，第$i$次操作为$a_i,b_i$，表示将编号为$b_i$的$01$串接在编号为$a_i$的$01$串后面，形成编号为$n+i$个$01$串。Efi为了检验Ori是否有正确进行这些操作，一次操作结束之后Efi会叫Ori找到一个正整数$k$，使得所有长度为$k$的$01$串（一共$2^k$个）都在新增加的第$n+i$个$01$串中。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行：两个整数$n,m$<br>接下来$n$行：每行一个$01$串，分别代表编号从$1 \sim n$的$01$串<br>接下来$m$行：$a_i,b_i$表示一次操作</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一共$m$行：每行输出一个$k$代表答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">101</span><br><span class="line">11111</span><br><span class="line">0</span><br><span class="line">1 2</span><br><span class="line">6 5</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p> 第一次操作之后新产生的$01$串为$0110$，$00$没在串中出现过，因此答案为$1$。<br>第二次操作之后为$01100$，答案为$2$。<br>第三次操作之后为$1111111111$，答案为$0$。</p>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$10 \%$的数据，$n$个$01$串都由$0$组成<br>对于$30 \%$的数据，编号为$a_i$的$01$串长度为$1$<br>对于$30 \%$的数据，$a_i=1$<br>以上部分分不相交<br>对于$100\%$的数据，有$n \leqslant 100,m \leqslant 100,1 \leqslant a_i,b_i \leqslant n+i-1,S \leqslant 100$（注意这里$S$之表示$n$个串的长度和）。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们可以计算得出，答案不大于14（我不知道怎么证明，但是我就是觉得答案小于这个数，事实证明我是对的，而且或许还比我估计的小）<br>因此，我们只需要保存字符串的前14位和后14位就可以了<br>首先，在输入字符串时，我们可以枚举这个字符传中的所有长度小于等于14的子串，把这些子串打上标记，看看对于这个字符串来说，它的$k$是多少<br>接着，对于每次合并字符串的操作，它的前十四位和后十四为就不说了，直接由$a$串和$b$串传递，对于他的所有长度小于等于14的子串的处理，合并前的两个串的长度小于等于14的子串一样还有，主要是中间两段字符串相交的地方，就枚举前面那个字符串的后14位，和后面那个字符串的前14位，并且还必须总长度小于等于14（不然就炸内存了）的所有串，也标记一遍，就可以了<br>具体的实现可以看程序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,len[<span class="number">210</span>],q[<span class="number">210</span>][<span class="number">20</span>],h[<span class="number">210</span>][<span class="number">20</span>],v[<span class="number">210</span>][<span class="number">32770</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ns;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        ns=<span class="built_in">strlen</span>(s),len[i]=min(ns,<span class="number">14</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len[i];j++) q[i][j]=s[j<span class="number">-1</span>]-<span class="string">'0'</span>,h[i][j]=s[ns-j]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=ns<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) <span class="keyword">for</span>(<span class="keyword">int</span> k=j,sum=<span class="number">0</span>;k&gt;=max(<span class="number">0</span>,j<span class="number">-14</span>);k--)&#123;</span><br><span class="line">            sum+=(<span class="number">1</span>&lt;&lt;(j-k))*(s[k]-<span class="string">'0'</span>);</span><br><span class="line">            v[i][sum+(<span class="number">1</span>&lt;&lt;(j-k+<span class="number">1</span>))]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//标记所有长度小于等于14的子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,k,l,flag;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b,n++,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len[a];i++) q[n][i]=q[a][i];<span class="comment">//前14位直接传递</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len[b];i++) h[n][i]=h[b][i];<span class="comment">//后14位直接传递</span></span><br><span class="line">        l=<span class="number">0</span>,k=len[a];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">14</span>&amp;&amp;l&lt;=len[b]) q[n][++k]=q[b][++l];<span class="comment">//前14位直接传递</span></span><br><span class="line">        l=<span class="number">0</span>,k=len[b];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">14</span>&amp;&amp;l&lt;=len[a]) h[n][++k]=h[a][++l];<span class="comment">//后14位直接传递</span></span><br><span class="line">        len[n]=min(len[a]+len[b],<span class="number">14</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">15</span>);i++) v[n][i]=(v[a][i]|v[b][i]);<span class="comment">//标记原来两个串的长度小于等于14子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s=<span class="number">0</span>;i&lt;=len[a];i++)&#123;</span><br><span class="line">            s+=h[a][i]*(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,sum=<span class="number">0</span>;j&lt;=len[b]&amp;&amp;i+j&lt;=<span class="number">14</span>;j++) sum=(sum&lt;&lt;<span class="number">1</span>)+q[b][j],v[n][s*(<span class="number">1</span>&lt;&lt;j)+(<span class="number">1</span>&lt;&lt;(i+j))+sum]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//标记中间两段字符串相交的地方的长度小于等于14的子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">14</span>;j;j--)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;j);k++) <span class="keyword">if</span>(!v[n][k+(<span class="number">1</span>&lt;&lt;j)])&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;ans=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;<span class="comment">//求k</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ2790 DTOJ2809 [CEOI2015 Day2]核能国度(Nuclearia)</title>
    <url>/2020/03/27/LOJ2790-DTOJ2809-CEOI2015-Day2-%E6%A0%B8%E8%83%BD%E5%9B%BD%E5%BA%A6-Nuclearia/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://loj.ac/problem/2790" target="_blank" rel="noopener">原题</a></strong><br><a id="more"></a><br>核能国可以看作一个由$W \times H$的方格组成的矩形。核能国有$N$个核电站，每个核电站占用一个方格。不幸的是，核能国遭遇了百年一遇的特大地震，导致所有的核电站都发生了核泄漏。<br>每个核电站的核泄漏程度可以用两个整数$a, b$来表示。如果位于$P=[x_P,y_P]$的核电站爆炸，方格$C=[x_C,y_C]$会增加$\mathrm{max}(0,a-b\times d(P,C))$贝克的辐射（贝克是单位），其中$d(P,C)$是两个方格的切比雪夫距离，即$d(P,C) =\mathrm{max}(|x_P - x_C|,|y_P - y_C|)$。<br>一个方格可能会受到多处核泄漏的影响。<br>例如，如果一个$a = 7, b = 3$的核电站爆炸了，所在的方格$X$会受到$7$贝克辐射（贝克是单位），满足$d(X,Y) = 1$的$8$个方格$Y$会受到$4$贝克辐射，满足$d(X,Z) = 2$的$16$个方格$Z$会受到$1$贝克辐射。<br>环保部门给了你$Q$组询问，每组询问会划定核能国领土中的一个矩形，请回答：矩形区域内（每个方格）所受的平均辐射量为多少。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个正整数$W$和$H(W × H \leqslant 2.5×10^6)$，分别表示核能国的宽度与高度。<br>第二行，一个正整数$N$，表示核电站的个数$(1 \leq N \leqslant 2×10^5)$。<br>在接下来的$N$行中，每行四个正整数$x_i,y_i,a_i,b_i(1 \leqslant x_i \leqslant W,1 \leqslant y_i \leqslant H,1 \leqslant a_i,b_i \leqslant 10^9)$，表示有一个核电站位于方格$[x_i,y_i]$，它的参数为$a_i$与$b_i​$。每个格子最多有一个核电站。<br>第$N+3$行，一个正整数$Q$，表示询问的次数$(1 \leq Q \leq 2×10^5)$。<br>在接下来的$Q$行中，每行四个 正整数 $x_{1j},y_{1j},x_{2j},y_{2j}(1 \leqslant x_{1j} \leqslant x_{2j} \leqslant W,1 \leqslant y_{1j} \leqslant y_{2j} \leqslant H)$，表示该询问给出的矩形区域的左上角在$[x_{1j},y_{1j}]$且它的右下角在$[x_{2j},y_{2j}]$。<br>你可以假设核能国内的总辐射量少于$2^{63}$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问，输出一行表示给定矩形区域内所有方格的平均辐射量，四舍五入至整数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">2</span><br><span class="line">1 1 7 3</span><br><span class="line">3 2 4 2</span><br><span class="line">4</span><br><span class="line">1 2 2 3</span><br><span class="line">1 1 4 3</span><br><span class="line">4 2 4 2</span><br><span class="line">1 3 4 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>以下为两次爆炸后对每个方格产生的辐射量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 6 3 2</span><br><span class="line">4 6 5 2</span><br><span class="line">1 3 3 2</span><br></pre></td></tr></table></figure></p>
<ol>
<li>$2^2$方形区域内的总辐射为$14$，所以平均值为$14\div 4=3.5$，四舍五入至$4$。</li>
<li>整个核能国的总辐射为$44$，所以平均值为$44\div 12 \approx 3.67$，四舍五入至$4$。</li>
<li>单个格子的平均辐射量就是它所受到的辐射量。</li>
<li>最后一行的平均辐射量为$9\div 4=2.25$，四舍五入至$2$。</li>
</ol>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>有$14$组测试数据。奇数的测试组只包含$a$是$b$的倍数的核电站。对每个子任务的进一步限制如下：<br>|   测试组   |   进一步限制   |   分数   |<br>| —— | —— | —— |<br>|   1   |   $H=1,N\cdot W \leqslant 10^8,Q \cdot W \leqslant 10^8$   |   3   |<br>|   2   |   $H=1,N\cdot W \leqslant 10^8,Q \cdot W \leqslant 10^8$   |   2   |<br>|   3   |   $N\cdot W \cdot H \leq 10^8,Q \cdot W \cdot H \leq 10^8$   |   3   |<br>|   4   |   $N\cdot W \cdot H \leq 10^8,Q \cdot W \cdot H \leq 10^8$   |   2   |<br>|   5   |   $H=1,N\cdot W \leq 10^8$   |   6   |<br>|   6   |   $H=1,N\cdot W \leq 10^8$   |   4   |<br>|   7   |   $N\cdot W \cdot H \leq 10^8$   |   6   |<br>|   8   |   $N\cdot W \cdot H \leq 10^8$   |   4   |<br>|   9   |   $H=1$   |   15   |<br>|   10   |   $H=1$   |   10   |<br>|   11   |   没有符合<strong>界限</strong>定义的爆炸事件   |   15   |<br>|   12   |   没有符合<strong>界限</strong>定义的爆炸事件   |   10  |<br>|   13   |   无   |   12   |<br>|   14   |   无   |   8   |<br>如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作<strong>界限</strong>。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力算法1"><a href="#暴力算法1" class="headerlink" title="暴力算法1"></a>暴力算法1</h2><p>最暴力的算法你能想到什么？枚举！<br>对于每个核电站爆炸事件，枚举它周围的方格受到的影响<br>直接枚举整个国度显得太暴力了，我们能不能稍稍优化一下呢？<br>显然是可以的<br>我们发现，每个核电站爆炸事件有一个“势力范围”<br>只有在这个方格和核电站的切比雪夫距离$\leqslant\frac{a}{b}$时，它才会受影响<br>所以，我们只需要枚举这个核电站的势力范围就可以了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXWH 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUCLEARIA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    huge Info[MAXWH];</span><br><span class="line">    <span class="function">huge&amp; <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> Info[(y * w) + x];&#125;<span class="comment">//其实就是个二维数组</span></span><br><span class="line">&#125;</span><br><span class="line">NUCLEARIA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PLANT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">PLANT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUERY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">    <span class="keyword">int</span> y1;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">&#125;</span><br><span class="line">QUERY;</span><br><span class="line"></span><br><span class="line">NUCLEARIA Nuclearia;</span><br><span class="line">PLANT Plant[MAXN];</span><br><span class="line">QUERY Query[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(huge sum, <span class="keyword">int</span> area)</span><span class="comment">//四舍五入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    huge rsl = sum / area;</span><br><span class="line">    <span class="keyword">if</span>((sum % area) * <span class="number">2</span> &gt;= area)</span><br><span class="line">    &#123;</span><br><span class="line">        rsl++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Plant[i].x), &amp;(Plant[i].y), &amp;(Plant[i].a), &amp;(Plant[i].b));</span><br><span class="line">        Plant[i].x--;</span><br><span class="line">        Plant[i].y--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Query[i].x1), &amp;(Query[i].y1), &amp;(Query[i].x2), &amp;(Query[i].y2));</span><br><span class="line">        Query[i].x1--;</span><br><span class="line">        Query[i].y1--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PLANT&amp; P = Plant[i];</span><br><span class="line">        <span class="keyword">int</span> d = (P.a - <span class="number">1</span>) / P.b;</span><br><span class="line">        <span class="keyword">int</span> x1 = max(<span class="number">0</span>, P.x - d);</span><br><span class="line">        <span class="keyword">int</span> y1 = max(<span class="number">0</span>, P.y - d);</span><br><span class="line">        <span class="keyword">int</span> x2 = min(w, P.x + d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> y2 = min(h, P.y + d + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//势力范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(x, y, P.x, P.y);</span><br><span class="line">                Nuclearia(x, y) += P.a - (d * P.b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QUERY&amp; Q = Query[i];</span><br><span class="line">        huge rsl = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = Q.x1; x &lt; Q.x2; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = Q.y1; y &lt; Q.y2; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                rsl += Nuclearia(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="暴力算法2"><a href="#暴力算法2" class="headerlink" title="暴力算法2"></a>暴力算法2</h2><p>我们发现上面的算法在询问次数很多时是很耗时间的，因为每次我们都需要把矩形的辐射量加一遍<br>所以，我们可以在询问前先预处理一下<br>大家应该知道<a href="https://www.luogu.com.cn/problem/P2280" target="_blank" rel="noopener">激光炸弹</a>吧？我们可以借用一下这种矩阵的预处理方法，就是计算出左上角在$[1,1]$且它的右下角在$[x,y]$的矩形的总辐射，假设是$Nuclearia(x,y)$<br>最终的答案就是$Nuclearia(x_{2j},y_{2j})-Nuclearia(x_{1j}-1,y_{2j})-Nuclearia(x_{2j},y_{1j}-1)+Nuclearia(x_{1j}-1,y_{1j}-1)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXWH 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUCLEARIA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    huge Info[MAXWH];</span><br><span class="line">    <span class="function">huge&amp; <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> Info[(y * w) + x];&#125;<span class="comment">//其实就是个二维数组</span></span><br><span class="line">&#125;</span><br><span class="line">NUCLEARIA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PLANT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">PLANT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUERY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">    <span class="keyword">int</span> y1;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">&#125;</span><br><span class="line">QUERY;</span><br><span class="line"></span><br><span class="line">NUCLEARIA Nuclearia;</span><br><span class="line">PLANT Plant[MAXN];</span><br><span class="line">QUERY Query[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Summarize</span><span class="params">()</span><span class="comment">//预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x) Nuclearia(x, y) += Nuclearia(x - <span class="number">1</span>, y);</span><br><span class="line">            <span class="keyword">if</span>(y) Nuclearia(x, y) += Nuclearia(x, y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y)) Nuclearia(x, y) -= Nuclearia(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(huge sum, <span class="keyword">int</span> area)</span><span class="comment">//四舍五入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    huge rsl = sum / area;</span><br><span class="line">    <span class="keyword">if</span>((sum % area) * <span class="number">2</span> &gt;= area)</span><br><span class="line">    &#123;</span><br><span class="line">        rsl++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Plant[i].x), &amp;(Plant[i].y), &amp;(Plant[i].a), &amp;(Plant[i].b));</span><br><span class="line">        Plant[i].x--;</span><br><span class="line">        Plant[i].y--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Query[i].x1), &amp;(Query[i].y1), &amp;(Query[i].x2), &amp;(Query[i].y2));</span><br><span class="line">        Query[i].x1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].y1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].x2--;</span><br><span class="line">        Query[i].y2--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PLANT&amp; P = Plant[i];</span><br><span class="line">        <span class="keyword">int</span> d = (P.a - <span class="number">1</span>) / P.b;</span><br><span class="line">        <span class="keyword">int</span> x1 = max(<span class="number">0</span>, P.x - d);</span><br><span class="line">        <span class="keyword">int</span> y1 = max(<span class="number">0</span>, P.y - d);</span><br><span class="line">        <span class="keyword">int</span> x2 = min(w, P.x + d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> y2 = min(h, P.y + d + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//势力范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(x, y, P.x, P.y);</span><br><span class="line">                Nuclearia(x, y) += P.a - (d * P.b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Summarize();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QUERY&amp; Q = Query[i];</span><br><span class="line">        huge rsl = Nuclearia(Q.x2, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.x1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x1, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.y1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x2, Q.y1);</span><br><span class="line">        <span class="keyword">if</span>((Q.x1 &gt;= <span class="number">0</span>) &amp;&amp; (Q.y1 &gt;= <span class="number">0</span>)) rsl += Nuclearia(Q.x1, Q.y1);</span><br><span class="line">        </span><br><span class="line">        Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>接着，我们尝试在进一步的优化<br>回想一下我们在利用树状数组做区间修改时的方法：把区间的前面标记为$+a$，最后面标记为$-a$，这样，就可以进行区间修改了<br>我们可以借用一下这个思路，来标记一次核电站爆炸事件<br>首先，我们先找出这个核电站爆炸事件的“势力范围”，接着，把“势力范围”的左上角和右下角标记为$+a\% b$，把左下角和右上角标记为$-a\% b$<br>然后，我们开两个数组，在这个“势力范围”的对角线上（两条对角线，所以要两个数组）存储$b$的值，为了节省时间，我们可以只在4个角上标记，最后再把对角线上的数全部加出来<br>因为每个核电站爆炸事件的影响相等方格的，都会围成一个正方形（因为取的是切比雪夫距离），也就是说，我们在统计时，只需要先把对角线上的数复制到$Nuclearia$数组中，再把左边的和上面的数相加再减去左上的数就可以了<br>看起来有点抽象，我们可以再总结一下：</p>
<ol>
<li>对于每个核电站爆炸事件，计算出它的“势力范围”，左上角为$(x1,y1)$，右下角为$(x2,y2)$</li>
<li>标记：$Nuclearia(x1,y1) = Nuclearia(x2,y2) = a\% b$，$Nuclearia(x1,y2) = Nuclearia(x2,y1) = a\% b$</li>
<li>修改两条对角线上的值（两条对角线的数组分别为$PosDiag$（主对角线）和$NegDiag$（次对角线））：$PosDiag(x1+1,y1+1)=b,PosDiag(x2,y2)=-b,NegDiag(x1+1,y2-1)=-b,NegDiag(x2,y1)=b$</li>
<li>枚举整个国度的$PosDiag$和$NegDiag$，$PosDiag(x,y)+=PosDiag(x-1,y-1),NegDiag(x,y)+=NegDiag(x-1,y+1)$</li>
<li>枚举整个国度的$Nuclearia$，$Nuclearia(x,y)+=PosDiag(x,y)+NegDiag(x,y)$</li>
<li>重复两次：枚举整个国度的$Nuclearia$，$Nuclearia(x,y)+=Nuclearia(x-1,y)+Nuclearia(x,y-1)-Nuclearia(x-1,y-1)$<br>这就是整个过程了，最后的答案计算方法和上面一样<br>你以为这就完了吗？<br><strong>不！没完！</strong><br>注意题目的最后一句话：<code>如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作界限</code><br>也就是说$x1$和$y1$有可能$\leqslant 0$，$x2$也有可能$&gt;W$，$y2$也有可能$&gt;H$！<br>对于这个的处理，我们需要再开两个数组$Col$和$Row$，存储超出边界的部分，具体的实现就看程序吧，这些细节的处理，这里就不再细讲了<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXWH 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUCLEARIA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    huge Info[MAXWH];</span><br><span class="line">    <span class="function">huge&amp; <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> Info[(y * w) + x];&#125;</span><br><span class="line">&#125;</span><br><span class="line">NUCLEARIA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PLANT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">PLANT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUERY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">    <span class="keyword">int</span> y1;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">&#125;</span><br><span class="line">QUERY;</span><br><span class="line"></span><br><span class="line">NUCLEARIA Nuclearia, PosDiag, NegDiag;</span><br><span class="line">PLANT Plant[MAXN];</span><br><span class="line">QUERY Query[MAXQ];</span><br><span class="line">huge Row[MAXWH];</span><br><span class="line">huge Col[MAXWH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdatePosDiag</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x1 &lt; <span class="number">0</span>) &amp;&amp; (y1 &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -max(x1, y1);</span><br><span class="line">        Nuclearia(<span class="number">0</span>, <span class="number">0</span>) += m * b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -x1;</span><br><span class="line">        Col[y1] += b;</span><br><span class="line">        Col[y1 + m] -= b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -y1;</span><br><span class="line">        Row[x1] += b;</span><br><span class="line">        Row[x1 + m] -= b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PosDiag(x1, y1) += b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((x2 + <span class="number">1</span> &lt; w) &amp;&amp; (y2 + <span class="number">1</span> &lt; h)) PosDiag(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>) -= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateNegDiag</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y2 &gt; h - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = y2 - (h - <span class="number">1</span>);</span><br><span class="line">        x1 += m;</span><br><span class="line">        y2 -= m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -x1;</span><br><span class="line">        Col[(y2 - m) + <span class="number">1</span>] -= b;</span><br><span class="line">        <span class="keyword">if</span>(y2 + <span class="number">1</span> &lt; h) Col[y2 + <span class="number">1</span>] += b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y2 -= m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((x1 &lt; w) &amp;&amp; (y2 &gt;= <span class="number">0</span>)) NegDiag(x1, y2) -= b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x2 &gt; w - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = x2 - (w - <span class="number">1</span>);</span><br><span class="line">        x2 -= m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -y1;</span><br><span class="line">        Row[(x2 - m) + <span class="number">1</span>] -= b;</span><br><span class="line">        <span class="keyword">if</span>(x2 + <span class="number">1</span> &lt; w) Row[x2 + <span class="number">1</span>] += b;</span><br><span class="line">        x2 -= m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((x2 + <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (x2 + <span class="number">1</span> &lt; w) &amp;&amp; (y1 - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (y1 - <span class="number">1</span> &lt; h)) NegDiag(x2 + <span class="number">1</span>, y1 - <span class="number">1</span>) += b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SummarizeDiags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y)) PosDiag(x, y) += PosDiag(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y != h - <span class="number">1</span>)) NegDiag(x, y) += NegDiag(x - <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddDiags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            Nuclearia(x, y) += PosDiag(x, y);</span><br><span class="line">            Nuclearia(x, y) += NegDiag(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SummarizeLines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        Row[x] += Row[x - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt; h; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        Col[y] += Col[y - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddLines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        Nuclearia(x, <span class="number">0</span>) += Row[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        Nuclearia(<span class="number">0</span>, y) += Col[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Summarize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x) Nuclearia(x, y) += Nuclearia(x - <span class="number">1</span>, y);</span><br><span class="line">            <span class="keyword">if</span>(y) Nuclearia(x, y) += Nuclearia(x, y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y)) Nuclearia(x, y) -= Nuclearia(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(huge sum, <span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    huge rsl = sum / area;</span><br><span class="line">    <span class="keyword">if</span>((sum % area) * <span class="number">2</span> &gt;= area)</span><br><span class="line">    &#123;</span><br><span class="line">        rsl++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Plant[i].x), &amp;(Plant[i].y), &amp;(Plant[i].a), &amp;(Plant[i].b));</span><br><span class="line">        Plant[i].x--;</span><br><span class="line">        Plant[i].y--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Query[i].x1), &amp;(Query[i].y1), &amp;(Query[i].x2), &amp;(Query[i].y2));</span><br><span class="line">        Query[i].x1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].y1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].x2--;</span><br><span class="line">        Query[i].y2--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PLANT&amp; P = Plant[i];</span><br><span class="line">        <span class="keyword">int</span> d = (P.a - <span class="number">1</span>) / P.b;</span><br><span class="line">        <span class="keyword">int</span> x1 = P.x - d;</span><br><span class="line">        <span class="keyword">int</span> y1 = P.y - d;</span><br><span class="line">        <span class="keyword">int</span> x2 = P.x + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y2 = P.y + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = P.a % P.b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r)</span><br><span class="line">        &#123;</span><br><span class="line">            Nuclearia(max(<span class="number">0</span>, x1), max(<span class="number">0</span>, y1)) += r;</span><br><span class="line">            <span class="keyword">if</span>(x2 &lt; w) Nuclearia(x2, max(<span class="number">0</span>, y1)) -= r;</span><br><span class="line">            <span class="keyword">if</span>(y2 &lt; h) Nuclearia(max(<span class="number">0</span>, x1), y2) -= r;</span><br><span class="line">            <span class="keyword">if</span>((x2 &lt; w) &amp;&amp; (y2 &lt; h)) Nuclearia(x2, y2) += r;</span><br><span class="line">            </span><br><span class="line">            x1++;</span><br><span class="line">            y1++;</span><br><span class="line">            x2--;</span><br><span class="line">            y2--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(P.a &gt;= P.b)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdatePosDiag(x1, y1, x2, y2, P.b);</span><br><span class="line">            UpdateNegDiag(x1, y1, x2, y2, P.b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SummarizeDiags();</span><br><span class="line">    AddDiags();</span><br><span class="line">    SummarizeLines();</span><br><span class="line">    AddLines();</span><br><span class="line">    Summarize();</span><br><span class="line">    Summarize();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QUERY&amp; Q = Query[i];</span><br><span class="line">        huge rsl = Nuclearia(Q.x2, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.x1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x1, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.y1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x2, Q.y1);</span><br><span class="line">        <span class="keyword">if</span>((Q.x1 &gt;= <span class="number">0</span>) &amp;&amp; (Q.y1 &gt;= <span class="number">0</span>)) rsl += Nuclearia(Q.x1, Q.y1);</span><br><span class="line">        </span><br><span class="line">        Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>LOJ</tag>
        <tag>CEOI</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3320 GotoAndPlay</title>
    <url>/2020/03/27/DTOJ3320-GotoAndPlay/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小松鼠终于吃撑了，她决定逃离这个地方<br>我们用一张连通图来表示整个西湖的范围，每棵容小松鼠逗留的树都用这张图上的一个点来表示。小松鼠能够通过只跳一次互相到达的两棵树用图上的一条无向边来连接<br>吃撑了的小松鼠有些神志不清，每次她连跳两条边之后才会在到达的那个点上休息。她想知道，是否存在一种连续的跳法，使得她有机会在所有的树上都休息至少一次<br>对于这种跳法，你可以任选起点，允许重复经过边，允许重复经过点<br>但是超萌小松鼠是一只有梦想的小松鼠，她有时能够突破自己的极限，使一些原本无法互相到达的两个点能够通过一次跳跃互相到达</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数$n,m$，$n$表示点的个数，$m$表示边的条数<br>接下来$m$行，每行两个数$x_i,y_i$，表示$x_i$和$y_i$之间能够通过一次跳跃互相到达<br>接下来一行一个数$q$，表示询问的个数<br>接下来$q$行，其中的第$i$行每行两个数$a_i,b_i$，表示在原图的基础上加上从$a_i$到$b_i$ 的边。即成为一张$n$个点$m+1$条边的图<br>保证给出的原图是个连通图，$1 \leqslant a_i,b_i,x_i,y_i \leqslant n$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一共$q$行，对于第$i$个询问，当在原图的基础上加上$a_i$与$b_i$间的无向边后，如果小松鼠能够找到一种连续的跳法，使得她有机会在所有的树上至少休息一次，输出一行“Yes”，否则输出一行“No”（不包含引号）</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2</span><br><span class="line">1 1 </span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于前$50\%$，$n,q \leqslant 10^3,m \leqslant 2 \times 10^3$<br>对于$100\%$，$n,q \leqslant 10^5,m \leqslant 2 \times 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接对整个图进行二分图染色，那么松鼠的这种跳法只允许跳过同一种颜色的节点<br>所以接下来就很简单了：只有在发现全图能被染成一种颜色或者添加的边的两端是同一种颜色，这个询问才是对的，否则就是错的<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,q,tot,flag,head[<span class="number">100010</span>],to[<span class="number">400010</span>],nxt[<span class="number">400010</span>],t[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[u]=ty;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[to[i]]&lt;<span class="number">0</span>) dfs(to[i],(ty+<span class="number">1</span>)%<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[to[i]]==ty) flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) t[i]=<span class="number">-1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(flag||t[x]==t[y]) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1678 Tree</title>
    <url>/2020/03/27/DTOJ1678-Tree/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200327164411941.png" alt="在这里插入图片描述"></p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p><img src="https://img-blog.csdnimg.cn/2020032716444363.png" alt="在这里插入图片描述"></p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p><img src="https://img-blog.csdnimg.cn/20200327164459366.png" alt="在这里插入图片描述"></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">QUERY 1 2</span><br><span class="line">CHANGE 1 3</span><br><span class="line">QUERY 1 2</span><br><span class="line">DONE</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://www.spoj.com/problems/QTREE/" target="_blank" rel="noopener">SP375</a>的变体，树链剖分好题<del>一个lazy标志传递错误让我调了半天……</del><br>先把边权化为点权，建一张新图<br>对这张新图跑树链剖分，建一棵线段树来维护区间最大和最小值（正常是只需要最大值，但是因为要去相反数，所以需要维护最小值）<br>对于$3$个操作：</p>
<ol>
<li>修改单边权：直接单点修改就可以了</li>
<li>路径取反：划分一下重链，直接区间修改，最大值和最小值取反后交换就好了</li>
<li>路径查询：划分重链，直接区间查询最大值</li>
</ol>
<p>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(X) t[X].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(X) t[X].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d(X) t[X].max</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x(X) t[X].min</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(X) t[X].add</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,max,min,add;</span><br><span class="line">&#125;t[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">int</span> n,tot,U[<span class="number">100010</span>],V[<span class="number">100010</span>],head[<span class="number">100010</span>],to[<span class="number">200010</span>],ver[<span class="number">200010</span>],nxt[<span class="number">200010</span>],big[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,top[<span class="number">100010</span>],dep[<span class="number">100010</span>],siz[<span class="number">100010</span>],dfn[<span class="number">100010</span>],fa[<span class="number">100010</span>],wei[<span class="number">100010</span>],sor[<span class="number">100010</span>],p[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v,ver[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u]=Fa,dep[u]=dep[Fa]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=Fa)&#123;</span><br><span class="line">        wei[to[i]]=ver[i],dfs1(to[i],u),siz[u]+=siz[to[i]],p[(i<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>]=to[i];</span><br><span class="line">        <span class="keyword">if</span>((!big[u])||siz[to[i]]&gt;siz[big[u]]) big[u]=to[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,sor[cnt]=u,top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(!big[u]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(big[u],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[u]&amp;&amp;to[i]!=big[u]) dfs2(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l(p)=l,r(p)=r,d(p)=<span class="number">0x7fffffff</span>,x(p)=<span class="number">-0x7fffffff</span>,a(p)=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;d(p)=x(p)=wei[sor[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    d(p)=max(d(p*<span class="number">2</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)),x(p)=min(x(p*<span class="number">2</span>),x(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a(p))&#123;</span><br><span class="line">        <span class="keyword">int</span> temp,add=a(p);</span><br><span class="line">        a(p)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(add&amp;<span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">        temp=d(p*<span class="number">2</span>),d(p*<span class="number">2</span>)=-x(p*<span class="number">2</span>),x(p*<span class="number">2</span>)=-temp,a(p*<span class="number">2</span>)+=add;</span><br><span class="line">        temp=d(p*<span class="number">2</span>+<span class="number">1</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)=-x(p*<span class="number">2</span>+<span class="number">1</span>),x(p*<span class="number">2</span>+<span class="number">1</span>)=-temp,a(p*<span class="number">2</span>+<span class="number">1</span>)+=add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l(p)==r(p))&#123;d(p)=x(p)=d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) change(p*<span class="number">2</span>,x,d);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>,x,d);</span><br><span class="line">    d(p)=max(d(p*<span class="number">2</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)),x(p)=min(x(p*<span class="number">2</span>),x(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Negate</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r)&#123;<span class="keyword">int</span> temp=d(p);d(p)=-x(p),x(p)=-temp,a(p)++;<span class="keyword">return</span>;&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) Negate(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) Negate(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    d(p)=max(d(p*<span class="number">2</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)),x(p)=min(x(p*<span class="number">2</span>),x(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r)&#123;<span class="keyword">return</span> d(p);&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=max(ans,ask(p*<span class="number">2</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=max(ans,ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w),U[i]=u,V[i]=v,add(u,v,w),add(v,u,w);</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>),dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'D'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) change(<span class="number">1</span>,dfn[p[a]],b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'N'</span>)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> ta=top[a],tb=top[b];ta!=tb;)</span><br><span class="line">    		    <span class="keyword">if</span>(dep[ta]&gt;dep[tb]) Negate(<span class="number">1</span>,dfn[ta],dfn[a]),a=fa[ta],ta=top[a];</span><br><span class="line">    		    <span class="keyword">else</span> Negate(<span class="number">1</span>,dfn[tb],dfn[b]),b=fa[tb],tb=top[b];</span><br><span class="line">    		<span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">if</span>(dep[a]&lt;dep[b]) Negate(<span class="number">1</span>,dfn[big[a]],dfn[b]);</span><br><span class="line">    		<span class="keyword">else</span> Negate(<span class="number">1</span>,dfn[big[b]],dfn[a]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123; </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> ta=top[a],tb=top[b];ta!=tb;)</span><br><span class="line">    		    <span class="keyword">if</span>(dep[ta]&gt;dep[tb]) ans=max(ans,ask(<span class="number">1</span>,dfn[ta],dfn[a])),a=fa[ta],ta=top[a];</span><br><span class="line">                <span class="keyword">else</span> ans=max(ans,ask(<span class="number">1</span>,dfn[tb],dfn[b])),b=fa[tb],tb=top[b];</span><br><span class="line">    		<span class="keyword">if</span>(a==b)&#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    		<span class="keyword">if</span>(dep[a]&lt;dep[b]) ans=max(ans,ask(<span class="number">1</span>,dfn[big[a]],dfn[b]));</span><br><span class="line">    		<span class="keyword">else</span> ans=max(ans,ask(<span class="number">1</span>,dfn[big[b]],dfn[a]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1049 欢乐送</title>
    <url>/2020/03/27/DTOJ1049-%E6%AC%A2%E4%B9%90%E9%80%81/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>天下最欢乐的事情就是大家在做题的时候<code>moreD</code>送分给大家。现在就让大家欢乐一下<br>首先大家排排坐，坐成一排<br><code>moreD</code>会给大家送分，他会时而选择区间，从左到右依次用魔法给大家送分，最左边的孩子送$1$分，第二个送$2$分……以此类推<br>有时<code>moreD</code>会询问一个孩子到底已经被送了多少分<br>只要你能每次都迅速而正确地回答出<code>moreD</code>的问题，你就可以得到出题人送的分了，两天总得分最高的孩子可以得到神秘礼物</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数$N,M$，表示有$N$个孩子，出题人有$M$次操作<br>接下来$M$行，每行代表一个操作<br>第一个字符为$c_i$,若$c_i=$<code>C</code>则此次操作为送分操作，接下来会有两个整数$L_i,R_i$，表示此次送分的区间<br>若$c_i=$<code>Q</code>，则此次操作为询问操作，接下来一个整数$x_i$，表示询问第$x_i$个孩子的当前得分数</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组询问输出一行，仅包含一个整数，表示答案对$1000000007$取$mod$的结果</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">C 1 3</span><br><span class="line">Q 2</span><br><span class="line">C 2 3</span><br><span class="line">Q 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据$N,M\leqslant 1000$<br>对于$100\%$的数据$N,M\leqslant 100000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树状数组好题<br>看到这个形式，很容易让人想起树状数组的区间修改和区间求和（<a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ3468</a>）<br>但是增加的值是一个等差数列啊<br>那么，我们可以来化简一下这个式子<br>假设我们要查询第$x$个，答案为$ans_x$，那么，我们假设所有修改中，满足$L\leqslant x$且$R\geqslant x$的为$(L_1,R_1),(L_2,R_2),\cdots\cdots (L_{len},R_{len})$<br>那么，$ans_x=\sum\limits_{i=1}^{len}(x-L_i+1)=len\times (x+1)-\sum\limits_{i=1}^{len}L_i$<br>所以，我们只需要知道$len$和$\sum\limits_{i=1}^{len}L_i$就可以了<br>这两个量非常好求，开两个树状数组，对于每个$(L_i,R_i)$，第一个树状数组的$L_i$处$+1$，$R_i+1$处$-1$，第二个树状数组的$L_i$处$+L_i$，$R_i+1$处$-L_i$就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y,MOD=<span class="number">1e9</span>+<span class="number">7</span>,c1[<span class="number">100010</span>],c2[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> X,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=(x&amp;(-x))) c1[x]+=flag*X,c2[x]+=flag;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;long long,long long&gt; ask(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=(x&amp;(-x))) s1+=c1[x],s2+=c2[x];</span><br><span class="line">    <span class="keyword">return</span> make_pair(s1,s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s%lld"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>) ans=ask(x),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(((x+<span class="number">1</span>)*ans.second%MOD-ans.first)%MOD+MOD)%MOD);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;y),add(x,x,<span class="number">1</span>),add(y+<span class="number">1</span>,x,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2460 拜访女神</title>
    <url>/2020/03/27/DTOJ2460-%E6%8B%9C%E8%AE%BF%E5%A5%B3%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>TRT出国后，想找一个好的位置住下来。而他所在的城市，恰好有N栋建筑(从$1\sim n$编号)，他会选择这些建筑的某一个居住<br>而建筑之间，有$M$条双向路相连。每条道路有一个起始点$u$，终止点$v$，以及走过这条道路所需的时间$d$<br>所有建筑都可以借助一些道路相互到达<br><code>TRT</code>每天会从他的住房出发，按任意顺序拜访他的$K$个女神（他想怎么走就怎么走），不过由于<code>TRT</code>精力(???)有限，他的女神个数不会超过$12$个<br>可他的女神们都比较娇气，希望<code>TRT</code>尽快来看她们<del>可她们却不会担心TRT的花心……</del><br>对于第$i$个女神，她住在第p[i]栋建筑物，她每等$x$分钟(从<code>TRT</code>离家的那一时刻开始计算)，她的焦急程度（初始为$0$）就会增加$x$<br><code>TRT</code>当然希望她们高兴越好，而且他也不会让某个女神特别伤心，所以他希望所有女神的焦急程度的最大值越小越好<br>且他也不希望与任何一个女神住在一起,要不然会被众人黑成傻逼的<del>虽然他已经被我们黑成傻逼了</del><br>所以他向你求助，帮他找出他应该住的那栋建筑，以及此时所有女神焦急程度最大值</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：三个正整数$N,M,K$<br>第二行: $K$个正整数 第$i$个正整数即是$p_i$<br>第$3\sim M+2$行：描述这些道路 对于每一行 三个正整数描述这条道路$u,v,d$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p> 一行包含两个数<br>第一个是他所住的建筑物的编号（如果有多种选择，请输出编号最小的那一个）<br>第二个是所有女神的焦急程度的最大值的最小值</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 10 2</span><br><span class="line">2 5</span><br><span class="line">1 5 2</span><br><span class="line">5 6 3</span><br><span class="line">6 2 4</span><br><span class="line">5 3 1</span><br><span class="line">6 3 2</span><br><span class="line">2 3 3</span><br><span class="line">1 2 4</span><br><span class="line">1 4 3</span><br><span class="line">3 4 5</span><br><span class="line">2 4 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p><code>TRT</code>在$3$号建筑安家。他每天的行走路线为$3\rightarrow 5\rightarrow 3\rightarrow 2$<br>到达$5$号建筑的时刻是$1$，那位女神的焦急程度是$1$<br>到达$2$号建筑的时间是$5$，那位女神的焦急程度是$5$，最大是$5$<br>接下来他爱走哪走哪，反正他已经拜访 <del>（∗∗）</del> 了所有女神。 可以证明其它方法不比这更优</p>
<h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于$20\%$的数据$N\leqslant 8,M\leqslant 15$<br>对于另外$20\%$的数据$K=1$<br>对于$60\%$的数据$K\leqslant 5$<br>对于$100\%$的数据$N\leqslant 10^4,M\leqslant 5\times 10^4,K\leqslant 12,N&gt;K,1\leqslant p_i,u,v\leqslant N,d\leqslant 10^4$<br>本题后$80\%$的数据保证随机</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看看这个$k$，它这么小，难道不香吗？<br>显然是个状压DP<br>首先跑$k$遍SPFA，把图压缩成只包含女神的住处，边为两两的最短路的图<br>设$f_{i,j,s}$表示起点为$i$，当前城市为$j$，遍历状态为$s$的最短时间<br>转移就是直接枚举上一个拜访的女神的房子，最后加上到起点的最近城市的距离就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,ver;</span><br><span class="line">&#125;e[<span class="number">100010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,k,tot,h,ans,p[<span class="number">20</span>],w[<span class="number">10010</span>],head[<span class="number">10010</span>],dis[<span class="number">20</span>][<span class="number">10010</span>],v[<span class="number">10010</span>],f[<span class="number">20</span>][<span class="number">20</span>][<span class="number">10010</span>],g[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].to=v,e[tot].ver=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v)),dis[k][x]=<span class="number">0</span>,v[x]=<span class="number">1</span>,q.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt) <span class="keyword">if</span>(dis[k][e[i].to]&gt;dis[k][u]+e[i].ver)&#123;</span><br><span class="line">            dis[k][e[i].to]=dis[k][u]+e[i].ver;</span><br><span class="line">            <span class="keyword">if</span>(!v[e[i].to]) q.push(e[i].to),v[e[i].to]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"godness.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"godness.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]),w[p[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(dis)),<span class="built_in">memset</span>(f,<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(f)),<span class="built_in">memset</span>(g,<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(g)),ans=g[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) spfa(i,p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        f[i][i][<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));s&lt;(<span class="number">1</span>&lt;&lt;k);s++) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=k;t++) <span class="keyword">if</span>(!(s&amp;(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))))</span><br><span class="line">                f[i][t][s|(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))]=min(f[i][t][s|(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))],f[i][j][s]+dis[j][p[t]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) g[i]=min(g[i],f[i][j][(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!w[i]) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) <span class="keyword">if</span>(g[j]+dis[j][i]&lt;ans) ans=g[j]+dis[j][i],h=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,h,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2431 棋盘路径</title>
    <url>/2020/03/27/DTOJ2431-%E6%A3%8B%E7%9B%98%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>像南京这样的213城市，天气总是不太友好<br>周三下午是模电实验课，<code>xy</code>正打算从宿舍$(0,0)$去实验楼$(n,m)$上课，然而他突然发现，由于暴雨的缘故，有$k$个路口$(x,y)$已经被水淹没（不知所措），根本过不了人<br><code>xy</code>行走的路线很特别，必须满足</p>
<ol>
<li>一定平行于坐标轴</li>
<li>只能在横纵坐标都是整数的点改变方向</li>
<li>行走过程中横坐标和纵坐标始终不减小<br>现在有<code>xy</code>想知道有多少条满足条件的路线可以避开被淹没的路口到达实验楼<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>第$1$行是两个非负整数$n$和$m$，表示实验楼的坐标<br>第$2$行是一个正整数$k$，表示有$k个路口被淹没<br>接下来$k$行，每行有两个非负整数$x$和$y$，表示$(x,y)$这个路口已被淹没<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>仅一行，一个非负整数，为满足条件的路线数对$1000000007$取模的值<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>对于$30\%$的数据，满足$0\leqslant n,m\leqslant 1000,0\leqslant k\leqslant 100$<br>对于$70\%$的数据，满足$0\leqslant n,m\leqslant 100000,0\leqslant k\leqslant 100$<br>对于$100\%$的数据，满足$0\leqslant n,m\leqslant 100000,0\leqslant k\leqslant 3000$<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>又是一道沙雕题……<del>又只有我这个沙雕错了</del><br>先将所有被淹没的路口排序，排序后进行容斥<br>就是用总路径数减掉前面所有的被淹没的路口到这个被淹没的路口的路径数乘以前面那个被淹没的路口的路径数（容斥完的路径数）<br>思路极易理解<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;q[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>,f[<span class="number">200010</span>],jc[<span class="number">200010</span>],ny[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;n||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> jc[n]*ny[m]%MOD*ny[n-m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">way</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> C(x2-x1+y2-y1,x2-x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">200005</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%MOD; </span><br><span class="line">    ny[<span class="number">200004</span>]=POW(jc[<span class="number">200004</span>],MOD<span class="number">-2</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">200003</span>;i&gt;=<span class="number">0</span>;i--) ny[i]=ny[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].x,&amp;q[i].y); </span><br><span class="line">    sort(q+<span class="number">1</span>,q+k+<span class="number">1</span>,cmp);</span><br><span class="line">    q[++k].x=n,q[k].y=m,f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        f[i]=way(<span class="number">0</span>,<span class="number">0</span>,q[i].x,q[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) f[i]=(f[i]-f[j]*way(q[j].x,q[j].y,q[i].x,q[i].y)%MOD+MOD)%MOD; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>组合</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2229 抢车位</title>
    <url>/2020/03/27/DTOJ2229-%E6%8A%A2%E8%BD%A6%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>很久以前 ，<code>cxm</code>做了一个题，叫“抢车位”，大意是让你调度的汽车 使得每个汽车都有位。<code>AC</code>以后，<code>cxm</code>去实地考察了这个游戏 ，发现最有意思的地方是“以旧换新”：你最多拥有$10$辆汽车， 便宜的汽车换贵只用补差价<br>但是贵的汽车不能换便宜，价格相同的汽车也不能互换 。每个汽车有一个赚钱速度，即每分钟会从这汽车得到多少的钱<br>假定汽车在任何时候都要赚钱 (在原游戏中即为始终能找到位置停车)，<code>cxm</code>发现需要设计一个换车的策略，使得自己以最快的速度拥有$M$的资产 (资产包括现金 + 汽车的价值，这个$M$大于等于最贵车价格的$2$倍的)<br><code>cxm</code>想了一个算法，于是这次简化版：只考虑有$2$辆汽车的情况，规则与游戏中稍不同，收益是随时发放和均摊的 ，即如果收益为$7$金每分钟，你可以在$\frac{3}{14}$分钟的时候得到$1.5$金<br>最开始你的“汽车”为$2$辆价值为$0$， 赚钱速度为$1$金每分钟的$11$路汽车</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数$N$和$M$，表示有$N$种汽车和最终需要达到的资产<br>接下来$N$行，每两个正整数$w_i$和$v_i$，表示第 i种汽车的价值为$w_i$金，赚钱 速度为$v_i$金每分钟</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>包含一行一个浮点数(不限位数)，表示达到$M$的资产最少需要的时间<br>只要你的答案与标准答案差别不超过$0.001$我们就认为你的答案是正确的（正式评测时我们用<code>C++</code>的<code>double</code>类型存储你的答案和标准答案并参与判断）</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 200</span><br><span class="line">10 2</span><br><span class="line">15 3</span><br><span class="line">100 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36.4762</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 200</span><br><span class="line">20 2</span><br><span class="line">50 3</span><br><span class="line">51 100</span><br><span class="line">100 99</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21.2418</span><br></pre></td></tr></table></figure>
<h3 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 200</span><br><span class="line">10 2</span><br><span class="line">20 2</span><br><span class="line">50 3</span><br><span class="line">51 100</span><br></pre></td></tr></table></figure>
<h3 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19.425199</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h3><p>第一步：将第一辆换成第一种车<br>第二步：将第一辆换成第二种车<br>第三步：将第二辆换成第一种车<br>第四步：将第二辆换成第二种车<br>第五步：将第一辆换成第三种车<br>第六步：等待赚够$85$金的现金(也可以认为将第二辆换成了第三种车然后等待赚够$0$金)<br>总共耗时$\frac{10}{2}+\frac{5}{3}+\frac{10}{4}+\frac{5}{5}+\frac{85}{6}+\frac{85}{7}\approx 36.4762$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>有$20\%$的数据$N\leqslant 10$<br>另有$20\%$的数据$N\leqslant 30$且$M\leqslant 2000$<br>有$60\%$的数据$N\leqslant 300$<br>$100\%$的数据$N\leqslant 3000,M&lt;=10^9,2w_i\leqslant M,2\leqslant v_i\leqslant 10^5$</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>BJWC2015</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不得不说，这真是一个沙雕题……<del>只有我这个沙雕错了……</del><br>首先，那些$w_i$增加，$v_i$减少或者不变的汽车都没有用（显然）<br>假设去掉之后只有$len$种车且从小到大排序好了<br>最优的方法显然是把两辆车都从$(w_1,v_1)$一直换到$(w_{len},v_{len})$（显然）<br>所以，我们只需要计算$f_{i,j}$，表示把第一辆车变成第$i$种车，并把第二辆车变成第$j$种车花的钱<br>由此，我们可以列出递推式：$f_{i,j}=min(f_{i,j-1}+\frac{w_j}{v_i+v_{j-1}},f_{i-1,j}+\frac{w_i}{v_{i-1}+v_j})$<br>直接暴力计算即可，效率$\Theta(len^2)$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">&#125;c[<span class="number">3010</span>],q[<span class="number">3010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len,s;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.w&lt;b.w||(a.w==b.w&amp;&amp;a.v&gt;b.v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),q[<span class="number">0</span>].w=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">0</span>].v=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c[i].w,&amp;c[i].v);</span><br><span class="line">    sort(c+<span class="number">1</span>,c+n+<span class="number">1</span>,cmp);<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(q[len].w&lt;c[i].w&amp;&amp;q[len].v&lt;c[i].v) q[++len]=c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) f[i][<span class="number">0</span>]=f[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1.0</span>*(q[i].w-q[i<span class="number">-1</span>].w)/(q[i<span class="number">-1</span>].v+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) f[<span class="number">0</span>][i]=f[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1.0</span>*(q[i].w-q[i<span class="number">-1</span>].w)/(q[i<span class="number">-1</span>].v+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">        f[i][j]=min(f[i<span class="number">-1</span>][j]+<span class="number">1.0</span>*(q[i].w-q[i<span class="number">-1</span>].w)/(q[i<span class="number">-1</span>].v+q[j].v),f[i][j<span class="number">-1</span>]+<span class="number">1.0</span>*(q[j].w-q[j<span class="number">-1</span>].w)/(q[j<span class="number">-1</span>].v+q[i].v));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>,f[len][len]+<span class="number">1.0</span>*(m-q[len].w*<span class="number">2</span>)/(q[len].v*<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2450 梦灵苏魅</title>
    <url>/2020/03/27/DTOJ2450-%E6%A2%A6%E7%81%B5%E8%8B%8F%E9%AD%85/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>紫雅拥有七彩的头发，身穿樱花色的七彩裙子，这种梦幻般的外貌自然能够吸引所有男人的目光<br>紫雅为了展示自己的才华，开始在这个国家跳起了芭蕾<br>已知这个国家的城市和道路刚好形成一颗完全二叉树，从位于根节点的城市开始广度优先依次将城市编号为$1\sim N$<br>紫雅在这个国家一共表演$M$天，每天会从某个城市开始，经过若干条道路（不会回头），从而到达某个城市进行芭蕾表演<br>每个城市都有人口数量$A_i$，紫雅希望知道，对于她这一天的行动，她所有可能表演的城市的人口之和为多少</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行$2$个正整数$N,M$<br>接下来$N$行每行$1$个整数$A_i$，为第$i$个城市的人口数量<br>接下来$M$行每行$2$个正整数$B_j, P_j$，表示第j天紫雅的起点城市的编号以及经过的道路的数量</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$M$行，每行$1$个非负整数$C_i$,为第$j$天所有可能表演的城市的人口数量之和<br>如果不存在这种城市，则答案为$0$</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 3</span><br><span class="line">13</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">18</span><br><span class="line">27</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>第一天：$1$号城市位于该树的根节点。不存在经过$3$条不重复的道路所能到达的城市<br>第二天：$4$号城市位于该树的叶节点，经过$2$条道路可到达$1$号城市和$5$号城市，故答案为$13+5=18$<br>第三天：$3$号城市位于$1$号城市的子节点处，经过$1$条道路可到达$1$号城市，$6$号城市和$7$号城市。故答案为$13+6+8=27$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$50\%$的数据：$1\leqslant N\leqslant 1023,1\leqslant M\leqslant 1000$<br>对于$100\%$的数据：$1\leqslant N\leqslant 131071,1\leqslant M\leqslant 100000$，且$N=2t-1,t\in \N^+,1\leqslant Ai\leqslant 30000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设$f_{i,j}$为从$i$出发，往下走$j$步能到达的点的权值和，$g_{i,j}$为从$i$出发，往上走$j$步能到达的点的权值和<br>所以我们可以直接用DFS求$f$和$g$<br>最后的答案就是$f$、$g$的和了！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//班上某同学的代码，自己的代码太难解释了！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">131072</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, dep[maxn + <span class="number">5</span>], len, maxlen;</span><br><span class="line">ll f[maxn + <span class="number">5</span>][maxt + <span class="number">5</span>], g[maxn + <span class="number">5</span>][maxt + <span class="number">5</span>], a[maxn + <span class="number">5</span>], ans[maxn + <span class="number">5</span>][maxt + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;&lt; <span class="number">1</span> &lt;= n) f[p][len] = f[p &lt;&lt; <span class="number">1</span>][len - <span class="number">1</span>] + f[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][len - <span class="number">1</span>];</span><br><span class="line">    g[p][len] = g[p / <span class="number">2</span>][len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= <span class="number">2</span>) g[p][len] += f[p ^ <span class="number">1</span>][len - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> ((p &lt;&lt; <span class="number">1</span>) &lt;= n) &#123;</span><br><span class="line">        dfs(p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        dfs(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]); f[i][<span class="number">0</span>] = g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        dep[i] = log2(i) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = log2(n + <span class="number">1</span>); maxlen = t * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">1</span>; len &lt;= maxlen; len++) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; maxlen) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[x][k] + g[x][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3628 DTOJ1220 [APOI2010]特别行动队</title>
    <url>/2020/03/27/%E6%B4%9B%E8%B0%B7P3628-DTOJ1220-APOI2010-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P3628" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br>你有一支由$n$名预备役士兵组成的部队，士兵从$1$到$n$编号，要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号应该连续，即为形如$(i, i + 1,\cdots \cdots, i + k)$的序列<br>编号为 i 的士兵的初始战斗力为$x_i$ ，一支特别行动队的初始战斗力$x$为队内士兵初始战斗力之和，即$x = \sum\limits_{j=i}^{i+k}x_j$<br>通过长期的观察，你总结出一支特别行动队的初始战斗力$x$将按如下经验公式修正为$x’：x’ = ax^2 + bx + c$，其中$a, b, c$是已知的系数（$a &lt; 0$）<br>作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队修正后战斗力之和最大，试求出这个最大和</p>
<p>例如， 你有$4$名士兵，$x_1 = 2, x_2 = 2, x_3 = 3, x_4 = 4$，经验公式中的参数为$a = –1, b = 10, c = –20$<br>此时，最佳方案是将士兵组成$3$个特别行动队：第一队包含士兵$1$和士兵$2$，第二队包含士兵$3$，第三队包含士兵$4$<br>特别行动队的初始战斗力分别为$4, 3, 4$，修正后的战斗力分别为$4, 1, 4$，修正后的战斗力和为$9$，没有其它方案能使修正后的战斗力和更大</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数$n$，表示士兵的总数<br>第二行包含三个整数$a, b, c$，经验公式中各项的系数<br>第三行包含n 个用空格分隔的整数$x_1,x_2, \cdots, x_n$，分别表示编号为$1, 2, \cdots, n$的士兵的初始战斗力</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，代表最大的所有特别行动队战斗力之和</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 </span><br><span class="line">-1 10 -20 </span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$20\%$的数据，$n \leqslant 10^3$<br>对于$50\%$的数据，$n \leqslant 10^4$<br>对于$100\%$的数据，$1 \leqslant n \leqslant 10^6，-5 \leqslant a \leqslant -1，-10^7 \leqslant b \leqslant 10^7，-10^7 \leqslant c \leqslant 10^7，1 \leqslant x_i \leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然是个DP<br>设$f_i$表示前$i$个人最大的所有特别行动队战斗力之和<br>假设战斗力的前缀和为$sum_i$<br>那么，我们可以得出$f_i=\min\limits_{1\leqslant j<i}\{f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c\}$
显然，这非常的像斜率优化的形式
假设$k$比$l$优
那么，$f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c<f_k+a(sum_i-sum_k)^2+b(sum_i-sum_k)+c$
$f_j-f_k+a(sum_j^2-sum_k^2)-b(sum_j-sum_k)<2asum_i(sum_j-sum_k)$
$\frac{f_j-f_k+a(sum_j^2-sum_k^2)-b(sum_j-sum_k)}{sum_j-sum_k}<2asum_i$
直接进行斜率优化
附上代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a,b,c,l,r,x[<span class="number">1000010</span>],sum[<span class="number">1000010</span>],f[<span class="number">1000010</span>],q[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">K</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>*(f[x]-f[y]+a*(sum[x]*sum[x]-sum[y]*sum[y])-b*(sum[x]-sum[y]))/(sum[x]-sum[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;n,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x[i]),sum[i]=sum[i<span class="number">-1</span>]+x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[l],q[l+<span class="number">1</span>])&gt;<span class="number">2</span>*a*sum[i]) l++;</span><br><span class="line">        f[i]=f[q[l]]+a*(sum[i]-sum[q[l]])*(sum[i]-sum[q[l]])+b*(sum[i]-sum[q[l]])+c;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[r],q[r<span class="number">-1</span>])&lt;K(q[r],i)) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>洛谷</tag>
        <tag>APIO</tag>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1984 花园</title>
    <url>/2020/03/27/DTOJ1984-%E8%8A%B1%E5%9B%AD/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>奇怪的大学有一座奇怪的花园，花园由N座温室组成，温室依次标号为$1,2,\cdots \cdots ,N$，温室之间由$N-1$条双向道路连接<br>每一座温室都种植这一种花，随着季节的变换，温室里的花的种类也在不断发生着变化<br><code>ShenX</code>平时非常喜欢在花园中漫步，他想知道从温室$x$走到温室$y$的路径中（包括两个端点），第$t$种花出现的次数</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行为两个整数$N,Q$，分别表示温室的数目和操作的数目<br>第二行有N个整数$T_1,T_2,\cdots \cdots,T_n$，其中$T_i$表示温室$i$中的花的种类<br>接下来$N-1$行，每个两个整数$x,y$，表示温室$x$和温室$y$之间有一条双向道路<br>接下来$Q$行，表示$Q$个操作，分别为以下两种形式之一：</p>
<ol>
<li><code>C x t</code> 表示在温室$x$中的花的种类变为$t$</li>
<li><code>Q x y t</code> 表示询问温室$x$走到温室$y$的路径中（包括两个端点），第t种花出现的次数</li>
</ol>
<p>为了体现在线操作，输入数据中的每个操作的参数都进行了加密。记最后一次询问的答案为$anslast$（一开始没有进行过询问时设$anslast$为$0$），读入中的$x,y,t$均需要异或上$anslast$以得到真实值，在c/c++中异或为<code>^</code>运算符，在Pascal中为<code>xor</code>运算符</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问操作，给出答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">10 20 30 40 50 </span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">Q 2 5 10</span><br><span class="line">C 2 21</span><br><span class="line">Q 3 4 21</span><br><span class="line">C 6 22</span><br><span class="line">Q 1 7 28</span><br><span class="line">C 5 20</span><br><span class="line">Q 2 5 20</span><br><span class="line">Q 2 0 9</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>这是加密前的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q 2 5 10</span><br><span class="line">C 3 20</span><br><span class="line">Q 2 5 20</span><br><span class="line">C 4 20</span><br><span class="line">Q 3 5 30</span><br><span class="line">C 5 20</span><br><span class="line">Q 2 5 20</span><br><span class="line">Q 1 3 10</span><br></pre></td></tr></table></figure></p>
<h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>对于30%的数据，有$N\leqslant 1000，Q\leqslant 2000$<br>对于50%的数据，有$N\leqslant 10000，Q\leqslant 20000$<br>对于100%的数据，有$1\leqslant N&lt;100000，1\leqslant Q\leqslant 200000,0\leqslant Ti&lt;2^{31}$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为这是一棵树，所以我们可以假设根是$1$号节点<br>我们设$S(x)$表示$1$号节点到$x$号节点的路径上第$t$种花的数量，$v(x)$表示$x$号节点上是第几种花<br>那么，$x$号节点到$y$号节点的路径上第$t$种花的数量为$S(x)+S(y)-S(lca)+[v(lca)==t]$<br>所以我们就只需要求出$S(x)$就可以了<br>咋求呢？线段树！<br>所以我们可以对每一种花开一棵线段树，由于内存的限制，我们需要使用动态开点<br>问题是如何修改呢？<br>我们可以对于每一个节点，记录下这个节点的DFS序，就可以进行修改了！<br>修改时只需要把这个点DFS序的起始到结束中间的所有数都$+1$就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(x) t[x].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) t[x].val</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,add,val;</span><br><span class="line">&#125;t[<span class="number">10000010</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val;</span><br><span class="line"><span class="keyword">int</span> n,q,ans,sum,size,T[<span class="number">100010</span>],root[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">int</span> tot,top,head[<span class="number">100010</span>],to[<span class="number">200010</span>],nxt[<span class="number">200010</span>],dep[<span class="number">100010</span>],fa[<span class="number">100010</span>][<span class="number">20</span>],dfn[<span class="number">200010</span>],b[<span class="number">100010</span>],e[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[x]) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[x][<span class="number">0</span>]) fa[to[i]][<span class="number">0</span>]=x,dep[to[i]]=dep[x]+<span class="number">1</span>,dfs(to[i]);</span><br><span class="line">    dfn[++top]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> temp=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">16</span>;i++) <span class="keyword">if</span>(temp&amp;(<span class="number">1</span>&lt;&lt;i)) u=fa[u][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">16</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];</span><br><span class="line">    <span class="keyword">return</span> u==v?u:fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a(p)||l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=a(p);</span><br><span class="line">    <span class="keyword">if</span>(!l(p)) l(p)=++size;</span><br><span class="line">    <span class="keyword">if</span>(!r(p)) r(p)=++size;</span><br><span class="line">    a(p)=<span class="number">0</span>,v(l(p))+=temp,a(l(p))+=temp,v(r(p))+=temp,a(r(p))+=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++size;</span><br><span class="line">    spread(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x==l&amp;&amp;y==r)&#123;v(p)+=d,a(p)+=d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) change(l(p),l,mid,x,min(y,mid),d);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) change(r(p),mid+<span class="number">1</span>,r,max(x,mid+<span class="number">1</span>),y,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    spread(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> v(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> ask(l(p),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(r(p),mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T[i]);</span><br><span class="line">        <span class="keyword">if</span>(!val[T[i]]) val[T[i]]=++sum;</span><br><span class="line">        T[i]=val[T[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),add(u,v),add(v,u);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)</span><br><span class="line">        <span class="keyword">if</span>(!b[dfn[i]]) b[dfn[i]]=i;</span><br><span class="line">        <span class="keyword">else</span> e[dfn[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) change(root[T[i]],<span class="number">1</span>,top,b[i],e[i],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d%d"</span>,op,&amp;x,&amp;y),x^=ans,y^=ans;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z),z^=ans;</span><br><span class="line">            <span class="keyword">int</span> LCA=lca(x,y);</span><br><span class="line">            <span class="keyword">if</span>(!val[z])&#123;ans=<span class="number">0</span>,<span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            z=val[z],ans=ask(root[z],<span class="number">1</span>,top,b[x])+ask(root[z],<span class="number">1</span>,top,b[y])<span class="number">-2</span>*ask(root[z],<span class="number">1</span>,top,b[LCA]);</span><br><span class="line">            <span class="keyword">if</span>(T[LCA]==z) ans++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!val[y]) val[y]=++sum;</span><br><span class="line">            y=val[y],change(root[T[x]],<span class="number">1</span>,top,b[x],e[x],<span class="number">-1</span>),change(root[y],<span class="number">1</span>,top,b[x],e[x],<span class="number">1</span>),T[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3049 苋</title>
    <url>/2020/03/27/DTOJ3049-%E8%8B%8B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>众所周知，一株马齿苋是活的，当且仅当它是连通的<br>特别地，一株活马齿苋上有$n$个独立的节点，以及连接这些点的$n-1$条苋边。每条苋边有一个值，定义为苋边的键值<br>对于一株马齿苋，我们定义两点间的简单路径为其相互到达所经过的最短苋路径<br>生物学界对于马齿苋的性质有许多研究，其中生物学家<code>Pauling</code>在其$1995$年的一篇论文中提到过这样一个经典问题：给定一株马齿苋上的一条简单路径，用生物方法判断路径上键值的异或和是否为$k$<br>这里尝试对这个问题进行推广，称之为泛马齿苋问题：给定一株马齿苋，求有多少条简单路径，使得路径上键值的异或和为$k$ </p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行，两个整数$n,k$<br>以下$n$行$a,b,c$表示$a\rightarrow b$有边，其键值为$c$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，即答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1</span><br><span class="line">1 2 4</span><br><span class="line">1 3 8</span><br><span class="line">3 4 8</span><br><span class="line">4 5 9</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p> 对于$30\%$的数据，$1\leqslant n\leqslant 100,k\leqslant10$<br>对于$50\%$的数据，$1\leqslant n\leqslant 2000,k\leqslant 256$<br>对于$100\%$的数据，$1\leqslant n\leqslant 4\times 10^5,k\leqslant 10^9$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于这是一棵树，所以简单路径就是没有重复经过一个点的路径<br>设$f(u,v)$为从$u$到$v$的简单路径的异或和<br>由异或的性质：$a\land a=1$可以知道，$f(u,v)=f(1,u)\land f(1,v)$<br>所以，我们可以先预处理出所有的$f(1,u)$<br>又因为$a\land b=c$可以推出$a\land c=b$，所以，我们只需要统计所有$f(1,u)\land k=f(1,v)$的$u$和$v$就可以了<br><strong>注意：用map离散化，答案要除以2</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="keyword">int</span> n,k,tot,sum,head[<span class="number">400010</span>],nxt[<span class="number">800010</span>],to[<span class="number">800010</span>],ver[<span class="number">800010</span>],XOR[<span class="number">400010</span>],s[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v,ver[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa) XOR[to[i]]=XOR[x]^ver[i],dfs(to[i],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w),add(u,v,w),add(v,u,w);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!d[XOR[i]]) d[XOR[i]]=++sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[d[XOR[i]]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=s[d[XOR[i]^k]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4072 BZOJ4518 DTOJ2682 [SDOI2016]征途</title>
    <url>/2020/03/27/%E6%B4%9B%E8%B0%B7P4072-BZOJ4518-DTOJ2682-SDOI2016-%E5%BE%81%E9%80%94/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P4072" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br><code>Pine</code>开始了从$S$地到$T$地的征途<br>从$S$地到$T$地的路可以划分成$n$段，相邻两段路的分界点设有休息站<br><code>Pine</code>计划用$m$天到达$T$地。除第$m$天外，每一天晚上<code>Pine</code>都必须在休息站过夜。所以，一段路必须在同一天中走完<br><code>Pine</code>希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小<br>帮助<code>Pine</code>求出最小方差是多少<br>设方差是$v$，可以证明，$v \times m ^ 2$是一个整数。为了避免精度误差，输出结果时输出$v \times m ^ 2$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数$n$、$m$<br>第二行$n$个数，表示$n$段路的长度</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，最小方差乘以$m ^ 2$后的值</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 2 5 8 6</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据，$1 \leqslant n \leqslant 10$<br>对于$60\%$的数据，$1 \leqslant n \leqslant 100$<br>对于$100\%$的数据，$1 \leqslant n \leqslant 3000$<br>保证从$S$到$T$的总路程不超过$30000$</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>SDOI2016 Round1 Day2</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们先把结果的表达式化简一下<br>假设第$i$天走了$x_i$，总路程为$S$<br>那么$ans=m^2\times \frac{\sum \limits_{i=1}^m(x_i-\frac{S}{m})^2}{m}=\frac{\sum\limits_{i=1}^m(mx_i-S)^2}{m}=\frac{m^2\sum \limits_{i=1}^mx_i^2+S^2m-2Sm\sum \limits_{i=1}^mx_i}{m}=m\sum \limits_{i=1}^{m}x_i^2+S^2-2S^2=m\sum \limits_{i=1}^{m}x_i^2-S^2$<br>所以，我们只需要计算最小的$\sum \limits_{i=1}^mx_i^2$<br>假设$f_{i,j}$表示用$j$天走完前$i$段时，最小的$\sum \limits_{k=1}^jx_k^2$的值<br>为了方便，我们先预处理出$sum_i$表示前$i$段的长度之和<br>所以，我们就可以写出状态转移方程：$f_{i,j}=\min \limits_{1\leqslant k<i}\{f_{k,j-1}+(sum_i-sum_k)^2\}$
显然，这么做的时间复杂度太高了，我们需要进行优化
怎么优化呢？我们考虑$k$比$l$优，那么，我们可以得出：
$f_{k,j-1}+sum_k^2+sum_i^2-2sum_ksum_i<f_{l,j-1}+sum_l^2+sum_i^2-2sum_isum_l$
$f_{k,j-1}-f_{l,j-1}+sum_k^2-sum_k^2<2sum_i(sum_k-sum_l)$
$\frac{f_{k,j-1}-f_{l,j-1}+sum_k^2-sum_k^2}{sum_k-sum_l}<2sum_i$
所以，我们就可以进行斜率优化了！
附上代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,l,r;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">3010</span>],sum[<span class="number">3010</span>],f[<span class="number">3010</span>],fl[<span class="number">3010</span>],q[<span class="number">3010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">K</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fl[y]-fl[x]+sum[y]*sum[y]-sum[x]*sum[x])/(sum[y]-sum[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fl[i]=sum[i]*sum[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        l=r=<span class="number">1</span>,q[l]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[l],q[l+<span class="number">1</span>])&lt;<span class="number">2</span>*sum[j]) l++;</span><br><span class="line">            f[j]=fl[q[l]]+(sum[j]-sum[q[l]])*(sum[j]-sum[q[l]]);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[r<span class="number">-1</span>],q[r])&gt;K(q[r],j)) r--;</span><br><span class="line">            q[++r]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) fl[j]=f[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,m*f[n]-sum[n]*sum[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>洛谷</tag>
        <tag>斜率优化DP</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ4499 DTOJ2555 线性函数</title>
    <url>/2020/03/27/BZOJ4499-DTOJ2555-%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小<code>C</code>最近在学习线性函数，线性函数可以表示为：$f(x) = kx + b$。现在小<code>C</code>面前有$n$个线性函数$f_i=k_ix+b_i$，他对这$n$个线性函数执行$m$次操作，每次可以：</p>
<ol>
<li><code>M i K B</code>代表把第$i$个线性函数改为$f_i(x)=Kx+B$</li>
<li><code>Q l r x</code>返回$f_r(f_{r-1}(\cdots \cdots f_l(x)))mod(10^9+7)$<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>第一行两个整数$n, m (1 \leqslant n, m \leqslant 200,000)$<br>接下来$n$行，每行两个整数$k_i, b_i$<br>接下来$m$行，每行的格式为<code>M i K B</code>或者<code>Q l r x</code><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>对于每个<code>Q</code>操作，输出一行答案 <h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 5 5</span><br><span class="line">4 2</span><br><span class="line">3 6</span><br><span class="line">5 7</span><br><span class="line">2 6</span><br><span class="line">7 5</span><br><span class="line">Q 1 5 1</span><br><span class="line">Q 3 3 2</span><br><span class="line">M 3 10 6</span><br><span class="line">Q 1 4 3</span><br><span class="line">Q 3 4 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1825</span><br><span class="line">17</span><br><span class="line">978</span><br><span class="line">98</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>$20\%$：$n, m \leqslant 1000$<br>另外$10\%$：$b = 0$<br>另外$10\%$：$k = 1$<br>$100\%$：$1 \leqslant n, m \leqslant 200,000，0 \leqslant k, b, x &lt; 10^9+7$<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2>FJWC2016 day5<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>这一题一眼看过去就是线段树，问题是要储存什么<br>假设现在有两个函数$f_1(x)=k_1x+b_1,f_2(x)=k_2x+b_2$，那么$f(x)=f_2(f_1(x))$的表达式是什么呢？<br>$f(x)=f_2(f_1(x))=f_2(k_1x+b_1)=k_2(k_1x+b_1)+b_2=k_1k_2x+b_1k_2+b_2$<br>所以，我们令$k_1k_2=K,b_1k_2+b_2=B$，就可以把$f(x)$表示为$Kx+B$了<br>所以，我们只需要在线段树中存储这个函数的$k$和$b$，上传时按照上面的方法操作就可以了<br><strong>注意：线段树要开4倍！！！要记得mod10^9+7！！！</strong><br>附上代码：<br>```cpp<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<algorithm></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<cstdio></h1>using namespace std;<h1 id="define-l-x-t-x-l"><a href="#define-l-x-t-x-l" class="headerlink" title="define l(x) t[x].l"></a>define l(x) t[x].l</h1><h1 id="define-r-x-t-x-r"><a href="#define-r-x-t-x-r" class="headerlink" title="define r(x) t[x].r"></a>define r(x) t[x].r</h1><h1 id="define-k-x-t-x-k"><a href="#define-k-x-t-x-k" class="headerlink" title="define k(x) t[x].k"></a>define k(x) t[x].k</h1><h1 id="define-b-x-t-x-b"><a href="#define-b-x-t-x-b" class="headerlink" title="define b(x) t[x].b"></a>define b(x) t[x].b</h1>struct Segment_Tree<br>{<br> int l,r;<br> long long k,b;<br>}t[800010];<br>int n,m;<br>long long x,y,z,MOD=1e9+7,k[200010],b[200010];<br>void build(int p,int l,int r)<br>{<br> l(p)=l,r(p)=r;<br> if(l==r){k(p)=k[l],b(p)=b[l];return;}<br> int mid=(l+r)&gt;&gt;1;<br> build(2<em>p,l,mid);<br> build(2</em>p+1,mid+1,r);<br> k(p)=k(2<em>p)</em>k(2<em>p+1)%MOD,b(p)=(b(2</em>p)<em>k(2</em>p+1)%MOD+b(2<em>p+1))%MOD;<br>}<br>void change(int p,int x,long long K,long long B)<br>{<br> if(l(p)==r(p)&amp;&amp;l(p)==x){k(p)=K,b(p)=B;return;}<br> int mid=(l(p)+r(p))&gt;&gt;1;<br> if(x&lt;=mid) change(2</em>p,x,K,B);<br> else change(2<em>p+1,x,K,B);<br> k(p)=k(2</em>p)<em>k(2</em>p+1)%MOD,b(p)=(b(2<em>p)</em>k(2<em>p+1)%MOD+b(2</em>p+1))%MOD;<br>}<br>pair<long long,long long> ask(int p,int L,int R)<br>{<br> if(L&lt;=l(p)&amp;&amp;r(p)&lt;=R) return make_pair(k(p),b(p));<br> int mid=(l(p)+r(p))&gt;&gt;1;<br> pair<long long,long long> ansl=make_pair(1,0),ansr=make_pair(1,0);<br> if(L&lt;=mid) ansl=ask(2<em>p,L,R);<br> if(R&gt;mid) ansr=ask(2</em>p+1,L,R);<br> return make_pair(ansl.first<em>ansr.first%MOD,(ansl.second</em>ansr.first%MOD+ansr.second)%MOD);<br>}<br>int main()<br>{<br> scanf(“%d%d”,&amp;n,&amp;m);<br> for(int i=1;i&lt;=n;i++) scanf(“%lld%lld”,&amp;k[i],&amp;b[i]);<br> build(1,1,n);<br> for(int i=1;i&lt;=m;i++){<pre><code> char op[2];
 scanf(&quot;%s %lld%lld%lld&quot;,op,&amp;x,&amp;y,&amp;z);
 if(op[0]==&#39;M&#39;) change(1,x,y,z);
 else{
     pair&lt;long long,long long&gt; ans;
     ans=ask(1,x,y);
     printf(&quot;%lld\n&quot;,(ans.first*z%MOD+ans.second)%MOD);
 }
</code></pre> }<br>}</li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>exLucas定理</title>
    <url>/2020/03/13/exLucas%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4720" target="_blank" rel="noopener">模板</a><br>这好像不是个定理……<br>看起来是个算法，但是不知道为什么大家都叫它定理，所以我也跟着写了……<br>还有，这玩意儿好像跟Lucas定理没有半毛钱关系，不知道为什么叫exLucas……<br><a id="more"></a></p>
<h6 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h6><p>为了学会这个“定理”，你需要了解几样东西：</p>
<ol>
<li>质因数分解</li>
<li>CRT（中国剩余定理）</li>
<li>逆元</li>
<li>其他基础的数论</li>
<li>组合数的定义（？？？）</li>
<li>好的视力，或者一个放大镜（因为有的又有分数又有上下标，很容易看不清）</li>
</ol>
<p>这些知识如果不会，可以参考我的<a href="https://jrjacky.github.io/2019/07/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/">另一篇博客</a>（5、6除外）</p>
<h6 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h6><p>下面的讲解有几个规定：</p>
<ol>
<li>$p$为模数</li>
<li>除了$p$以外的所有含$p$的字母默认为质数</li>
<li>所有的数都是非负整数</li>
<li>$i$的范围默认为距离这个$i$最近（上面）的一次定义的$i$的范围（可能在式子中）</li>
<li>与第四条类似，①式默认为距离这个①式最近（上面）的一次定义的①式</li>
</ol>
<h6 id="分解p"><a href="#分解p" class="headerlink" title="分解p"></a>分解p</h6><p>首先，我们要先将$p$进行质因数分解<br>设$p=\prod \limits_{i=1}^{t}p_i^{\alpha_i}$<br>这样，我们就只需要计算$\binom{n}{m}modp_i^{\alpha_i}(*)$，最后再用一下CRT就好了</p>
<h6 id="算-∗-式！"><a href="#算-∗-式！" class="headerlink" title="算(∗)式！"></a>算(∗)式！</h6><p>看到这个式子，有的同学就会说：看！$p_i$是质数！直接用Lucas定理算！<br>……首先，我说过，这玩意儿跟Lucas定理没有半毛钱关系；其次，它还有个次数$\alpha_i$啊！<br>首先，我们由组合数的定义可以知道：$\binom{n}{m}=\frac{n!}{m!(n-m)!}$<br>这时候，又有同学要说了：$\frac{1}{m!(n-m)!}$直接求逆元啊！<br>……求逆元的前提是互质啊！你看$m!(n-m)!$这个阶乘，它能跟$p_i$互质吗？<br>所以，我们得把这玩意儿中的$p_i$提出来……<br>假设$p^{k1}\mid\mid n!,p^{k2}\mid\mid m!,p^{k3}\mid\mid (n-m)!$<br>那么$\binom{n}{m}=\frac{\frac{n!}{p^{k1}}}{\frac{m!}{p^{k2}}\times\frac{(n-m)!}{p^{k3}}}\times p^{k1-k2-k3}$</p>
<h6 id="阶乘中质数的个数"><a href="#阶乘中质数的个数" class="headerlink" title="阶乘中质数的个数"></a>阶乘中质数的个数</h6><p>假设$p^\alpha\mid\mid n!$<br>首先考虑$n!\%p^k$咋算<br>$n!\%{p^k}={p^{n/p}}\times (n/p)!\times (\prod\limits_{i,gcd(i,p)=1}^{p^k}i)^{n/p^k}\times(\prod\limits_{i,gcd(i,p)=1}^{p\%k}i)\%p^k$<br>其中，$\prod\limits_{i,gcd(i,p)=1}^{p^k}i$是循环的，直接暴力枚举，然后快速幂<br>剩下的$\prod\limits_{i,gcd(i,p)=1}^{p\%k}i$是多余的部分，也直接暴力枚举就完了<br>最后递归一下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算n!%p^ppa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cir=<span class="number">1</span><span class="comment">/*循环节*/</span>,rem=<span class="number">1</span><span class="comment">/*余数*/</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=ppa;i++) <span class="keyword">if</span>(i%p) cir=cir*i%ppa;</span><br><span class="line">    cir=POW(cir,n/ppa,ppa);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=ppa*(n/ppa);i&lt;=n;i++) <span class="keyword">if</span>(i%p) rem=rem*(i%ppa)%ppa;</span><br><span class="line">    <span class="keyword">return</span> fac(n/p,p,ppa)*cir%ppa*rem%ppa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着，我们需要算出$\alpha$<br>这个就非常简单了，我们假设$p^{\alpha’}\mid\mid \left[\frac{n}{p}\right]!$<br>那么$\alpha=\left[\frac{n}{p}\right]+\alpha’$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum_fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//n!中p的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;p?<span class="number">0</span>:sum_fac(n/p,p)+(n/p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>回到①式，$\binom{n}{m}=\frac{\frac{n!}{p^{k1}}}{\frac{m!}{p^{k2}}\times\frac{(n-m)!}{p^{k3}}}\times p^{k1-k2-k3}$<br>所以我们可以得出整个计算①式的程序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算n!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cir=<span class="number">1</span><span class="comment">/*循环节*/</span>,rem=<span class="number">1</span><span class="comment">/*余数*/</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=ppa;i++) <span class="keyword">if</span>(i%p) cir=cir*i%ppa;</span><br><span class="line">    cir=POW(cir,n/ppa,ppa);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=ppa*(n/ppa);i&lt;=n;i++) <span class="keyword">if</span>(i%p) rem=rem*(i%ppa)%ppa;</span><br><span class="line">    <span class="keyword">return</span> fac(n/p,p,ppa)*cir%ppa*rem%ppa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum_fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//n!中p的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;p?<span class="number">0</span>:sum_fac(n/p,p)+(n/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算Cnm%pi^ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fz=fac(n,p,ppa),fm1=ny(fac(m,p,ppa),ppa),fm2=ny(fac(n-m,p,ppa),ppa);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi=POW(p,sum_fac(n,p)-sum_fac(m,p)-sum_fac(n-m,p),ppa);</span><br><span class="line">    <span class="keyword">return</span> fz*fm1%ppa*fm2%ppa*mi%ppa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>解决了①式，剩下的部分就迎刃而解了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,p,cnt<span class="comment">/*个数*/</span>,pr[<span class="number">1010</span>]<span class="comment">/*质数*/</span>,al[<span class="number">1010</span>]<span class="comment">/*指数*/</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> (<span class="keyword">void</span>)(x=<span class="number">1</span>,y=<span class="number">0</span>);</span><br><span class="line">    exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=x;x=y;y=tmp-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ny</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line">    exgcd(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t=<span class="number">1</span>;</span><br><span class="line">    a%=p;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) t=t*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算n!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cir=<span class="number">1</span><span class="comment">/*循环节*/</span>,rem=<span class="number">1</span><span class="comment">/*余数*/</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=ppa;i++) <span class="keyword">if</span>(i%p) cir=cir*i%ppa;</span><br><span class="line">    cir=POW(cir,n/ppa,ppa);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=ppa*(n/ppa);i&lt;=n;i++) <span class="keyword">if</span>(i%p) rem=rem*(i%ppa)%ppa;</span><br><span class="line">    <span class="keyword">return</span> fac(n/p,p,ppa)*cir%ppa*rem%ppa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum_fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//n!中p的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;p?<span class="number">0</span>:sum_fac(n/p,p)+(n/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算Cnm%pi^ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fz=fac(n,p,ppa),fm1=ny(fac(m,p,ppa),ppa),fm2=ny(fac(n-m,p,ppa),ppa);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi=POW(p,sum_fac(n,p)-sum_fac(m,p)-sum_fac(n-m,p),ppa);</span><br><span class="line">    <span class="keyword">return</span> fz*fm1%ppa*fm2%ppa*mi%ppa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span><span class="comment">//分解p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> P=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i*i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(P%i))&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ppa=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!(P%i)) ppa*=i,P/=i;</span><br><span class="line">            pr[++cnt]=ppa;</span><br><span class="line">            al[cnt]=C(n,m,i,ppa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P!=<span class="number">1</span>) pr[++cnt]=P,al[cnt]=C(n,m,P,P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">crt</span><span class="params">()</span><span class="comment">//中国剩余定理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> M=p/pr[i],T=ny(M,pr[i]);</span><br><span class="line">        ans=(ans+al[i]*M%p*T%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exlucas</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span><span class="comment">//扩展卢卡斯 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pfd(n,m);</span><br><span class="line">    <span class="keyword">return</span> crt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;exlucas(n,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>西安集训日记</title>
    <url>/2020/02/13/%E8%A5%BF%E5%AE%89%E9%9B%86%E8%AE%AD%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>这个学期，我被老师叫去跟一群高一的神犇一起去西安集训，从9号到19号<del>其实就是为了逃课</del>，这篇文章就是我这11天的日记<br><a id="more"></a></p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>8号我找出了出行学习的计划，从洛谷日报里找了一些有用的东西预习了一下</p>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>早上坐飞机到西安，中午在外面乱吃了一些东西之后，去买了一堆生(wéi)活(jìn)物品，跟保安说我们是来训练的，就莫名其妙地进去了……<del>吐槽一句，这里的宿舍是真的脏</del><br>下午原来想去机房，但是听说机房还在维修，所以去篮球场打了好几个小时的篮球，打到我们要去吃饭为止</p>
<p>晚上翻出我电脑里的一堆资料，预习了一番</p>
<h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上不知道为什么，精神充沛，6点就醒了，宿舍没开灯，我就准备等到其他人都起来了，再开灯。等其他人醒来了，我才发现一个严重的问题：宿舍灯开不了！所以我摸着黑，干完了早上该干的事情。到了7点，灯才亮……<br>直接在宿舍楼下买了一个面包，就匆匆赶去机房准备考试<br>一进机房，就看到一堆蓝蓝的屏幕（蓝屏了）这就是他们昨天修电脑的结果？7:30，开始考试了。这里考试的规则也是诡异，我们可以开网，但是除了一个叫做<a href="accoders.com">accoders</a>的OJ可以开<del>貌似我们学校的OJ也开得起来</del>。考试的名字叫“NOI 2020 模拟赛Contest 1”，还写了一堆文件名，导致我们有一个傻(shén)逼(bēn)打了freopen，爆零了。<br>第一题是道概率题，不会，乱打了一个表，0分……第二题好像是个二分，可惜我不知道怎么二分，打了一个DFS，50分。第三题又是一个数学题，考集合的子集，不会做，直接暴力枚举子集，40分。总分90分，第34名（一共39个人），接近垫底，最高220分……<br>中午看了一下题解，第一题好像很水，很快就过了。一看第二题的题解，我人都傻了。由于数据是随机的，所以要用随机算法！我发现一堆人尝试了好几十次才过，所以我决定放弃这种牛(shǎ)逼的题目。（ps:现在的情况：提交722，解决:60）第三题的题解又是我看不懂的东西。质因数分解要用$O(\sqrt[3]{n})$的算法，判断质数还要用什么Miller Rabin算法，然后复杂度还是$O(\sqrt[3]{n}+3^{\omega(n)}\omega(n))$……去<del>网上</del>一个神犇那里找了一个Miller Rabin算法，直接复制，又看到了一个诡异的函数：random……这是什么毒瘤考试啊，考了两道随机数算法……<br>下午讲了一堆毒瘤题目，一题都不会，就在机房刷水题，晚上也是</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>早上起来又没有灯……<br>机房的电脑都修好了，体验也比昨天好。今天考试的名字令人疑惑：“NOIP 2019 模拟赛Contest 7”？？？不是只有CSP吗，NOIP不是SPFA了吗？第一题看一眼就知道是要用DP，就是不会做。于是就暴力枚举所有的子串，一个个判断，15分。第二题没有思路，胡乱找了一个规律，后来发现是错的，就准备达35分的表。有一个表打错了，15分。第三题用树状数组求逆序对，考试时就A了。一共130分，第15名。我仔细一看，居然有4个人AK了！我还是太菜了……<br>中午看题解，第一题果然是DP，但是很难理解，我们讨论了半天才做出来。第二题是个二分，一群人被二分的范围坑了，做了半天没A。<br>下午讲数据结构，还行，听的效果挺好的。晚上A了下午讲的题目，感觉还好。</p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>今天的名字总算正常了一点，就叫做模拟赛。我们看到有输入输出文件名，就打了freopen，结果，所有人都爆零……<br>第一题写了正解，但是n忘记减1了，80分……第二题显然是个DP，不会写，乱写了一个贪心，0分……第三题写了一个奇怪的方法，原来20分的，后来多测忘记回车了……共80分，不知道排名，只知道又有一个人AK了……<br>中午，我发现了一个问题：这个题目居然是提高组的模拟赛，而且我们学校的OJ上有！可惜我考试的时候没有开OJ（开了好像也没有什么用）而且这个题解，在网上都找得到……第二题是一个诡异的DP，不会写。第三题也是DP，状态定义有点奇怪，写出来了。<br>下午的数据结构有点恶心，晚上只写了3道题，就是细节太多了，查了好久的错……</p>
<h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>今天的比赛名字是假的，叫小S的欢乐赛，事实告诉我，这个比赛一点都不欢乐。第一题根本不知道是什么鬼，随便写了一个暴力DP，70分。第二题不会，根本没做。第三题写了一个特判，25分。一共95分，第19名。<br>下午有讲毒瘤的图论，又去刷水题了……<br>晚上才看了题解。这题目是真的毒瘤。第一题因为是随机数，最长上升子序列长度期望是$\sqrt{n}$。第二题是一个什么FFT，根本不知道是什么鬼。第三题就更懵逼了，什么数位DP，还是5维的！我把第一题做完就去刷水题了。</p>
<h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>今天上午讲了一大堆DP，没听懂多少，所以去洛谷日报里学了一下。<br>下午和晚上都在刷题。</p>
<h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>今天讲自动机和border，还回答了弱周期定理的证明。中午把模板A了。<br>下午测试的名字极其诡异：“CCF全国信息学奥林匹克联赛（CSP2020）复赛<br>提高组 day2”？？？透题？？？假的吧。第一题不会写，写了一个特判，48分。第二题就更不会了，是个毒瘤计算几何。第三题写了个特判，20分。一共68分，第22名。<br>晚上看了一下题解，第一题要推式子，第二题果然是个毒瘤题，要先证明两个引理，再暴力判断，细节实在是太多了，我调了一个晚上+半个早上。第三题先搞一个线段树，对于每个询问，再二分答案。</p>
<h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><p>今天早上老师安排这几次考试比较好的同学给我们讲题。我就在底下改我的第二题。成为了第一个3题都改对的人。<br>下午和晚上都在刷题。</p>
<h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><p>早上讲数学，挺简单的，还去回答了一个问题，后来我就没在听了。<br>下午考试超级难，一开始很累，导致我第一题用了$90\%$的时间，只有14分。第二题没写完，第三题根本没写。<br>考完试准备看题解，却发现题解是题目……还好旁边有个傻(shén)逼(bēn)（就是上次开了freopen的那个傻(shén)逼(bēn)）知道第二题思路，他写完之后就开心地交了。结果0分！所以这个神犇就把程序发给我，让我对拍<del>其实是我想要他的程序</del>，找到了一个错误的点，他<del>1</del>亿会儿就改完了。他又开心地交上去：80分！我立刻开启两个对拍，CPU利用率达到了$90\%$！拍到了10000也没有用。最后的问题是：没开long long……</p>
<h1 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h1><p>早上讲博弈论和计算几何，好难。但是第一道例题是个超级大水题，我上去凑了个热闹之后，就开始在座位上改题。<br>下午的考试只会第三题。我写了正解，但是有一点点小错误。我只对拍了其中一种情况，然后骄傲的跟我旁边那个人说：“看！我全对！”最后35分……<br>考完后看了看题解，第一题乍一看是个图论，但是其实就是推一个式子！抄下式子，3分钟搞定。第二题是个二分再加容斥，我看了半天没看懂。还好有神犇给我解释，我才会做。第三题改了一下小错误，一下就过了。</p>
<h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><p>都最后一天了，早上还考试……我也不想说什么了，爆零了……<br>考完试就溜了，去赶飞机了，题解没有看……</p>
<hr>
<p>这就是我去西安10天的学习。这十天，我不但收获了新知识，还大大开阔了我的视野，也结识了许多神犇，这也是我第一次出外进行集训，希望以后能有更多这样的机会。</p>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>去完西安后，我的文化课从40名下降道了66名，也不知道老师会不会再让我出去了……</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分之积分</title>
    <url>/2020/02/13/%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B9%8B%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="一、不定积分"><a href="#一、不定积分" class="headerlink" title="一、不定积分"></a>一、不定积分</h1><p>不定积分本质上就是导数的逆运算<br><strong>注意！许多函数的积分是算不出来的，所以，不要随便问别人一个函数的积分</strong><br><a id="more"></a><br>由于常数的导数为$0$，所以，一个不定积分的结果会是这样的：$\int f(x)dx=g(x)+C$，其中，$C$是一个常数</p>
<h2 id="1、不定积分运算法则"><a href="#1、不定积分运算法则" class="headerlink" title="1、不定积分运算法则"></a>1、不定积分运算法则</h2><h3 id="1-加减法"><a href="#1-加减法" class="headerlink" title="(1)加减法"></a>(1)加减法</h3><p>$\int f(x)dx+\int g(x)dx=\int \left(f(x)+g(x)\right)dx$</p>
<h3 id="2-乘除法"><a href="#2-乘除法" class="headerlink" title="(2)乘除法"></a>(2)乘除法</h3><p>然而并没有这种东西……</p>
<h2 id="2、求不定积分的常见方法"><a href="#2、求不定积分的常见方法" class="headerlink" title="2、求不定积分的常见方法"></a>2、求不定积分的常见方法</h2><h3 id="1-第一类换元法"><a href="#1-第一类换元法" class="headerlink" title="(1)第一类换元法"></a>(1)第一类换元法</h3><p>我之前讲过一个求导的公式——$(f(g(x)))’=f’(g(x))\times g‘(x)$（忘了？不知道？点<a href="https://blog.csdn.net/weixin_43849488/article/details/97966479" target="_blank" rel="noopener">这里</a>），那么我们可以得到$\int f’(g(x))\times g’(x)dx=f(g(x))$，把$g‘(x)$塞到$dx$中变成$dg(x)$，也就是$\int f’(g(x))\times dg(x)=f(g(x))$——这个公式就是第一类换元法<br>第一类换元法的应用很广，接下来我举几个例子供大家参考</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>求$\int sinx\cdot cosxdx$</p>
<hr>
<p>法一：$\int sinx\cdot cosxdx=\int sinx\cdot (sinx)’dx=\int sinxdsinx=\frac{1}{2}(sinx)^2+C$</p>
<hr>
<p>法二：$\int \frac{1}{2}sin2xdx=\int \frac{1}{4}sin2xd2x=-\frac{1}{4}cos2x+C$<br><strong>注意！+C是不可省略的！+C是不可省略的！+C是不可省略的！</strong><br>两种方法做的结果看似不一样，其实是一样的，只是在没有$+C$的情况下常数不同<br>这就是我强调要$+C$的原因</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>求$\int \frac{dx}{1+e^x}$</p>
<hr>
<p>$\int \frac{dx}{1+e^x}=\int \frac{e^xdx}{(1+e^x)e^x}=\int \frac{de^x}{e^x(1+e^x)}=\int \left(\frac{1}{e^x}-\frac{1}{e^x+1}\right)de^x=lne^x-ln\left(1+e^x\right)+C=x-ln\left(1+e^x\right)+C$<br>这一题巧妙地运用了$\left(e^x\right)’=e^x$的特殊性，再用第一类换元法和裂项解决</p>
<h3 id="2-第二类换元法"><a href="#2-第二类换元法" class="headerlink" title="(2)第二类换元法"></a>(2)第二类换元法</h3><p>第二类换元法和第一类换元法很像，就是最后一步的变形：$\int f’(g(x))\times g’(x)dx=\int f’(g(x))\times dg(x)$<br>第二类换元法一般会和三角换元有关，基本上都是那种带根号的式子</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>求$\int \frac{dx}{\sqrt{1-x^2}}$</p>
<hr>
<p>设$x=sin\theta$<br>$\int \frac{dx}{\sqrt{1-x^2}}=\int \frac{dsin\theta}{cos\theta}=\int \frac{cos\theta d\theta}{cos\theta}=\int d\theta=\theta+C=arcsinx+C$<br>这就是第二类换元法的应用，将$x$巧妙地进行三角换元，得到最后消掉的局面<br>大家不要小看这种换元方法，第二类换元法的题目可以出得很难</p>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>求$\int \frac{t^2dt}{\sqrt[3]{t-5}}$</p>
<hr>
<p>设$x=\sqrt[3]{t-5}$<br>$\int \frac{t^2dt}{\sqrt[3]{t-5}}=\int \frac{(x^6+10x^3+25)\cdot 3x^2dx}{x}=3\int (x^7+10x^4+25x)dx=3\cdot (\frac{1}{8}x^8+2x^5+\frac{25}{2}x^2)+C$（答案太丑了，不写了）<br>一看到题目，可能很多人就傻眼了——这东西能积分吗？答案是能的，只是很麻烦<br>看到题目的第一反应应该是先把那个恶心的根号换元，接着能不能做再说</p>
<h3 id="3-部分积分法"><a href="#3-部分积分法" class="headerlink" title="(3)部分积分法"></a>(3)部分积分法</h3><p>在求导的时候，我们学过一个公式——$(uv)’=u’v+uv’$，我们把两边同时积分，就可以得到$\int (uv)’dx=\int u’vdx+\int uv’dx+C$，左边的积分和求导抵消掉，变成$uv=\int u’vdx+\int uv’dx+C$<br>这个式子并不是最常用的，常用的是移项并用第二类换元法之后的结果——$\int udv=uv-\int vdu+C$<br>当$\int udv$不好求，但是$\int vdu$好求的时候，这个式子就排上用场啦！</p>
<h4 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h4><p>求$\int xcosxdx$</p>
<hr>
<p>$\int xcosdx=\int x(sinx)’dx=xsinx-\int (x)’sinxdx+C=xsinx-\int sinxdx+C=xsinx+cosx+C$<br>这一个看似奇怪的函数，却被我们几下搞定<br>这题巧用了$(x)’=1$的性质，把$x$消掉，变成$sinx$的积分</p>
<h4 id="例题6"><a href="#例题6" class="headerlink" title="例题6"></a>例题6</h4><p>求$\int arctanxdx$</p>
<hr>
<p>$\int arctanxdx=xarctanx-\int x\frac{dx}{x^2+1}+C=xarctanx-\frac{1}{2}\int \frac{d(x^2+1)}{x^2+1}+C=xarctanx-\frac{1}{2}ln(x^2+1)+C$<br>这题再次巧用$(x)’=1$的性质，无中生有一个$x$，最后又在把$x$丢到$dx$中的时候巧妙地加了一个常数，使得刚好凑成$\frac{1}{x}$的形式</p>
<h4 id="例题7"><a href="#例题7" class="headerlink" title="例题7"></a>例题7</h4><p>求$\int e^xcosxdx$</p>
<hr>
<p>$\int e^xcosxdx=\int e^xdsinx=e^xsinx-\int sinxe^xdx+C=e^xsinx+\int e^xdcosx+C=e^xsinx+e^xcosx-\int e^xcosxdx+C$<br>$\therefore 2\times\int e^xcosxdx=e^x(sinx+cosx)+C$<br>$\therefore \int e^xcosxdx=\frac{e^x(sinx+cosx)}{2}+C$<br>这题巧妙运用$\left((cosx)’\right)’=-cosx$的循环性，制造出一个循环，再除以二</p>
<h3 id="4-一种有理函数求积分的好方法"><a href="#4-一种有理函数求积分的好方法" class="headerlink" title="(4)一种有理函数求积分的好方法"></a>(4)一种有理函数求积分的好方法</h3><p>在计算一个有理函数$\frac{p(x)}{q(x)}$的积分时，我们可以采用接下来介绍的一种方法<br>这种方法很复杂，初学者建议跳过</p>
<h4 id="a、部分分式化"><a href="#a、部分分式化" class="headerlink" title="a、部分分式化"></a>a、部分分式化</h4><p>在求有理函数的积分前，我们先要对这个函数进行一些操作，在我以前学数竞的时候，老师曾经告诉过我们，这是一个求微积分才会用到的知识<br>首先，我们要先将这个函数中的$0$次及以上的系数分离，就是做一次大除法（不要问我大除法是什么，就是多项式除法，因为我没办法写竖式，所以无法展示出计算过程）<br>假设$p(x)\div q(x)=r(x)\cdots\cdots s(x)$，那么我们直接处理$\frac{s(x)}{q(x)}$就可以了<br>第二步，把q(x)分解质因式，假设是$a_1(x)^{b_1}\cdot a_2(x)^{b_2}\cdots\cdots a_k(x)^{b_k}$<br>第三步，把整个式子拆成这样：$\frac{p(x)}{q(x)}=\sum\limits_{i=1}^{k}\sum\limits_{j=1}^{b_i}\frac{\sum\limits_{l=0}^{a_i(x)\text{的次数}-1} \text{一个系数}\times x^l}{(a_i(x))^j}$<br>相信大家看了这个式子后一定是懵逼的，所以我来举个例子<br>比如$q(x)=(x-1)(x+4)^3(x^2+4x+7)(3x^2-x+1)$，我们就把这个式子拆成$\frac{A}{x-1}+\frac{B}{(x+4)^3}+\frac{C}{(x+4)^2}+\frac{D}{x+4}+\frac{Ex+F}{x^2+4x+7}+\frac{Gx+H}{3x^2-x+1}$<br>那这个式子要怎么拆开呢？接下来我就再举一个例子</p>
<h5 id="例题8"><a href="#例题8" class="headerlink" title="例题8"></a>例题8</h5><p>把$\frac{x+2}{x^2-1}$部分分式化</p>
<hr>
<p>首先，这个函数可以拆成$\frac{A}{x-1}+\frac{B}{x+1}$<br>所以，我们可以把$\frac{A}{x-1}+\frac{B}{x+1}$合并起来，得到$\frac{A(x+1)+B(x-1)}{x^2-1}=\frac{x+2}{x^2-1}$<br>把分母消掉并合并同类项：$x+2=(A+B)x+(A-B)$<br>这样，我们就可以得到一个方程组：$\begin{cases}A+B=1\\A-B=2\end{cases}$<br>解得$\begin{cases}A=\frac{3}{2}\\B=-\frac{1}{2}\end{cases}$<br>所以，$\frac{x+2}{x^2-1}$部分分式化的结果就是$\frac{\frac{3}{2}}{x-1}-\frac{\frac{1}{2}}{x+1}$</p>
<h4 id="b、积分！"><a href="#b、积分！" class="headerlink" title="b、积分！"></a>b、积分！</h4><p>做完部分分式化的操作后，我们终于到了积分的环节<br>我们把这个式子部分分式化了之后，我们就可以逐个来积分了<br>首先我们来解决最简单的$q(x)$是一次的形式：$\int \frac{1}{ax+b}dx$<br>设$t=ax+b$<br>$\int \frac{1}{t}dx=\int \frac{1}{t}d(\frac{t-b}{a})=\frac{1}{a}\int \frac{1}{t}dt=\frac{1}{a}lnt+C=\frac{1}{a}ln(ax+b)+C$<br>大家觉得这个结果对吗？<br>答案是：这个结果是<strong>错的！错的！错的！</strong><br>为什么？这看起来没有错啊<br>问题在于当$ax+b&lt;0$时，就不能取对数了，所以正确答案是$\frac{1}{a}ln|ax+b|+C$<br>处理完一次式，我们再来处理一下二次式$\int \frac{Ax+B}{ax^2+bx+c}dx$<br>首先，我们进行配方$ax^2+bx+c=a(x+\frac{b}{2a})^2+\frac{4ac-b^2}{4a}$<br>设$x+\frac{b}{2a}=t$<br>$\int \frac{Ax+B}{ax^2+bx+c}dx=\int \frac{At+B-\frac{b}{2a}}{at^2-\frac{4ac-b^2}{4a}}dt=A\int \frac{t}{at^2+\frac{4ac-b^2}{4a}}dt+(B-\frac{b}{2a})\int \frac{1}{at^2+\frac{4ac-b^2}{4a}}dt$<br>现在的式子<del>有点</del>非常恶心，所以我们分两边处理<br>$\int \frac{t}{at^2-\frac{4ac-b^2}{4a}}dt=\frac{1}{2a}\int \frac{2at}{at^2+\frac{4ac-b^2}{4a}}dt=\frac{1}{2a}\int \frac{1}{at^2+\frac{4ac-b^2}{4a}}d\left(at^2\right)=\frac{1}{2a}ln|at^2+\frac{4ac-b^2}{4a}|+C=\frac{1}{2a}ln|ax^2+bx+c|+C$<br>至于右边，只需要记住一个公式：$\int \frac{1}{x^2+a^2}dt=\frac{1}{a}arctan\left(\frac{x}{a}\right)+C$（这其实就是一份第二类换元法，可以参照例3的做法）<br>问题是，我的式子中的所谓的$a^2$是$\frac{4ac-b^2}{4a}$！它大于0吗？<br>现在，你终于要知道我们为啥要部分分式化了<br>之所以这是一个二次式，是因为它无法因式分解！所以，它的$\Delta=b^2-4ac&lt;0$！所以，$\frac{4ac-b^2}{4a}$大于0<br>所以，$\int \frac{1}{at^2+\frac{4ac-b^2}{4a}}dt=\frac{1}{\sqrt{\frac{4ac-b^2}{4a}}}arctan\left(\frac{\sqrt{a}t}{\sqrt{\frac{4ac-b^2}{4a}}}\right)+C$<br>最后，我们把这两个部分合起来，$\int \frac{Ax+B}{ax^2+bx+c}dx=\frac{A}{2a}ln|ax^2+bx+c|+\frac{B-\frac{b}{2a}}{\sqrt{\frac{4ac-b^2}{4a}}}arctan\left(\frac{\sqrt{a}x+\sqrt{a}\frac{b}{2a}}{\sqrt{\frac{4ac-b^2}{4a}}}\right)+C$<br>又是一个令人无语的式子，这个式子太复杂了，以至于我相信没有人能背下来（包括我）<br>一般这种题目不会出得这么恶心，会出一些凑好的数给你<br>对于更高次的积分，你就只需要像二次一样，把它降次打击，就可以了<br>说着简单，做起来却很难<br>所以我告诫大家：积分千万条，生命第一条，积分用手算，一天写不完</p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><p>相信大家已经对这种有理函数求积分的好方法有了一定的了解，我给大家总结一下这种方法的步骤</p>
<ol>
<li>先看分子分母最高项的次数，如果有必要请做除法</li>
<li>对分母进行因式分解</li>
<li>分部</li>
<li>计算常数的值（以上为部分分式化内容）</li>
<li>积分<h4 id="例题9"><a href="#例题9" class="headerlink" title="例题9"></a>例题9</h4>求$\int \frac{x^5-7x^4+19x^3-10x^2-19x+18}{x^4-5x^3+9x^2}dx$</li>
</ol>
<hr>
<p>$\int \frac{x^5-7x^4+19x^3-10x^2-19x+18}{x^4-5x^3+9x^2}dx=\int \left(x-2+\frac{8x^2-19x+18}{x^4-5x^3+9x^2}\right)dx=\frac{x^2}{2}-2x+\int \frac{8x^2-19x+18}{x^4-5x^3+9x^2}dx+C=\frac{x^2}{2}-2x+\int \frac{8x^2-19x+18}{x^2(x^2-5x+9)}dx+C=\frac{x^2}{2}-2x+\int \frac{2(x^2-5x+9)-x(x^2-5x+9)+(x+1)x^2}{x^2(x^2-5x+9)}dx+C=\frac{x^2}{2}-2x+\int\left(\frac{2}{x^2}-\frac{1}{x}+\frac{x+1}{x^2-5x+9}\right)dx+C=\frac{x^2}{2}-2x-\frac{2}{x}-ln|x|+\frac{ln(x^2-5x+9)}{2}+\frac{7arctan\left(\frac{2x-5}{\sqrt{11}}\right)}{\sqrt{11}}+C$<br>这就是不定积分的全部内容了，下面给大家几道练习题：</p>
<ol>
<li>$\int tanxdx$</li>
<li>$\int sin(ax+b)dx$</li>
<li>$\int \frac{x}{1+x^4}dx$</li>
<li>$\int \frac{1}{a^2-x^2}dx$</li>
<li>$\int \sqrt{a^2-x^2}dx$</li>
<li>$\int \frac{1}{\sqrt{a^2-x^2}}dx$</li>
<li>$\int \frac{1}{\sqrt{x^2-a^2}}dx$</li>
<li>$\int x^3lnxdx$</li>
<li>$\int x^2e^xdx$</li>
<li>$\int e^xsinxdx$</li>
<li>$\int \frac{x+2}{x^2-1}dx$</li>
<li>$\int \frac{x+8}{x^2+6x+13}dx$<h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1>定积分的定义：$f(x)$在$[a,b]$上的函数图像的面积（这并不是定积分严格的定义，为了让大家好理解，把它写成这样了。原来的定义是：$\int_a^b f(x)dx=\lim \limits_{mesh\to 0} f(c_j)(x_j-x_{j-1})$，其中$a=x_0&lt;x_1&lt;\cdots \cdots&lt;x_n=b$且$\forall j\in [1,n],j\in \Z,c_j\in [x_j-1,x_j]$）<br><img src="https://img-blog.csdnimg.cn/20200126182607488.png" alt="在这里插入图片描述"><br>举个例子，$\int_a^bxdx=(a+b)*(a-b)/2$，直接画出图像，用梯形的面积计算即可<h2 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h2></li>
<li>$\int_a^b f(x)dx=-\int_b^a f(x)dx$</li>
<li>$\int_a^a f(x)dx=0$</li>
<li>$\int_a^b f(x)dx=\int_a^c f(x)dx+\int_c^b f(x)dx$</li>
<li>$\int_a^b Cf(x)dx=C\int_a^b f(x)dx$</li>
<li>$\int_a^b(f(x)+g(x))dx=\int_a^bf(x)dx+\int_a^bg(x)dx$</li>
</ol>
<p>定积分的这些性质都很显然，按照定义来看就知道了</p>
<h2 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h2><h3 id="微积分的第一基本定理"><a href="#微积分的第一基本定理" class="headerlink" title="微积分的第一基本定理"></a>微积分的第一基本定理</h3><p>$\frac{d}{dx}\int_a^x f(t)dt=f(x)$<br>这个式子还是很显然，不行的自己画个图<br>我们把形如$\int_a^x f(t)dt$的式子，我们称为变上限积分</p>
<h3 id="微积分的第二基本定理"><a href="#微积分的第二基本定理" class="headerlink" title="微积分的第二基本定理"></a>微积分的第二基本定理</h3><p>$\int_a^b f(x)dx=\int f(b)dx-\int f(a)dx$<br>在知道微积分的第一基本定理后，我们就能很容易地推出微积分的第二基本定理了，现在知道这两个看似无关的东西的关联了吧？<br>定积分的内容比较少，因为它的计算就是通过微积分的第二基本定理，计算出该函数的不定积分，再相减，得出定积分。因此，我也没有给大家练习题了。这就是本篇文章的全部内容了，因为我的能力有限，写得不好的地方请大家多多包容。<br><strong>参考材料：</strong><br><strong>1、《普林斯顿微积分读本》Adrian Banner 著 杨爽 赵晓婷 高璞 译</strong></p>
]]></content>
      <categories>
        <category>物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ Begin4028 DTOJ3603 table</title>
    <url>/2019/09/22/DTOJ-Begin4028%20-DTOJ3603-table/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><code>C</code> 酱有一个$m \times n$的数表，行与列的编号都从$1$开始。令$f_{i,j}$表示表格第$i$行第$j$列内的数，那么对于表格的第$i(i&gt;1)$行有</p>
<script type="math/tex; mode=display">\begin{cases}f_{i,1}=a \times f_{i-1,1}\\f_{i,j}=a\times f_{i-1,j}+b\times f_{i-1,j-1}\end{cases}</script><p>然而 <code>C</code> 酱已经把表格中的数忘得差不多了，他现在只记得第$p$行的数。他希望你能够帮忙还原出部分位置的数值。</p>
<a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行为$6$个整数$m,n,a,b,p,q$，其中$q$表示询问的个数。  </p>
<p>接下来一行共$n$个整数，依次表示$f_{p,1},f_{p,2},\cdots,f_{p,n}$。  </p>
<p>接下来$q$行，每行两个整数$x,y$，表示 <code>C</code> 酱询问你$f_{x,y}$的数值。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$q$行，依次表示每个询问的答案在模$998244353$意义下的取值。  </p>
<p>即设答案可以表示为分式$\frac{a}{b}$ ，则输出整数$x$使得$b \times x \equiv a \pmod {998244353}$且$0  \leqslant x &lt; 998244353$。可以证明这样的整数$x$是唯一的。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 1"></a>样例输入 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 1 1 3 5</span><br><span class="line">1 0 0 0</span><br><span class="line">5 2</span><br><span class="line">3 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 1"></a>样例输出 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">998244351</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 2"></a>样例输入 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5 233 2333 6 4</span><br><span class="line">9 3 1 0 10</span><br><span class="line">1 5</span><br><span class="line">10 2</span><br><span class="line">5 3</span><br><span class="line">8 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 2"></a>样例输出 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110343631</span><br><span class="line">118211750</span><br><span class="line">770559638</span><br><span class="line">488601</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">测试点编号</th>
<th style="text-align:center">$n$</th>
<th style="text-align:center">$m$</th>
<th style="text-align:center">$a,b$</th>
<th style="text-align:center">$p$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$1,2$</td>
<td style="text-align:center">$\leqslant 100$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">$p=1$</td>
</tr>
<tr>
<td style="text-align:center">$3,4$</td>
<td style="text-align:center">$\leqslant 100$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$a=b=1$</td>
<td style="text-align:center">−</td>
</tr>
<tr>
<td style="text-align:center">$5,6,7,8$</td>
<td style="text-align:center">$\leqslant 100$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">−</td>
</tr>
<tr>
<td style="text-align:center">$9,10,11,12$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">$p=1$</td>
</tr>
<tr>
<td style="text-align:center">$13,14,15,16$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">$p=m$</td>
</tr>
<tr>
<td style="text-align:center">$17,18,19,20$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$\leqslant 10^7$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">−</td>
</tr>
</tbody>
</table>
</div>
<p>对于$100\%$的数据，保证$1 \leqslant q \leqslant 100 , 1 \leqslant x , p \leqslant m , 1 \leqslant y \leqslant n , 1 \leqslant a,b &lt; 998244353,0 \leqslant f_{i,j} &lt; 998244353$。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="40分算法"><a href="#40分算法" class="headerlink" title="40分算法"></a>40分算法</h2><p>暴力把所有格子算出来<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,a,b,p,q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ny,f[<span class="number">100010</span>][<span class="number">110</span>],MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;q;</span><br><span class="line">    ny=POW(a,MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;f[p][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[i][j]=((a*f[i<span class="number">-1</span>][j])%MOD+(b*f[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[i][j]=(((f[i+<span class="number">1</span>][j]-(b*f[i][j<span class="number">-1</span>])%MOD)%MOD*ny)%MOD+MOD)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=q;i++) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,<span class="built_in">cout</span>&lt;&lt;f[x][y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AC算法"><a href="#AC算法" class="headerlink" title="AC算法"></a>AC算法</h1><p>我们先分类讨论，在第$p$行下和在第$p$行上<br>若在第$p$行下，我们可以由上面的两个点得出下面一个点<br><img src="https://img-blog.csdnimg.cn/20190922124118645.png" alt=""><br>由题目可知，$f_{i,j}=a\times f_{i-1,j}+b\times f_{i-1,j-1}$</p>
<p>所以，我们考虑第$p$行中，要求的点$(x,y)$左侧的点$(p,i)$（即$i\leqslant y$），它对$(x,y)$的贡献就是$(p,i)$到$(x,y)$的路径条数（只能向右下或向下走）$\times a^{\cdots}\times b^{\cdots}$</p>
<p>我们只需要求$(p,i)$到$(x,y)$的路径条数和$a$、$b$的次数</p>
<p>假设$n=x-p,m=y-i$，那么，我们可以知道我们一共需要走$n$步，向右下走$m$步，所以路径数就是$C^m_n$</p>
<p>所以最终的结果就是：$C^m_n\times a^{n-m}\times b^{m}$<br><img src="https://img-blog.csdnimg.cn/20190922125117710.png" alt=""><br>所以我们还能得到一个范围：$n\geqslant m$<br>终于，我们解决了$(x,y)$在在$p$行下，即$x&gt;p$的情况，接下来，我们讨论一下$x&lt;p$的情况</p>
<p>同样，我们可以通过下面的和他左边的点得到这个位置的值，$f_{i,j}=\frac{f_{i+1,j}}{a}-\frac{b\times f_{i,j-1}}{a}$，那么，问题就变成考虑第$p$行中，要求的点$(x,y)$左侧的点$(p,i)$（即$i\leqslant y$），它对$(x,y)$的贡献就是$(p,i)$到$(x,y)$的路径条数（只能向上或右走）$\times a^{\cdots}\times \left(-\frac{b}{a}\right)^{\cdots}$</p>
<p>同样假设$n=p-x,m=y-i$，但是，不一样的地方在于第一步必须向上走！所以，我们可以知道去掉先向上走的一步后，一共需要走$n+m-1$步，向右走$m$步，所以路径数就是$C^m_{n+m-1}$</p>
<p>所以最终的结果就是：$C^m_{n+m-1}\times a^{n}\times \left(-\frac{b}{a}\right)^{m}$</p>
<p><img src="https://img-blog.csdnimg.cn/20190922131247325.png" alt=""></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol>
<li>取模</li>
<li>阶乘的逆元可以反着算，$invjc_i=invjc_{i+1}*(i+1)$，这样就避免了多次的$pow$</li>
<li>提前保存$a$的逆元</li>
<li>提前保存$-\frac{b}{a}$的次方，避免计算$-1^{y-i}$</li>
<li>$x&lt;p$的情况中，是$C^m_{n+m-1}$<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,p,q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,MOD=<span class="number">998244353</span>,f[<span class="number">10100010</span>],jc[<span class="number">10100010</span>],cj[<span class="number">10100010</span>],pa[<span class="number">10100010</span>],pb[<span class="number">10100010</span>],ap[<span class="number">10100010</span>],bp[<span class="number">10100010</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f：第p行的值</span></span><br><span class="line"><span class="comment">jc：阶乘</span></span><br><span class="line"><span class="comment">cj：阶乘的逆元</span></span><br><span class="line"><span class="comment">pa：a的次方</span></span><br><span class="line"><span class="comment">pb：b的次方</span></span><br><span class="line"><span class="comment">ap：pa的逆元</span></span><br><span class="line"><span class="comment">bp：-b/a的次方 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span><span class="comment">//快速幂 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//求组合数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||y&gt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> jc[x]*cj[y]%MOD*cj[x-y]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;q;</span><br><span class="line">    jc[<span class="number">0</span>]=pa[<span class="number">0</span>]=pb[<span class="number">0</span>]=ap[<span class="number">0</span>]=bp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10100000</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%MOD;<span class="comment">//暴力求阶乘 </span></span><br><span class="line">    cj[<span class="number">10100000</span>]=POW(jc[<span class="number">10100000</span>],MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10099999</span>;i&gt;=<span class="number">0</span>;i--) cj[i]=cj[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;<span class="comment">//反向求阶乘的逆元 </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> na=POW(a,MOD<span class="number">-2</span>),nb=MOD-(b*na%MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10100000</span>;i++) pa[i]=pa[i<span class="number">-1</span>]*a%MOD,pb[i]=pb[i<span class="number">-1</span>]*b%MOD,ap[i]=ap[i<span class="number">-1</span>]*na%MOD,bp[i]=bp[i<span class="number">-1</span>]*nb%MOD; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x==p)&#123;<span class="built_in">cout</span>&lt;&lt;f[y]&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;p)&#123;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++) <span class="keyword">if</span>(y-j&lt;=x-p) ans=(ans+f[j]*C(x-p,y-j)%MOD*pa[x-y-p+j]%MOD*pb[y-j]%MOD)%MOD;&#125;</span><br><span class="line">        <span class="comment">//括号很重要！不能删除 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++) ans=(ans+f[j]*C(y-x+p-j<span class="number">-1</span>,y-j)%MOD*ap[p-x]%MOD*bp[y-j]%MOD)%MOD;</span><br><span class="line">        <span class="comment">//分类讨论 </span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基础之求导</title>
    <url>/2019/08/01/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="1、导数的定义"><a href="#1、导数的定义" class="headerlink" title="1、导数的定义"></a>1、导数的定义</h1><p>导数，又名导函数值，是微积分中的重要基础概念。<a id="more"></a>当函数$y=f(x)$的自变量$x$在一点$x_0$处产生一个增量$\Delta x$时，函数输出值的增量$\Delta y$与自变量增量$\Delta x$的比值在$\Delta x$趋于$0$时的极限$a$如果存在，$a$即为在x0处的导数，记作$f’(x_0)$或$\frac{df(x_0)}{dx}$。导数的几何意义为：$f’(x)$表示函数曲线在点$(x,f(x))$处的切线的斜率。——百度百科（有删改）</p>
<h1 id="2、导数的运算"><a href="#2、导数的运算" class="headerlink" title="2、导数的运算"></a>2、导数的运算</h1><p>从导数的定义我们可以看出$f’(x)=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}$<br>所以我们可以从这个式子出发，得出导数的四则运算</p>
<h2 id="1-加（减）法"><a href="#1-加（减）法" class="headerlink" title="(1)加（减）法"></a>(1)加（减）法</h2><p>$(f(x)\pm g(x))’=\lim \limits_{\Delta x\rightarrow0}\frac{(f(x+\Delta x)\pm g(x+\Delta x))-(f(x)\pm g(x))}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}\pm\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}=f’(x)\pm g’(x)$</p>
<h2 id="2-乘法"><a href="#2-乘法" class="headerlink" title="(2)乘法"></a>(2)乘法</h2><p>$(f(x)\times g(x))’=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)\times g(x+\Delta x)-f(x)\times g(x)}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)\times g(x+\Delta x)-f(x+\Delta x)\times g(x)+f(x+\Delta x)\times g(x)-f(x)\times g(x)}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)\times(g(x+\Delta x)-g(x))+(f(x+\Delta x)-f(x))\times g(x)}{\Delta x}=f(x)\times\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}+g(x)\times\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}=f(x)\times g’(x)+f’(x)\times g(x)$</p>
<h2 id="3-除法"><a href="#3-除法" class="headerlink" title="(3)除法"></a>(3)除法</h2><p>$f’(x)=\left(\left(\frac{f(x)}{g(x)}\right)\times g(x)\right)’=\left(\frac{f(x)}{g(x)}\right)’\times g(x)+\left(\frac{f(x)}{g(x)}\right)\times g’(x)$<br>$\therefore \left(\frac{f(x)}{g(x)}\right)’=\frac{f’(x)-\left(\frac{f(x)\times g’(x)}{g(x)}\right)}{g(x)}=\frac{f’(x)g(x)-f(x)g’(x)}{g^2(x)}$</p>
<hr>
<p>除了四则运算之外，还有一些其他的运算</p>
<h2 id="4-复合函数求导"><a href="#4-复合函数求导" class="headerlink" title="(4)复合函数求导"></a>(4)复合函数求导</h2><p>$(f(g(x)))’=\lim \limits_{\Delta x\rightarrow0}\frac{f(g(x+\Delta x))-f(g(x))}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(g(x+\Delta x))-f(g(x))}{g(x+\Delta x)-g(x)}\times\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}=f’(g(x))\times g’(x)$</p>
<h2 id="5-反函数求导"><a href="#5-反函数求导" class="headerlink" title="(5)反函数求导"></a>(5)反函数求导</h2><p>设$f^{-1}(x)=g(x)$<br>$g’(x)=\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{1}{\frac{\Delta x}{g(x+\Delta x)-g(x)}}=\lim \limits_{\Delta x\rightarrow0}\frac{1}{\frac{f(g(x+\Delta x))-f(g(x))}{g(x+\Delta x)-g(x)}}=\frac{1}{f’(g(x))}$</p>
<h1 id="3、基本初等函数求导"><a href="#3、基本初等函数求导" class="headerlink" title="3、基本初等函数求导"></a>3、基本初等函数求导</h1><p>这里列出$6$大基本初等函数的导数，证明过程就省略了<del>原因是LaTeX太难打了</del>，幂函数稍微难一点，其他的都是用定义证明，具体的证明过程可以在网上搜索</p>
<h2 id="1-常数函数"><a href="#1-常数函数" class="headerlink" title="(1)常数函数"></a>(1)常数函数</h2><p>$f(x)=C$，$C$为常数<br>$f’(x)=0$</p>
<h2 id="2-幂函数"><a href="#2-幂函数" class="headerlink" title="(2)幂函数"></a>(2)幂函数</h2><p>$f(x)=x^a$<br>$f’(x)=ax^{a-1}$</p>
<h2 id="3-指数函数"><a href="#3-指数函数" class="headerlink" title="(3)指数函数"></a>(3)指数函数</h2><p>$f(x)=a^x(a\in\R^+)$<br>$f’(x)=a^xlna$</p>
<h2 id="4-对数函数"><a href="#4-对数函数" class="headerlink" title="(4)对数函数"></a>(4)对数函数</h2><p>$f(x)=log_ax(a\in\Z^+,a\ne 1)$<br>$f’(x)=\frac{1}{xlna}$</p>
<h2 id="5-三角函数"><a href="#5-三角函数" class="headerlink" title="(5)三角函数"></a>(5)三角函数</h2><p>$f(x)=sinx,g(x)=cosx,h(x)=tanx$<br>$f’(x)=cosx$<br>$g’(x)=-sinx$<br>$h’(x)=\frac{1}{cos^2x}=sec^2x$</p>
<h2 id="6-反三角函数"><a href="#6-反三角函数" class="headerlink" title="(6)反三角函数"></a>(6)反三角函数</h2><p>$f(x)=arcsinx,g(x)=arccosx,h(x)=arctanx$<br>$f’(x)=\frac{1}{\sqrt{1-x^2}}$<br>$g’(x)=-\frac{1}{\sqrt{1-x^2}}$<br>$h’(x)=\frac{1}{1+x^2}$</p>
<h1 id="一个诡异的函数"><a href="#一个诡异的函数" class="headerlink" title="一个诡异的函数"></a>一个诡异的函数</h1><p>$f(x)=x^x$这个函数这么求导呢？<br>我们只需要一步神奇的操作就可以了，看好了，千万不要眨眼<br>$f’(x)=\left(e^{ln\left(x^x\right)}\right)’=\left(e^{xlnx}\right)’=e^{xlnx}\times(xlnx)’=e^{xlnx}\times(1+lnx)$</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p>我：在本篇的末尾，我给大家出四个求导的练习题<br>读者：我最擅长微积分了，各种导数我都会求，你出的是什么水题，快拿来看看<br>我：先来个最简单的<br>$(sin(cos(sin(cose^x))))’$<br>我：有没有被吓到？<br>读者：没有，这不是很简单吗，一层层算就好了<br>我：没有？再来一个，保证吓死你<br>$sin(tanx+cosx)\times e^{x^2sinx+\sqrt{x^2+1}}$<br>读者：好了，我输了<br>我：不，我还没写分母呢！<br>$\left(\frac{sin(tanx+cosx)\times e^{x^2sinx+\sqrt{x^2+1}}}{e^xsin(x^2+3)+\sqrt{x^2+1}\times tanx}\right)’$<br>读者：什么！这个玩意儿能求导！？<br>我：能呀，我算过，再来一个<br>$\left(\frac{3x^2+5x^3sin2x+7e^{x^2+6x+sinx}+8ln(e^x+e^{\sqrt{5sinx+1}})}{ln(e^{5x}+sin(cose^x))\times(3x^2cosx+e^xsin(3x+1))}\right)’$<br>我：呀！你怎么了？你不会是晕了吧？<br>读者：突然感觉数学好难，我放弃了<br>我：别急呀，还有一道题呢！<br>$\left(\frac{\left(lnx^3+6xcos(sinx)\right)\left(arctan\left(l(x)e^xsin(tanx)\right)\right)}{e^{sin^2(xcosx)}ln^2(xarctanx)(x^2+1)}\right)’$<br>我：卧槽！你怎么了？同志，醒醒！<br>读者：我是谁？我在哪里？我在干什么？</p>
<hr>
<p>如果有人能做出这道题，可以私信给我，要求要有过程，来证明你不是抄的，你将会获得一些奖励</p>
]]></content>
      <categories>
        <category>数学&amp;物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3696 The Luckiest number题解</title>
    <url>/2019/07/31/POJ3696%20The%20Luckiest%20number%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<h3 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h3><p>Chinese people think of ‘$8$’ as the lucky digit. Bob also likes digit ‘$8$’. Moreover, Bob has his own lucky number $L$. Now he wants to construct his luckiest number which is the minimum among all positive integers that are a multiple of $L$ and consist of only digit ‘$8$’.</p>
<h3 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h3><p>给定一个正整数$L$($L\leqslant 2\times10^9$)<br>问至少有多少个$8$连在一起组成的正整数是$L$的倍数</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每行一个正整数$L$($L\leqslant 2\times10^9$)</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个$L$，输出至少有多少个$8$连在一起组成的正整数是$L$的倍数，格式参照样例。若不存在，输出$0$</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>8<br>11<br>16<br>0</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>Case 1: 1<br>Case 2: 2<br>Case 3: 0</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$n$个$8$连在一起组成的正整数可以记为$\frac{8}{9}(10^x-1)$<br>所以题目就转化为求最小的$x$使得$L|\frac{8}{9}(10^x-1)$<br>设$d=gcd(L,8)$<br>$L|\frac{8}{9}(10^x-1)\iff9L|8(10^x-1)\iff\frac{9L}{d}|10^x-1\iff10^x\equiv1\pmod{\frac{9L}{d}}$<br>这题的关键在于一个结论：若正整数$a,n$互质，则满足$a^x\equiv1\pmod{n}$的最小整数$x_0$为$\varphi(n)$的约数<br>证明：<br>假设满足$a^x\equiv1\pmod{n}$的最小整数$x_0$不能整除$\varphi(n)$<br>设$\varphi(n)=qx_0+r(0\leqslant r&lt;x_0)$<br>$\because a^{x_0}\equiv1\pmod{n}$<br>$\therefore a^{qx_0}\equiv1\pmod{n}$<br>又$\because a^{\varphi(n)}\equiv1\pmod{n}$（欧拉定理）<br>$\therefore a^{r}\equiv1\pmod{n}$，与$x_0$最小矛盾！<br>$\therefore$假设不成立，原命题成立</p>
<p>所以，我们只需要求出$\varphi(\frac{9L}{d})$，时间复杂度$\Theta(\sqrt{L}lnL)$<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">500000</span>],n,p,ans,i;</span><br><span class="line"><span class="keyword">int</span> t,m;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i,m=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++) <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        m=m/i*(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) m=m/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=n,b%=n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c=(<span class="keyword">long</span> <span class="keyword">double</span>)a*b/n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=a*b-c*n;</span><br><span class="line">    <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans&gt;=n) ans-=n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) c=mul(c,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        n=<span class="number">9</span>*n/gcd(<span class="number">8</span>,n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;++t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">if</span>(gcd(<span class="number">10</span>,n)==<span class="number">1</span>)&#123;</span><br><span class="line">            p=phi(n);</span><br><span class="line">            m=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i*i&lt;=p;i++) <span class="keyword">if</span>(p%i==<span class="number">0</span>)&#123;</span><br><span class="line">                a[++m]=i;</span><br><span class="line">                <span class="keyword">if</span>(i*i!=p) a[++m]=p/i;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(power(<span class="number">10</span>,a[i])==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数论总结</title>
    <url>/2019/07/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、数论中的基本概念与性质"><a href="#一、数论中的基本概念与性质" class="headerlink" title="一、数论中的基本概念与性质"></a>一、数论中的基本概念与性质</h1><h2 id="1、整除"><a href="#1、整除" class="headerlink" title="1、整除"></a>1、整除</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><a id="more"></a>
<p>若整数$b$除以非零整数$a$，商为整数，且余数为零， 我们就说$b$能被$a$整除（或说$a$能整除$b$），表示为$a \mid b$</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="1-反身性"><a href="#1-反身性" class="headerlink" title="(1)反身性"></a>(1)反身性</h4><p>$a \mid a$<br>证明：<br>$\because a \div a=1$<br>$\therefore a \mid a$</p>
<h4 id="2-反对称性"><a href="#2-反对称性" class="headerlink" title="(2)反对称性"></a>(2)反对称性</h4><p>$a \mid b$且$b \mid a$则$\left\vert a \right\vert=\left\vert b \right\vert$<br>证明：<br>$\because a \mid b,b \mid a$<br>$\therefore$设$b \div a=x,a \div b=y \left(x,y \in Z\right)$<br>$\therefore \begin{cases}b=ax\\a=by\end{cases}$<br>$\therefore b=ax=bxy$<br>$\therefore xy=1$<br>$\therefore \begin{cases} x= \pm 1\\y= \pm 1\end{cases}$<br>$\therefore \left\vert a \right\vert=\left\vert b \right\vert$<br>$\left\vert a \right\vert=\left\vert b \right\vert$则$a \mid b$且$b \mid a$<br>证明：<br>$\because \left\vert a \right\vert=\left\vert b \right\vert$<br>$\therefore \begin{cases} a \div b= \pm 1\\b \div a= \pm 1\end{cases}$<br>$\therefore a \mid b$且$b \mid a$</p>
<h4 id="3-传递性"><a href="#3-传递性" class="headerlink" title="(3)传递性"></a>(3)传递性</h4><p>$a \mid b$且$b \mid c$则$a \mid c$<br>证明：<br>$\because a \mid b,b \mid c$<br>$\therefore$设$b \div a=x,c \div b=y \left(x,y \in Z\right)$<br>$\therefore \begin{cases}b=ax\\c=by\end{cases}$<br>$\therefore c=by=axy$<br>$\therefore c \div a=xy$<br>$\therefore a \mid c$</p>
<h4 id="4-其他性质"><a href="#4-其他性质" class="headerlink" title="(4)其他性质"></a>(4)其他性质</h4><p>①$a \mid b$且$a \mid c$且$a \mid d$则$a \mid \left(ka+mb+nc+ld\right)$<br>证明：<br>$\because a \mid b,a \mid c,a \mid d$<br>$\therefore$设$b \div a=x,c \div a=y,d \div a=z \left(x,y,z \in Z\right)$<br>$\therefore \begin{cases}b=ax\\c=ay\\d=az\end{cases}$<br>$\therefore \left(ka+mb+nc+ld\right) \div a=\left(ka+mxa+nya+lza\right) \div a=\left(k +mx+ny+lz\right)$<br>$\therefore a \mid \left(ka+mb+nc+ld\right)$<br>②质数$p \mid ab$则$p \mid a$或$p \mid b$<br>证明：<br>假设$p \nmid a$且$p \nmid b$<br>$\because p \nmid a,p \nmid b$<br>$\therefore a$中不含有质因子$p$，$b$中不含有质因子$p$<br>$\therefore ab$中不含有质因子$p$<br>$\therefore p \nmid ab$，与$p \mid ab$矛盾<br>$\therefore$假设不成立<br>$\therefore p \mid a$或$p \mid b$<br>③连续$n$个整数中恰有一个整数是$n$的倍数<br>证明：<br>设这$n$个数为$a,a+1,\cdots,a+n-1,a \equiv r \pmod{n},1 \leqslant r \leqslant n$<br>$\therefore \left(a+n-r\right) \equiv \left(r+n-r\right) \equiv n \equiv 0 \pmod{n}$<br>又$\because 0 \leqslant n-r &lt; n$<br>$\therefore n \mid \left(a+n-r\right)$<br>$\therefore$连续$n$个整数中恰有一个整数是$n$的倍数<br>④连续$n$个整数的乘积为$n!$的倍数<br>证明：<br>设这$n$个数为$a,a+1,\cdots,a+n-1$<br>$\because C_{a+n-1}^{n}=\frac{\prod \limits_{i=1}^n \left(a+n-i\right)}{n!}$为整数<br>$\therefore n! \mid \prod \limits_{i=1}^n \left(a+n-i\right)$</p>
<h2 id="2、质数与合数"><a href="#2、质数与合数" class="headerlink" title="2、质数与合数"></a>2、质数与合数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h4 id="1-质数"><a href="#1-质数" class="headerlink" title="(1)质数"></a>(1)质数</h4><p>一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数</p>
<h4 id="2-合数"><a href="#2-合数" class="headerlink" title="(2)合数"></a>(2)合数</h4><p>合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数</p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="质数无穷多"><a href="#质数无穷多" class="headerlink" title="质数无穷多"></a>质数无穷多</h4><p>证明（质数无穷多的证明方法有许多，这里只展示1种，<del>其实我知道两种</del>，感兴趣的可以上网查）：<br>假设质数只有$n$个<br>从小到大依次排列为$p_{1},p_{2}, \cdots ,p_{n}$，设$N=\prod \limits_{i=1}^n p_{i}$<br>$\because p_{1} \nmid N$,$p_{2} \nmid N,\cdots,p_{n} \nmid N$<br>$\therefore N$为质数，与质数只有$n$个矛盾<br>$\therefore$假设不成立<br>$\therefore$质数无穷多</p>
<h4 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a>算术基本定理</h4><p>每一个合数都可以以唯一形式被写成质数的乘积<br>证明：<br>假设合数可以以多种方式写成多个质数的乘积，设最小的是$n$<br>设$n=\prod \limits_{i=1}^{r}(p_{i}^{a_{i}})=\prod \limits_{i=1}^{s}(q_{i}^{b_{i}})$<br>$\because p_{1} \mid \prod \limits_{i=1}^{s}(q_{i}^{b_{i}})$<br>$\therefore q_{1}^{b_{1}},q_{2}^{b_{2}},\cdots,q_{s}^{b_{s}}$中有一个数能被$p_{1}$整除<br>$\therefore$不妨设为$q_{1}$<br>又$\because q_{1}$也是质数，因此$q_{1}=p_{1}$<br>假设$a_{1} &gt; b_{1}$<br>$\therefore p_{1}^{a_{1}-b_{1}} \prod \limits_{i=2}^{r}(p_{i}^{a_{i}})=\prod \limits_{i=2}^{s}(q_{i}^{b_{i}})$<br>$\therefore q_{2}^{b_{2}},q_{3}^{b_{3}},\cdots,q_{s}^{b_{s}}$中有一个数能被$p_{1}$整除<br>又$\because p_{1}=q_{1} \ne q_{i}(i \ne 1)$<br>$\therefore a_{1} \leqslant b_{1}$<br>同理，$\therefore a_{1} \geqslant b_{1}$<br>$\therefore a_{1} = b_{1}$<br>$\therefore$存在小于$n$的整数$m=\prod \limits_{i=2}^{r}(p_{i}^{a_{i}})=\prod \limits_{i=2}^{s}(q_{i}^{b_{i}})$可以用多于一种的方式写成多个质数的乘积，这与$n$的最小性矛盾<br>$\therefore$ 每一个合数都可以以唯一形式被写成质数的乘积</p>
<h2 id="3、最大公约数和最小公倍数"><a href="#3、最大公约数和最小公倍数" class="headerlink" title="3、最大公约数和最小公倍数"></a>3、最大公约数和最小公倍数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="1-约数与倍数"><a href="#1-约数与倍数" class="headerlink" title="(1)约数与倍数"></a>(1)约数与倍数</h4><p>如果整数$a$能被整数$b$整除，$a$就叫做$b$的倍数，$b$就叫做$a$的约数</p>
<h4 id="2-公约数与公倍数"><a href="#2-公约数与公倍数" class="headerlink" title="(2)公约数与公倍数"></a>(2)公约数与公倍数</h4><p>几个整数中公有的约数，叫做这几个整数的公约数；几个整数中公有的倍数，叫做这几个整数的公倍数</p>
<h4 id="3-最大公约数与最小公倍数"><a href="#3-最大公约数与最小公倍数" class="headerlink" title="(3)最大公约数与最小公倍数"></a>(3)最大公约数与最小公倍数</h4><p>几个整数的公约数中，最大的一个，叫做这几个数的最大公约数；几个整数的公倍数中，最小的一个，叫做这几个数的最小公倍数数</p>
<h4 id="4-互质"><a href="#4-互质" class="headerlink" title="(4)互质"></a>(4)互质</h4><p>$\forall a,b \in N$,若(a,b)=1,则称$a,b$互质</p>
<h4 id="5-欧拉函数"><a href="#5-欧拉函数" class="headerlink" title="(5)欧拉函数"></a>(5)欧拉函数</h4><p>$1$~$N$中与$N$互质的数的个数被称为欧拉函数，记为$\varphi \left(N\right)=N \times \prod \limits_{质数p|N}(1-\frac{1}{p})$</p>
<h4 id="6-积性函数"><a href="#6-积性函数" class="headerlink" title="(6)积性函数"></a>(6)积性函数</h4><p>如果当$a,b$互质，有$f \left(ab\right)=f \left(a\right) \times f \left(b\right)$，那么称函数$f$为积性函数</p>
<h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><p>①$\forall a,b \in Z$，$gcd\left(a,b\right) \times lcm\left(a,b\right)=ab$<br>证明：<br>设$gcd\left(a,b\right)=d,a=a_{0}d,b=b_{0}d,(a_{0},b_{0})=1$<br>$lcm\left(a,b\right)=lcm\left(a_{0},b_{0}\right) \times d=a_{0}b_{0}d$<br>$\therefore gcd\left(a,b\right) \times lcm\left(a,b\right)=d \times a_{0}b_{0}d=a_{0}b_{0}d^{2}=\left(a_{0}d\right) \times \left(b_{0}d\right)=ab$<br>②$\forall n &gt; 1,1-n$中与$n$互质的数的和为$\frac{n \times \varphi \left(n\right)}{2}$<br>证明：<br>$\because gcd \left(n,x\right)=gcd \left(n,n-x\right)$<br>$\therefore$与$n$不互质的数$x,n-x$成对出现，平均值为$\frac{n}{2}$<br>$\therefore1-n$中与$n$互质的数的和为$\frac{n \times \varphi \left(n\right)}{2}$<br>③欧拉函数是积性函数<br>若$a,b$互质，则$\varphi \left(ab\right)=\varphi \left(a\right) \times \varphi \left(b\right)$<br>证明：<br>设$a=\prod \limits_{i=1}^{r}(p_{i}^{a_{i}}),b=\prod \limits_{i=1}^{s}(q_{i}^{b_{i}})$<br>$\therefore \varphi \left(a\right)=a \times \prod \limits_{i=1}^{r}(1-\frac{1}{p_{i}}),\varphi \left(b\right)=b \times \prod \limits_{i=1}^{s}(1-\frac{1}{q_{i}})$<br>$\therefore \varphi \left(ab\right)=ab \times \prod \limits_{i=1}^{r}(1-\frac{1}{p_{i}}) \times \prod \limits_{i=1}^{s}(1-\frac{1}{q_{i}})=\varphi \left(a\right) \times \varphi \left(b\right)$</p>
<h2 id="4、同余"><a href="#4、同余" class="headerlink" title="4、同余"></a>4、同余</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><h4 id="1-同余"><a href="#1-同余" class="headerlink" title="(1)同余"></a>(1)同余</h4><p>若整数$a$和整数$b$除以正整数$m$的余数相等，则称$a,b$模$m$同余，记为$a \equiv b \pmod{m}$</p>
<h4 id="2-同余类"><a href="#2-同余类" class="headerlink" title="(2)同余类"></a>(2)同余类</h4><p>对于$\forall a \in \left[0,m-1\right]$，集合$\left\{a+km\right\}(k \in Z)$的所有数模$m$同余，余数都是$a$，该集合称为一个模$m$的同余类，简记为$\overline{a}$</p>
<h4 id="3-完全剩余系"><a href="#3-完全剩余系" class="headerlink" title="(3)完全剩余系"></a>(3)完全剩余系</h4><p>模$m$的同余类一共有m个，分别为$\overline{0} , \overline{1} , \cdots , \overline{m-1}$,它们构成$m$的完全剩余系</p>
<h4 id="4-简化剩余系"><a href="#4-简化剩余系" class="headerlink" title="(4)简化剩余系"></a>(4)简化剩余系</h4><p>$1-m$中与$m$互质的数代表的同余类共有$\varphi \left(m\right)$个，它们构成$m$的简化剩余系</p>
<h4 id="5-数论倒数（乘法逆元）"><a href="#5-数论倒数（乘法逆元）" class="headerlink" title="(5)数论倒数（乘法逆元）"></a>(5)数论倒数（乘法逆元）</h4><p>若整数$a,x$满足$ax \equiv 1 \pmod{b}$，则$x$为$a$对模$m$意义下的数论倒数（乘法逆元）记为$a^{-1} \pmod{m}$</p>
<h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h3><h4 id="1-同余的充要条件"><a href="#1-同余的充要条件" class="headerlink" title="(1)同余的充要条件"></a>(1)同余的充要条件</h4><p>$a \equiv b \pmod{m}$的充要条件是$m \mid \left(a-b\right)$<br>证明：<br>$\because m \mid \left(a-b\right)$<br>$\therefore$存在整数$t$使得$a-b=mt$<br>$\therefore a=b+mt$<br>$\therefore a \equiv b \pmod{m}$</p>
<hr>
<p>$\because a \equiv b \pmod{m}$<br>$\therefore$存在整数$t$使得$a=b+mt$<br>$\therefore a-b=mt$<br>$\therefore m \mid \left(a-b\right)$</p>
<h4 id="2-反身性"><a href="#2-反身性" class="headerlink" title="(2)反身性"></a>(2)反身性</h4><p>$a \equiv a \pmod{m}$<br>证明：<br>$\because a-a=0,m \ne 0$<br>$\therefore m \mid a-a$<br>$\therefore a \equiv a \pmod{m}$</p>
<h4 id="3-对称性"><a href="#3-对称性" class="headerlink" title="(3)对称性"></a>(3)对称性</h4><p>$a \equiv b \pmod{m}$则$b \equiv a \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore m \mid \left(b-a\right)$<br>$\therefore b \equiv a \pmod{m}$</p>
<h4 id="4-传递性"><a href="#4-传递性" class="headerlink" title="(4)传递性"></a>(4)传递性</h4><p>$a \equiv b \pmod{m}$且$b \equiv c \pmod{m}$则$a \equiv c \pmod{m}$<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>又$\because b \equiv c \pmod{m}$<br>$\therefore m \mid \left(b-c\right)$<br>$\therefore m \mid \left[\left(a-b\right)+\left(b-c\right)\right]$<br>$\therefore m \mid \left(a-c\right)$<br>$\therefore a \equiv c \pmod{m}$</p>
<h4 id="5-可加性"><a href="#5-可加性" class="headerlink" title="(5)可加性"></a>(5)可加性</h4><p>$a \equiv b \pmod{m}$且$c \equiv d \pmod{m}$则$a+c \equiv b+d \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>又$\because c \equiv d \pmod{m}$<br>$\therefore m \mid \left(c-d\right)$<br>$\therefore m \mid \left[\left(a-b\right)+\left(c-d\right)\right]$<br>$\therefore m \mid \left[\left(a+c\right)-\left(b+d\right)\right]$<br>$\therefore a+c \equiv b+d \pmod{m}$</p>
<h4 id="6-可减性"><a href="#6-可减性" class="headerlink" title="(6)可减性"></a>(6)可减性</h4><p>$a \equiv b \pmod{m},c \equiv d \pmod{m}$则$a-c \equiv b-d \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>又$\because c \equiv d \pmod{m}$<br>$\therefore m \mid \left(c-d\right)$<br>$\therefore m \mid \left[\left(a-b\right)-\left(c-d\right)\right]$<br>$\therefore m \mid \left[\left(a-c\right)-\left(b-d\right)\right]$<br>$\therefore a-c \equiv b-d \pmod{m}$</p>
<h4 id="7-可乘性"><a href="#7-可乘性" class="headerlink" title="(7)可乘性"></a>(7)可乘性</h4><p>①$a \equiv b \pmod{m}$则$ac \equiv bc \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore m \mid \left(a-b\right)c$<br>$\therefore m \mid \left(ac-bc\right)$<br>$\therefore ac \equiv bc \pmod{m}$<br>②$a \equiv b \pmod{m},c \equiv d \pmod{m}$则$ac \equiv bd \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore ac \equiv bc \pmod{m}$<br>又$\because c \equiv d \pmod{m}$<br>$\therefore bc \equiv bd \pmod{m}$<br>$\therefore ac \equiv bd \pmod{m}$</p>
<h4 id="8-有关同余的其他性质"><a href="#8-有关同余的其他性质" class="headerlink" title="(8)有关同余的其他性质"></a>(8)有关同余的其他性质</h4><p>①$ac \equiv bc \pmod{m}$且$\left(m,c\right)=1$则$a \equiv b \pmod{m}$<br>证明：<br>$\because ac \equiv bc \pmod{m}$<br>$\therefore m \mid \left(ac-bc\right)$<br>$\therefore m \mid \left(a-b\right)c$<br>又$\because \left(m,c\right)=1$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore a \equiv b \pmod{m}$<br>②$ac \equiv bc \pmod{mc}$则$a \equiv b \pmod{m}$<br>证明：<br>$\because ac \equiv bc \pmod{mc}$<br>$\therefore mc \mid \left(ac-bc\right)$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore a \equiv b \pmod{m}$</p>
<h4 id="9-有关完全剩余系的性质"><a href="#9-有关完全剩余系的性质" class="headerlink" title="(9)有关完全剩余系的性质"></a>(9)有关完全剩余系的性质</h4><p>$gcd\left(m,a\right)=1$且$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个完全剩余系，则$\left\{\overline{ab_{i}}\right\}\left(i\in \left[1,m\right]\right)$也是模$m$的一个完全剩余系<br>证明：<br>假设存在两个整数$a \times b_{i} \equiv a \times b_{j} \pmod{m}$<br>$b_{i} \equiv b_{j} \pmod{m}$，与$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个完全剩余系矛盾<br>$\therefore$假设不成立<br>$\therefore \left\{\overline{ab_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个完全剩余系</p>
<h4 id="10-有关简化剩余系的性质"><a href="#10-有关简化剩余系的性质" class="headerlink" title="(10)有关简化剩余系的性质"></a>(10)有关简化剩余系的性质</h4><p>$gcd\left(m,a\right)=1$且$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,\varphi \left(m\right)\right]\right)$是模$m$的一个简化剩余系，则$\left\{\overline{ab_{i}}\right\}\left(i\in \left[1,\varphi \left(m\right)\right]\right)$也是模$m$的一个完全剩余系<br>证明：<br>假设存在两个整数$a \times b_{i} \equiv a \times b_{j} \pmod{m}$<br>$b_{i} \equiv b_{j} \pmod{m}$，与$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个简化剩余系矛盾<br>$\therefore$假设不成立<br>$\therefore \left\{\overline{ab_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个简化剩余系</p>
<h4 id="11-费马小定理"><a href="#11-费马小定理" class="headerlink" title="(11)费马小定理"></a>(11)费马小定理</h4><p>若$p$是质数，则对任意与$p$互质的整数$a$，有$a^{p-1} \equiv 1 \pmod{p}$<br>证明：<br>设$p$的完全剩余系为$\left\{\overline{i}\right\}\left(i \in\left[1,p-1\right]\right)$<br>$\because gcd\left(a,p\right)=1$<br>$\therefore \{\overline{ai}\}(i\in\left[1,p-1\right])$也是$p$的一个完全剩余系<br>$\therefore$对于每一个$i(i\in\left[1,p-1\right])$，总存在一个$j$使得$i \equiv a \times j \pmod{p}$<br>$\therefore \left(p-1\right)! \equiv \left(p-1\right)! \times a^{p-1} \pmod{p}$<br>又$\because \left(p,\left(p-1\right)!\right)=1$<br>$\therefore a^{p-1} \equiv 1 \pmod{p}$</p>
<h4 id="12-欧拉定理"><a href="#12-欧拉定理" class="headerlink" title="(12)欧拉定理"></a>(12)欧拉定理</h4><p>$gcd\left(a,n\right)=1,a \in Z^{+}$，则$a^{\varphi \left(n\right)} \equiv 1 \pmod{n}$<br>证明：<br>设$n$的简化剩余系为$\left\{\overline{a_{i}}\right\}\left(i \in\left[1,\varphi\left(n\right)\right]\right)$<br>$\because gcd\left(a,n\right)=1$<br>$\therefore \{\overline{aa_{i}}\}(i\in\left[1,\varphi \left(n\right)\right])$也是$p$的一个化简剩余系<br>$\therefore$对于每一个$a_{i}(i\in\left[1,\varphi \left(n\right)\right])$，总存在一个$j$使得$i \equiv a \times a_{j} \pmod{p}$<br>$\therefore \prod \limits_{i=1}^{\varphi \left(n\right)} a_{i} \equiv \prod \limits_{i=1}^{\varphi \left(n\right)}a_{i} \times a^{\varphi \left(n\right)} \pmod{n}$<br>$\therefore a^{\varphi \left(n\right)} \equiv 1 \pmod{n}$</p>
<h4 id="13-欧拉定理推论"><a href="#13-欧拉定理推论" class="headerlink" title="(13)欧拉定理推论"></a>(13)欧拉定理推论</h4><p>$gcd\left(a,n\right)=1,a \in Z^{+}$，则对于任意的正整数$b$，有$a^b \equiv a^{b \% \varphi \left(n\right)} \pmod{n}$<br>证明：<br>设$b=q \times \varphi \left(n\right)+r,0 \leqslant r &lt; \varphi \left(n\right)$<br>$a^{b} \equiv a^{q \times \varphi \left(n\right)+r} \equiv \left(a^{\varphi \left(n\right)}\right)^{q} \times a^{r} \equiv 1^{q} \times a^{r} \equiv a^{r} \equiv a^{b \% \varphi \left(n\right)} \pmod{n}$</p>
<h2 id="5、不定方程（丢番图方程）"><a href="#5、不定方程（丢番图方程）" class="headerlink" title="5、不定方程（丢番图方程）"></a>5、不定方程（丢番图方程）</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>不定方程是指未知数的个数多于方程个数，且未知数受到某些限制（如要求是有理数、整数或正整数等等）的方程或方程组</p>
<h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h3><h4 id="1-裴蜀Bezout定理"><a href="#1-裴蜀Bezout定理" class="headerlink" title="(1)裴蜀Bézout定理"></a>(1)裴蜀Bézout定理</h4><p>对于任意正整数$a,b$，存在一对整数$x,y$，满足$ax+by=gcd\left(a,b\right)$<br>证明：<br>设$gcd\left(a,b\right)=d,a=a_{0}d,b=b_{0}d$<br>$aa_{0}+bb_{0}=1$<br>$\therefore \left(a_{0},b_{0}\right)$是方程$ax+by=\left(a,b\right)$的一组解</p>
<h4 id="2-所有解与特解的关系"><a href="#2-所有解与特解的关系" class="headerlink" title="(2)所有解与特解的关系"></a>(2)所有解与特解的关系</h4><p>$\left(x_{0},y_{0}\right)$是方程$ax+by=c$的一组整数解，则方程的所有解为$\begin{cases}x=x_{0}+\frac{b}{gcd\left(a,b\right)}t\\y=y_{0}-\frac{a}{gcd\left(a,b\right)}t\end{cases},t \in Z$<br>证明：<br>设$ax_{1}+by_{1}=c,gcd\left(a,b\right)=c_{0},a=a_{0}c_{0},b=b_{0}c_{0},gcd\left(a_{0},b_{0}\right)=1$<br>$a_{0}x_{0}+b_{0}y_{0}=c_{0},a_{0}x_{1}+b_{0}y_{1}=c_{0}$<br>$\therefore a_{0}x_{0}+b_{0}y_{0}=a_{0}x_{1}+b_{0}y_{1}$<br>$\therefore a_{0}\left(x_{0}-x_{1}\right)=b_{0}\left(y_{1}-y_{0}\right)$<br>$\therefore b_{0} \mid a_{0}(x_{0}-x_{1})$<br>$\therefore b_{0} \mid \left(x_{0}-x_{1}\right)$<br>$\therefore x_{0} \equiv x_{1} \pmod{b_{0}}$<br>同理，$\therefore y_{0} \equiv y_{1} \pmod{b_{0}}$<br>$\therefore \begin{cases}x=x_{0}+b_{0}t\\y=y_{0}-a_{0}t\end{cases}$<br>$\therefore \begin{cases}x=x_{0}+\frac{b}{gcd\left(a,b\right)}t\\y=y_{0}-\frac{a}{gcd\left(a,b\right)}t\end{cases}$</p>
<h4 id="3-其他性质"><a href="#3-其他性质" class="headerlink" title="(3)其他性质"></a>(3)其他性质</h4><p>①$gcd\left(a,b\right)=1,a,b \in Z^{+}$，则方程$ax+by=ab-a-b$没有非负整数解<br>证明：<br>$\because ax+by=ab-a-b$<br>$\therefore a \left(x+1\right)+b \left(y+1\right)=ab$<br>又$\because a \mid ab$<br>$\therefore a \mid \left(a \left(x+1\right)+b \left(y+1\right)\right)$<br>$\therefore a \mid b \left(y+1\right)$<br>又$\because gcd\left(a,b\right)=1$<br>$\therefore a \mid \left(y+1\right)$<br>②$gcd\left(a,b\right)=1,c&gt;ab-a-b,a,b,c \in Z^{+}$，则方程$ax+by=c$有非负整数解<br>证明：<br>$\because gcd\left(a,b\right)=1$<br>$\therefore$设$ax_{0}+by_{0}=c,0 \leqslant x_{0} \leqslant b-1$<br>$\therefore y_{0}=\frac{c-ax_{0}}{b}&gt;\frac{ab-a-b-ax_{0}}{b} \geqslant \frac{ab-a-b-a\left(b-1\right)}{b}=-1$<br>$\therefore y_{0} \geqslant 0$<br>$\therefore x_{0},y_{0}$为非负整数<br>$\therefore$方程$ax+by=c$有非负整数解<br>③$gcd\left(a,b\right)=1,a,b \in Z^{+},0 \leqslant c \leqslant ab-a-b$，则恰有$\frac{\left(a-1\right)\left(b-1\right)}{2}$个整数$c$不能表示成$ax+by$的形式，$x,y \in \N$</p>
<h2 id="6、同余方程"><a href="#6、同余方程" class="headerlink" title="6、同余方程"></a>6、同余方程</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>设$f(x)=\sum \limits_{i=0}^{n}a_{i}x^{i}$是整系数多项式，称$f(x) \equiv 0 \pmod{m}$是$x$模$m$的同余方程</p>
<h2 id="7、高斯函数"><a href="#7、高斯函数" class="headerlink" title="7、高斯函数"></a>7、高斯函数</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><h4 id="1-取整函数"><a href="#1-取整函数" class="headerlink" title="(1)取整函数"></a>(1)取整函数</h4><p>不超过实数$x$的最大整数称为$x$的整数部分，记作$\left[x\right]$<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzAyLzIwL2sybjdmcy5wbmc" alt=""></p>
<h3 id="2-取小函数"><a href="#2-取小函数" class="headerlink" title="(2)取小函数"></a>(2)取小函数</h3><p>实数$x$的非负纯小数部分，记作$\left\{x\right\}$<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzAyLzIwL2sybkw2MC5wbmc" alt=""></p>
<h3 id="性质-5"><a href="#性质-5" class="headerlink" title="性质"></a>性质</h3><p>①$x=\left[x\right]+\left\{x\right\}$<br>②$x-1&lt;\left[x\right] \leqslant x$<br>③$0 \leqslant \left\{x\right\}&lt;1$<br>④若$x \leqslant y$，则$\left[x\right] \leqslant \left[y\right]$<br>证明：<br>$\because \left[x\right] \leqslant x \leqslant y&lt;\left[y\right]+1$<br>$\therefore \left[x\right] \leqslant \left[y\right]$<br>⑤$\forall a \in Z^{*},b \in Z$，则$b=a \left[\frac{b}{a}\right]+a\left\{\frac{b}{a}\right\},a\left\{\frac{b}{a}\right\} \in Z$<br>证明：<br>$\because \frac{b}{a}=\left[\frac{b}{a}\right]+\left\{\frac{b}{a}\right\}$<br>$\therefore b=a \left[\frac{b}{a}\right]+a\left\{\frac{b}{a}\right\}$<br>$\therefore a\left\{\frac{b}{a}\right\}=b-a \left[\frac{b}{a}\right]$<br>$\therefore a\left\{\frac{b}{a}\right\} \in Z$<br>⑥$\left[x\right]+\left[y\right]=\left[x+y\right]$或$\left[x+y\right]=\left[x\right]+\left[y\right]+1$<br>证明：<br>$\because x+y=\left[x\right]+\left[y\right]+\left\{x\right\}+\left\{y\right\}$<br>$\therefore$当$0 \leqslant \left\{x\right\}+\left\{y\right\}&lt;1$时，$\left[x\right]+\left[y\right]=\left[x+y\right]$<br>$  \;$当$1 \leqslant \left\{x\right\}+\left\{y\right\}&lt;2$时，$\left[x\right]+\left[y\right]+1=\left[x+y\right]$</p>
<h1 id="二、数论中相关的数和方程的求法"><a href="#二、数论中相关的数和方程的求法" class="headerlink" title="二、数论中相关的数和方程的求法"></a>二、数论中相关的数和方程的求法</h1><h2 id="1、埃拉托斯特尼筛法（埃氏筛法）"><a href="#1、埃拉托斯特尼筛法（埃氏筛法）" class="headerlink" title="1、埃拉托斯特尼筛法（埃氏筛法）"></a>1、埃拉托斯特尼筛法（埃氏筛法）</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>要得到自然数$n$以内的全部素数，必须把不大于$\sqrt{n}$的所有素数的倍数剔除，剩下的就是素数</p>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n/i;j++) v[i*j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(n \times \log \left(\log \left(n\right)\right)\right)$</p>
<h3 id="时间复杂度证明"><a href="#时间复杂度证明" class="headerlink" title="时间复杂度证明"></a>时间复杂度证明</h3><p>$\Theta \left(\log \left(n\right)\right)=\Theta \left(\ln \left(n\right)\right)=\Theta \left(\int_{1}^{n+1} \frac{dx}{x}\right)=\Theta \left(\sum \limits_{i=1}^{n} \int_{i}^{i+1} \frac{dx}{x}\right) &lt; \Theta \left(\sum \limits_{i=1}^{n} \frac{1}{i}\right) \leqslant \Theta \left(\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right) \times \sum \limits_{k=1}^{n} \frac{1}{k^{2}}\right) &lt; \Theta \left(\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right) \times \left(1+\sum \limits_{k=2}^{n} \left(\frac{1}{k-\frac{1}{2}}-\frac{1}{k+\frac{1}{2}} \right) \right) \right) = \Theta \left(\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right) \times \left(1+\frac{2}{3}+\frac{1}{n+\frac{1}{2}}\right)\right) &lt; \Theta \left(\frac{5}{3}\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right)\right) &lt; \Theta \left(\frac{5}{3} \prod \limits_{质数p \leqslant n} \exp  \left(\frac{1}{p}\right)\right) = \Theta \left(\frac{5}{3} \exp \left(\sum \limits_{质数p \leqslant n} \frac{1}{p}\right)\right)$<br>$\therefore \Theta \left(n \times \log \left(\log \left(n\right)\right)\right) = \Theta \left(n \times \ln \left(\ln \left(n\right)\right)\right) &lt; \Theta \left(n \times \ln \left(\frac{5}{3} \exp \left(\sum \limits_{质数p \leqslant n} \frac{1}{p}\right)\right)\right) = \Theta \left(n \times \sum \limits_{质数p \leqslant n} \frac{1}{p}\right)$</p>
<h2 id="2、欧拉筛法"><a href="#2、欧拉筛法" class="headerlink" title="2、欧拉筛法"></a>2、欧拉筛法</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的</p>
<h3 id="程序实现-1"><a href="#程序实现-1" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            v[i]=i;</span><br><span class="line">            prime[++m]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">            v[i*prime[j]]=prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cout</span>&lt;&lt;prime[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(n\right)$</p>
<h2 id="3、质因数分解"><a href="#3、质因数分解" class="headerlink" title="3、质因数分解"></a>3、质因数分解</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>$\forall N \in Z^{+} \setminus \left\{1\right\}$，把$N$化为$\prod \limits^{m}_{i=1} p^{c_{i}}_{i}$的过程叫质因数分解</p>
<h3 id="程序实现-2"><a href="#程序实现-2" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  m=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++) <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">    p[++m]=i,c[m]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,c[m]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">1</span>) p[++m]=n,c[m]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cout</span>&lt;&lt;p[i]&lt;&lt;<span class="string">'^'</span>&lt;&lt;c[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(\sqrt N\right)$</p>
<h2 id="4、欧几里得算法（辗转相除法）"><a href="#4、欧几里得算法（辗转相除法）" class="headerlink" title="4、欧几里得算法（辗转相除法）"></a>4、欧几里得算法（辗转相除法）</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>$\forall a,b \in N,b \ne 0,gcd(a,b)=gcd(b,a \% b)$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>若$a&lt;b$，则$gcd(b,a \% b)=gcd(b,a)=gcd(a,b)$，命题成立<br>若$a \geqslant b$，设$a=q \times b+r,0 \leqslant r&lt;b,a,b$的一个公约数为$d$<br>$d \mid a,d \mid qb$<br>$\therefore d \mid \left(a-qb\right)$<br>$\therefore d \mid r$<br>$\therefore d$也是$b,r$的公约数<br>$\therefore a,b$的公约数集合与$b,r$的公约数集合相同<br>$\therefore a,b$和$b,r$的最大公约数相等</p>
<h3 id="程序实现-3"><a href="#程序实现-3" class="headerlink" title="程序实现"></a>程序实现</h3><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp%a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(\log \left(a+b\right)\right)$</p>
<h2 id="5、扩展欧几里得算法"><a href="#5、扩展欧几里得算法" class="headerlink" title="5、扩展欧几里得算法"></a>5、扩展欧几里得算法</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>求方程$ax+by=gcd\left(a,b\right),a,b,x,y \in Z$的解$x,y$<br>当$b=0$时，$x=1,y=0$为方程的解<br>当$b&gt;0$时，$gcd \left(a,b\right)=gcd \left(b,a\%b\right)$<br>设$bx’+\left(a\%b\right)y’=gcd\left(b,a\%b\right),x’,y’ \in Z$<br>$\therefore bx’+\left(a\%b\right)y’=bx’+\left(a-b \left \lfloor \frac{a}{b} \right \rfloor\right)y’=ay’+b \left(x’-\left \lfloor \frac{a}{b} \right \rfloor y’\right)$<br>$\therefore \begin{cases} x=y’ \\y=x’-\left \lfloor \frac{a}{b} \right \rfloor y \end{cases}$</p>
<h3 id="程序实现-4"><a href="#程序实现-4" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y),z=x;</span><br><span class="line">    x=y,y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、线性同余方程组的解法"><a href="#6、线性同余方程组的解法" class="headerlink" title="6、线性同余方程组的解法"></a>6、线性同余方程组的解法</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>设$m_{1},m_{2},\cdots \cdots,m_{n} \in Z^{+}$，对于任意$n$个整数$a_{1},a_{2},\cdots \cdots,a_{n}$，求方程组$\begin{cases} x \equiv a_{1} \pmod{m_{1}}\\x \equiv a_{2} \pmod{m_{2}}\\             \vdots\\x \equiv a_{n} \pmod{m_{n}} \end{cases}$的解</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>设前$k-1$个方程的解为$x,m= \sum \limits^{t-1}_{i=1}m_{i},tm \equiv a_{k}-x \pmod{m_{k}}$<br>$\therefore x+tm \equiv a^{k} \pmod{m^{k}}$<br>$\therefore x’=x+tm$为前$k$个方程的解</p>
<h3 id="程序实现-5"><a href="#程序实现-5" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m[<span class="number">20</span>],a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> d=exgcd(b,a%b,x,y),z=x;</span><br><span class="line">  x=y,y=z-y*(a/b);</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">xxtyfcz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> M,A,d,x,y;</span><br><span class="line">  M=m[<span class="number">1</span>];</span><br><span class="line">  A=a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    d=exgcd(M,m[i],x,y);</span><br><span class="line">    <span class="keyword">if</span>((a[i]-A)%d!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp=<span class="built_in">abs</span>(m[i]/d);</span><br><span class="line">    x=x*((a[i]-A)/d);</span><br><span class="line">    x=(x%temp+temp)%temp;</span><br><span class="line">    A=M*x+A;</span><br><span class="line">    M=M*m[i]/d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (A%M+M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h1><h2 id="1、POJ2689-Prime-Distance题解"><a href="#1、POJ2689-Prime-Distance题解" class="headerlink" title="1、POJ2689 Prime Distance题解"></a>1、POJ2689 Prime Distance题解</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong><a href="http://poj.org/problem?id=2689" target="_blank" rel="noopener">原题</a></strong></p>
<h5 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h5><p>The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by $1$ and itself). The first prime numbers are $2,3,5,7$ but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, $2,3$ are the only adjacent primes that are also adjacent numbers.<br>Your program is given $2$ numbers: $L$ and $U$ ($1 \leqslant L&lt; U \leqslant 2,147,483,647$), and you are to find the two adjacent primes $C1$ and $C2$ ($L \leqslant C1&lt; C2 \leqslant U$) that are closest (i.e. $C2-C1$ is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes $D1$ and $D2$ ($L \leqslant D1&lt; D2 \leqslant U$) where $D1$ and $D2$ are as distant from each other as possible (again choosing the first pair if there is a tie).</p>
<h5 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h5><p>给定两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647$)，求闭区间 $\left[L,R\right]$中相邻两个质数的差的最小值和最大值是多少，分别输出这两对质数</p>
<h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>每行两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647,R-L \leqslant 10^6$)</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个$L,R$，输出最小值和最大值，格式参照样例<br>若区间内无质数，输出”There are no adjacent primes.”</p>
<h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><p>2 17<br>14 17</p>
<h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><p>2,3 are closest, 7,11 are most distant.<br>There are no adjacent primes.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于$L,R$的范围很大，所以埃氏筛法和欧拉筛法都无法生成$\left[1,R\right]$的所有质数<br>但是$R-L$的范围很小且任何一个合数$n$一定包含一个不超过$\sqrt{n}$的质因子，所以我们只需要用筛法求出$2,3,\cdots,\sqrt{n}$的所有质数<br>而对于每一个质数$p$，标记$i \times p \left(\left\lceil\frac{L}{p}\right\rceil \leqslant i \leqslant \left\lceil\frac{R}{p}\right\rceil\right)$为合数<br>标记完后，剩下的所有数就是$\left[L,R\right]$中的质数了<br>再两两比较，找出差最大和最小的就可以了，时间复杂度$\Theta(\sqrt{R}lnln\sqrt{R}+(R-L)lnlnR)$</p>
<h2 id="2、洛谷P1072-Hankson的趣味题"><a href="#2、洛谷P1072-Hankson的趣味题" class="headerlink" title="2、洛谷P1072 Hankson的趣味题"></a>2、洛谷P1072 Hankson的趣味题</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">原题</a></strong><br>Hanks博士是 BT(Bio-Tech，生物技术)领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。<br>今天在课堂上，老师讲解了如何求两个正整数$c_1$和$c_2$的最大公约数和最小公倍数。现在Hankson认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数$a_0,a_1,b_0,b_1$，设某未知正整数$x$满足：<br>1.$x$和 $a_0$的最大公约数是$a_1$​；<br>2.$x$和$b_0$的最小公倍数是$b_1$。<br>Hankson的“逆问题”就是求出满足条件的正整数$x$。但稍加思索之后，他发现这样的$x$并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的$x$的个数。请你帮助他编程求解这个问题。</p>
<h4 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行为一个正整数$n$，表示有$n$组输入数据。接下来的$n$行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$​，每两个整数之间用一个空格隔开。输入数据保证$a_0$能被$a_1$整除，$b_1$能被$b_0$​整除。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>共$n$行。每组输入数据的输出结果占一行，为一个整数。<br>对于每组数据：若不存在这样的$x$，请输出$0$；<br>若存在这样的$x$，请输出满足条件的$x$的个数；</p>
<h4 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h5><p>2<br>41 1 96 288<br>95 1 37 1776 </p>
<h5 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h5><p>6<br>2</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>因为$x$是$b_1$的约数，所以$x$的质因子一定也是$b_1$的质因子，所以我对于$b_1$的每个质因子$p$，我们可以计算$x$中有多少个$p$<br>假设$a_0,a_1,b_0,b_1,x$中分别有$m_{a_0},m_{a_1},m_{b_0},m_{b_1},m_x$个质因子$p$<br>由于$gcd(a_0,x)=b_0$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0}$，则$m_x\geqslant m_{b_0}$</li>
<li>若$m_{a_0}&lt;m_{b_0}$，则$m_x$无解</li>
</ol>
<p>同理，由于$lcm(a_1,x)=b_1$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_1}&lt;m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_1}=m_{b_1}$，则$m_x\leqslant m_{b_1}$</li>
<li>若$m_{a_1}&gt;m_{b_1}$，则$m_x$无解</li>
</ol>
<p>综合以上所有情况，我们可以得出共有$5$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}=m_{b_1}$，则$m_x=m_{b_0}=m_{b_1}$</li>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_{b_0}\leqslant m_x\leqslant m_{b_1}$</li>
<li>若其他情况，则$m_x$均无解</li>
</ol>
<p>我们将$m_x$的取法记为$sum_p$，则$x$的数量为$\prod\limits_{\text{质数}p|d}sum_p$，时间复杂度$\Theta\left(\frac{n\sqrt{d}}{lnd}\right)$</p>
<h2 id="POJ3696-The-Luckiest-number"><a href="#POJ3696-The-Luckiest-number" class="headerlink" title="POJ3696 The Luckiest number"></a>POJ3696 The Luckiest number</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong><a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">原题</a></strong></p>
<h5 id="英文题目-1"><a href="#英文题目-1" class="headerlink" title="英文题目"></a>英文题目</h5><p>Chinese people think of ‘$8$’ as the lucky digit. Bob also likes digit ‘$8$’. Moreover, Bob has his own lucky number $L$. Now he wants to construct his luckiest number which is the minimum among all positive integers that are a multiple of $L$ and consist of only digit ‘$8$’.</p>
<h5 id="中文题意-1"><a href="#中文题意-1" class="headerlink" title="中文题意"></a>中文题意</h5><p>给定一个正整数$L$($L\leqslant 2\times10^9$)<br>问至少有多少个$8$连在一起组成的正整数是$L$的倍数</p>
<h4 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>每行一个正整数$L$($L\leqslant 2\times10^9$)</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个$L$，输出至少有多少个$8$连在一起组成的正整数是$L$的倍数，格式参照样例。若不存在，输出$0$</p>
<h4 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h5><p>8<br>11<br>16<br>0</p>
<h5 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h5><p>Case 1: 1<br>Case 2: 2<br>Case 3: 0</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>$n$个$8$连在一起组成的正整数可以记为$\frac{8}{9}(10^x-1)$<br>所以题目就转化为求最小的$x$使得$L|\frac{8}{9}(10^x-1)$<br>设$d=gcd(L,8)$<br>$L|\frac{8}{9}(10^x-1)\iff9L|8(10^x-1)\iff\frac{9L}{d}|10^x-1\iff10^x\equiv1\pmod{\frac{9L}{d}}$<br>这题的关键在于一个结论：若正整数$a,n$互质，则满足$a^x\equiv1\pmod{n}$的最小整数$x_0$为$\varphi(n)$的约数<br>证明：<br>假设满足$a^x\equiv1\pmod{n}$的最小整数$x_0$不能整除$\varphi(n)$<br>设$\varphi(n)=qx_0+r(0\leqslant r&lt;x_0)$<br>$\because a^{x_0}\equiv1\pmod{n}$<br>$\therefore a^{qx_0}\equiv1\pmod{n}$<br>又$\because a^{\varphi(n)}\equiv1\pmod{n}$（欧拉定理）<br>$\therefore a^{r}\equiv1\pmod{n}$，与$x_0$最小矛盾！<br>$\therefore$假设不成立，原命题成立</p>
<p>所以，我们只需要求出$\varphi(\frac{9L}{d})$，时间复杂度$\Theta(\sqrt{L}lnL)$</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>数论的练习题还有很多，在这里就不一一细细分析了，推荐几道题目供大家练习</p>
<ol>
<li><a href="https://www.luogu.org/problem/P1463" target="_blank" rel="noopener">洛谷P1463反素数</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1053" target="_blank" rel="noopener">双倍经验：BZOJ1053</a></li>
<li><a href="https://www.luogu.org/problem/P2261" target="_blank" rel="noopener">洛谷P2261余数求和</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1257" target="_blank" rel="noopener">双倍经验：BZOJ1257</a></li>
<li><a href="http://poj.org/problem?id=3090" target="_blank" rel="noopener">POJ3090Visible Lattice Points</a>这题洛谷上好像有原题，只是名字改了，有知道题号的可以跟我说</li>
<li><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">洛谷P1082同余方程</a></li>
<li><a href="http://poj.org/problem?id=3070" target="_blank" rel="noopener">POJ2891Strange Way to Express Integers</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2818" target="_blank" rel="noopener">BZOJ1257Gcd</a></li>
<li><a href="http://poj.org/problem?id=2480" target="_blank" rel="noopener">POJ2480Longge’s problem</a></li>
<li><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">洛谷P1516青蛙的约会</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1477" target="_blank" rel="noopener">双倍经验：BZOJ1447</a> <a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">三倍经验！！！POJ1061</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2242" target="_blank" rel="noopener">BZOJ2242计算器</a></li>
</ol>
<p><strong>参考材料：</strong><br><strong>1、《算法竞赛进阶指南》李煜东 著</strong><br><strong>2、《数论初步》周春荔 著</strong><br><strong>3、《简明数论》潘承洞、潘承彪 著</strong></p>
<p><strong>ps:写得比较匆忙，有错误请在评论区指出，我将及时更改，谢谢！</strong></p>
]]></content>
      <categories>
        <category>数学&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1072 DTOJ Begin1014Hankson的趣味题</title>
    <url>/2019/07/31/%E6%B4%9B%E8%B0%B7P1072-DTOJ%20Begin1014Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>Hanks博士是 BT(Bio-Tech，生物技术)领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。<br>今天在课堂上，老师讲解了如何求两个正整数$c_1$和$c_2$的最大公约数和最小公倍数。现在Hankson认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数$a_0,a_1,b_0,b_1$，设某未知正整数$x$满足：<br>1.$x$和 $a_0$的最大公约数是$a_1$；<br>2.$x$和$b_0$的最小公倍数是$b_1$。<br>Hankson的“逆问题”就是求出满足条件的正整数$x$。但稍加思索之后，他发现这样的$x$并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的$x$的个数。请你帮助他编程求解这个问题。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为一个正整数$n$，表示有$n$组输入数据。接下来的$n$行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$​，每两个整数之间用一个空格隔开。输入数据保证$a_0$能被$a_1$整除，$b_1$能被$b_0$​整除。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共$n$行。每组输入数据的输出结果占一行，为一个整数。<br>对于每组数据：若不存在这样的$x$，请输出$0$；<br>若存在这样的$x$，请输出满足条件的$x$的个数；</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>2<br>41 1 96 288<br>95 1 37 1776 </p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>6<br>2</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为$x$是$b_1$的约数，所以$x$的质因子一定也是$b_1$的质因子，所以我对于$b_1$的每个质因子$p$，我们可以计算$x$中有多少个$p$<br>假设$a_0,a_1,b_0,b_1,x$中分别有$m_{a_0},m_{a_1},m_{b_0},m_{b_1},m_x$个质因子$p$<br>由于$gcd(a_0,x)=b_0$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0}$，则$m_x\geqslant m_{b_0}$</li>
<li>若$m_{a_0}&lt;m_{b_0}$，则$m_x$无解</li>
</ol>
<p>同理，由于$lcm(a_1,x)=b_1$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_1}&lt;m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_1}=m_{b_1}$，则$m_x\leqslant m_{b_1}$</li>
<li>若$m_{a_1}&gt;m_{b_1}$，则$m_x$无解</li>
</ol>
<p>综合以上所有情况，我们可以得出共有$5$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}=m_{b_1}$，则$m_x=m_{b_0}=m_{b_1}$</li>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_{b_0}\leqslant m_x\leqslant m_{b_1}$</li>
<li>若其他情况，则$m_x$均无解</li>
</ol>
<p>我们将$m_x$的取法记为$sum_p$，则$x$的数量为$\prod\limits_{\text{质数}p|d}sum_p$<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a0,a1,b0,b1,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)a*b/gcd(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a0,&amp;a1,&amp;b0,&amp;b1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(b1);i++)</span><br><span class="line">    <span class="keyword">if</span>(b1%i==<span class="number">0</span>)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(gcd(i,a0)==a1&amp;&amp;lcm(i,b0)==b1) ans++;</span><br><span class="line">      <span class="keyword">if</span>(i*i!=b1) <span class="keyword">if</span>(gcd(b1/i,a0)==a1&amp;&amp;lcm(b1/i,b0)==b1) ans++;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>洛谷</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>矢量（向量）</title>
    <url>/2019/07/30/%E7%9F%A2%E9%87%8F%EF%BC%88%E5%90%91%E9%87%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1、矢量的定义"><a href="#1、矢量的定义" class="headerlink" title="1、矢量的定义"></a>1、矢量的定义</h2><p>矢量是一种既有大小又有方向的量，又称为向量。在计算机中，矢量图可以无限放大永不变形 <del>（反正我没看懂）</del>。——百度百科</p>
<a id="more"></a>
<h2 id="2、矢量的表示及其相关量的表示"><a href="#2、矢量的表示及其相关量的表示" class="headerlink" title="2、矢量的表示及其相关量的表示"></a>2、矢量的表示及其相关量的表示</h2><h3 id="1-矢量的表示"><a href="#1-矢量的表示" class="headerlink" title="(1)矢量的表示"></a>(1)矢量的表示</h3><p>矢量可以表示为一个小写字母$a$上面一个箭头$\vec{a}$（ps:正确的箭头应该是$\rightharpoonup$这样的，而不是$\rightarrow$的，但$L_{A}T^{E}X$上打不出来）或者一个粗体 <strong>A</strong><br>在$n$维空间内，矢量通常被表示为一个$n$元组$(a_{1},a_{2},\cdots \cdots,a_{n})$</p>
<h3 id="2-矢量夹角的表示"><a href="#2-矢量夹角的表示" class="headerlink" title="(2)矢量夹角的表示"></a>(2)矢量夹角的表示</h3><p>两个矢量$\vec{a},\vec{b}$的夹角表示为$\langle\vec{a},\vec{b}\rangle$</p>
<h2 id="3、矢量的运算"><a href="#3、矢量的运算" class="headerlink" title="3、矢量的运算"></a>3、矢量的运算</h2><h2 id="1-矢量的模"><a href="#1-矢量的模" class="headerlink" title="(1)矢量的模"></a>(1)矢量的模</h2><p>即矢量的长度，记为$|\vec{a}|$</p>
<h3 id="2-矢量的加法"><a href="#2-矢量的加法" class="headerlink" title="(2)矢量的加法"></a>(2)矢量的加法</h3><p>满足三角形法则，如图<br><img src="https://img-blog.csdnimg.cn/20190719195643588.png" alt=""></p>
<h3 id="3-矢量的减法"><a href="#3-矢量的减法" class="headerlink" title="(3)矢量的减法"></a>(3)矢量的减法</h3><p>满足平行四边形法则，如图<br><img src="https://img-blog.csdnimg.cn/20190719195730190.png" alt="在这里插入图片描述"></p>
<h3 id="4-矢量的点乘"><a href="#4-矢量的点乘" class="headerlink" title="(4)矢量的点乘"></a>(4)矢量的点乘</h3><p>两个矢量的点乘是标量，$(a_{1},a_{2},\cdots\cdots,a_{n})\cdot(b_{1},b_{2},\cdots\cdots,b_{n})\overset{\underset{def}{}}{=}\sum \limits_{i=1}^{n}a_{i}b_{i},\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|cos(\langle\vec{a},\vec{b}\rangle)$<br>这时，我们终于可以给出矢量的模的表达式了$|\vec{a}|\overset{\underset{def}{}}{=}\sqrt{(\vec{a})^2}$<br>点乘满足交换律和分配律</p>
<h3 id="5-矢量的叉乘"><a href="#5-矢量的叉乘" class="headerlink" title="(5)矢量的叉乘"></a>(5)矢量的叉乘</h3><p>有$0.999999994538$的概率我们不考虑矢量的叉乘后的结果，我们只考虑矢量的叉乘后矢量的模<br>$(a_{1},a_{2})\times(b_{1},b_{2})\overset{\underset{def}{}}{=}a_{1}b_{2}-a_{2}b_{1},\vec{a}\times\vec{b}=|\vec{a}||\vec{b}|sin(\langle\vec{a},\vec{b}\rangle)$<br>矢量的叉乘的本质的有向面积，它的方向满足右手螺旋法则：先把手掌除大拇指以外的$4$个指头展开，指向$\vec{a}$的方向，然后把$4$个指头弯起来，弯的方向由$\vec{a}$转向矢量$\vec{b}$（转的角度须小于$\pi$），此时大拇指立起的方向，就是$\vec{a}\times\vec{b}$的方向。<br>矢量的叉乘满足逆交换律，即$\vec{a}\times\vec{b}=-\vec{b}\times\vec{a}$</p>
<h3 id="6-矢量的极角"><a href="#6-矢量的极角" class="headerlink" title="(6)矢量的极角"></a>(6)矢量的极角</h3><p>向量$\vec{a}$的极角$\theta$为$atan2(y,x)$</p>
<h2 id="4、矢量的变换"><a href="#4、矢量的变换" class="headerlink" title="4、矢量的变换"></a>4、矢量的变换</h2><h3 id="1-缩放"><a href="#1-缩放" class="headerlink" title="(1)缩放"></a>(1)缩放</h3><p>$\vec{a}$方向的单位矢量（即长度为1的矢量）为$\frac{\vec{a}}{|a|}$<br>与$\vec{a}$同向但长度为$l$的矢量为</p>
<h3 id="2-平移"><a href="#2-平移" class="headerlink" title="(2)平移"></a>(2)平移</h3><p>平移后的矢量和平移前的矢量是同一个向量</p>
<h3 id="3-旋转"><a href="#3-旋转" class="headerlink" title="(3)旋转"></a>(3)旋转</h3><p>矢量$\vec{a}=(x,y)$逆时针旋转$\theta$，得到的矢量$\vec{a’}=(xcos\theta-ysin\theta,ycos\theta+xsin\theta)$</p>
<h3 id="4-投影"><a href="#4-投影" class="headerlink" title="(4)投影"></a>(4)投影</h3><p>矢量$\vec{b}$在矢量$\vec{a}$上的投影为$\vec{a}\frac{\vec{a}\cdot\vec{b}}{\vec{a}^2}$</p>
<h3 id="5-对称"><a href="#5-对称" class="headerlink" title="(5)对称"></a>(5)对称</h3><p>记矢量$\vec{b}$在矢量$\vec{a}$上的投影为$\vec{c}=\vec{a}\frac{\vec{a}\cdot\vec{b}}{\vec{a}^2}$，则矢量$\vec{b}$关于矢量$\vec{a}$的对称为$\vec{b}-2(\vec{b}-\vec{s})=2\vec{a}\frac{\vec{a}\cdot\vec{b}}{\vec{a}^2}=\vec{b}$</p>
]]></content>
      <categories>
        <category>数学&amp;物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基础之图形面积（体积）计算</title>
    <url>/2019/07/29/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%88%E4%BD%93%E7%A7%AF%EF%BC%89%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="一、平面图形面积"><a href="#一、平面图形面积" class="headerlink" title="一、平面图形面积"></a>一、平面图形面积</h1><script type="math/tex; mode=display">\boxed{积分的要领1：以长方形为基础来思考}</script><a id="more"></a>
<h2 id="1、简单图形的面积"><a href="#1、简单图形的面积" class="headerlink" title="1、简单图形的面积"></a>1、简单图形的面积</h2><h3 id="1-长方形"><a href="#1-长方形" class="headerlink" title="(1)长方形"></a>(1)长方形</h3><p>长$\times$宽，<del>不会的请离开</del></p>
<h3 id="2-三角形"><a href="#2-三角形" class="headerlink" title="(2)三角形"></a>(2)三角形</h3><p>底$\times$高/2，<del>不会的请离开</del></p>
<h3 id="3-平行四边形"><a href="#3-平行四边形" class="headerlink" title="(3)平行四边形"></a>(3)平行四边形</h3><p>底$\times$高，<del>不会的请离开</del></p>
<h3 id="4-梯形"><a href="#4-梯形" class="headerlink" title="(4)梯形"></a>(4)梯形</h3><p>$($上底$+$下底$)\times$高/2，<del>不会的请离开</del></p>
<h3 id="2、稍微复杂一点的图形面积"><a href="#2、稍微复杂一点的图形面积" class="headerlink" title="2、稍微复杂一点的图形面积"></a>2、稍微复杂一点的图形面积</h3><script type="math/tex; mode=display">\boxed{积分的要领2：把图形看作小长方形的组合}</script><h3 id="1-圆"><a href="#1-圆" class="headerlink" title="(1)圆"></a>(1)圆</h3><h4 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h4><p>用圆规在方格纸上画一个圆，接着数一数圆中的方格数<br>我在边长为$1mm$的方格纸上画了一个半径为$2cm$的圆，我算(shǔ)出圆中共有$1189$个格子，所以我们算出的圆周率是$2.9725$<br>虽然这个误差很大，但是，随着格子边长的缩小，我们的准确度就越高</p>
<h4 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h4><p>有什么办法可以提高精度吗？有，如图，我们把圆分成细长的小条来求<del>由于我太懒了，所以只画了3条</del><br><img src="https://img-blog.csdnimg.cn/20190728100923496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""><br>每一个小条的宽度是$\Delta x$，表示非常小的数值<br>这样，我们可以得出圆的面积$=\int_{左端}^{右端}短条在x值对应的长度dx$<br>$dx$可以理解为$\lim \limits_{\Delta x \rightarrow 0}\Delta x$<br>我做了一个实验，计算半径为$1cm$的圆，把它分成$N$个小条，制成一张表格<br>|$N$|所有小条的总面积|<br>|—|—|<br>|$10$|$2.637049$|<br>|$20$|$2.904518$|<br>|$40$|$3.028465$|<br>|$200$|$3.120417$|<br>|$2000$|$3.139555$|<br>|$20000$|$3.141391$|<br>可见$N$越来越大时，小条的总面积就会越接近圆的面积$\pi r^{2}$</p>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>椭圆是由圆拉伸来的，所以我们也可以把它分成细长的短条来求，这个小条的面积就是圆的小条面积的$\frac{a}{b}$倍，所以，椭圆的面积就是$\pi ab$</p>
<script type="math/tex; mode=display">\boxed{积分的要领3：把图形分解成长方形然后进行伸缩变换}</script><p><img src="https://img-blog.csdnimg.cn/20190728103006934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""></p>
<h1 id="立体图形表面积和体积"><a href="#立体图形表面积和体积" class="headerlink" title="立体图形表面积和体积"></a>立体图形表面积和体积</h1><h2 id="祖暅定理"><a href="#祖暅定理" class="headerlink" title="祖暅定理"></a>祖暅定理</h2><script type="math/tex; mode=display">\boxed{积分的要领4：把图形看作被切割后的组合}</script><p>在外国称作卡瓦列利原理<br>截面面积总是相等的两个立体图形，体积也相等</p>
<h2 id="三分之一之谜"><a href="#三分之一之谜" class="headerlink" title="三分之一之谜"></a>三分之一之谜</h2><script type="math/tex; mode=display">\boxed{积分的要领5：灵活应用祖暅定理}</script><p>大家都知道圆锥的体积公式吧？体积$=$底面积$\times$高$\times\frac{1}{3}$<br>话说这个$\frac{1}{3}$是哪来的？<br>首先，我们从四棱锥说起<br>我们先把C点平移到A的正上方，使得$AC\perp$平面$ABD$（祖暅定理）<br><img src="https://img-blog.csdnimg.cn/20190729110729838.png" alt=""><br>$                     \Downarrow$<br><img src="https://img-blog.csdnimg.cn/20190729111056314.png" alt=""><br>这时，我们发现3个这样的椎体可以拼成一个长方形，因此，我们可以得到这个四棱锥的体积就是$\frac{1}{3}\times$底面积$\times$高<br>得到了四棱锥的体积之后，我们就可以计算任意椎体的体积了<br>我们把椎体的底面分成许多很小的长方形，所以每一个小四棱锥的体积相加就是椎体的体积了，也就等于$\frac{1}{3}\times$底面积$\times$高</p>
<h2 id="球的体积"><a href="#球的体积" class="headerlink" title="球的体积"></a>球的体积</h2><p>我们先做出一个立体图形，我把它称为钵体，它是一个圆柱再去掉一个圆锥后的图形<br><img src="https://img-blog.csdnimg.cn/20190729113104741.png" alt=""><br>我们可以发现，它的每一个截面的面积和一个半球上的截面的面积相同，所以，根据祖暅定理，我们可以知道，球的体积$=2\times\frac{2}{3}\pi R^3=\times\frac{4}{3}\pi R^3$</p>
<script type="math/tex; mode=display">\boxed{积分的要领6：寻找“有效的对应、关系条件”}</script><h2 id="球的表面积"><a href="#球的表面积" class="headerlink" title="球的表面积"></a>球的表面积</h2><script type="math/tex; mode=display">\boxed{积分的要领7：相比“纠结于细节”，“如何思考才能顺利计算”更优先}</script><p>我们把球的表面分成许多小的四棱锥，所以，我们可以得到球的体积$=\frac{1}{3}\times R\times$球的表面积<br>所以，我们可以得到球的表面积$=4\pi R^2$</p>
<h1 id="终极问题——甜甜圈的体积"><a href="#终极问题——甜甜圈的体积" class="headerlink" title="终极问题——甜甜圈的体积"></a>终极问题——甜甜圈的体积</h1><p>大家都知道甜甜圈吧？<br><img src="https://img-blog.csdnimg.cn/2019072912252495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""><br>我用软件画了一个甜甜圈，我们假设甜甜圈边上的圆心到中心的距离为$4cm$，半径为$2cm$，我们尝试水平切割，我们就可以得到一个个圆环<br>这些圆环的外圈的半径$=4+\sqrt{4-x^2}$，内圈的半径$=4-\sqrt{4-x^2}$，所以这个截面的面积$=16\pi\sqrt{4-x^2}$（$x$代表到圆心的距离）<br>由此，我们就可以表示出整个甜甜圈的体积就是$\int_{-2}^{2}16\pi\sqrt{4-x^2}dx$这个积分是在不需要我们计算，我们只要画一个图就行了<br><img src="https://img-blog.csdnimg.cn/20190729123434408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""><br>积分相当于计算这个图形的面积，所以也就是$\int_{-2}^{2}16\pi\sqrt{4-x^2}dx=16\pi\times2\pi=32\pi^{2}$</p>
<p><strong>参考材料：</strong><br><strong>《简单微积分》神永正博 著</strong></p>
]]></content>
      <categories>
        <category>物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2894 DTOJ Begin1549[USACO08FEB]酒店Hotel题解</title>
    <url>/2019/07/27/%E6%B4%9B%E8%B0%B7P2894-DTOJ%20Begin1549%5BUSACO08FEB%5D%E9%85%92%E5%BA%97Hotel%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>奶牛们最近的旅游计划，是到苏必利尔湖畔，享受那里的湖光山色，以及明媚的阳光。作为整个旅游的策划者和负责人，贝茜选择在湖边的一家著名的旅馆住宿。这个巨大的旅馆一共有$N (1 \leqslant N \leqslant 50000)$间客房，它们在同一层楼中顺次一字排开，在任何一个房间里，只需要拉开窗帘，就能见到波光粼粼的湖面。<br>贝茜一行，以及其他慕名而来的旅游者，都是一批批地来到旅馆的服务台，希望能订到$D_{i} (1 \leqslant D_{i} \leqslant N)$间连续的房间。<br>服务台的接待工作也很简单：如果存在r满足编号为$r \cdots \cdots r+D_{i}-1$的房间均空着，他就将这一批顾客安排到这些房间入住；如果没有满足条件的r，他会道歉说没有足够的空房间，请顾客们另找一家宾馆。如果有多个满足条件的r，服务员会选择其中最小的一个。 旅馆中的退房服务也是批量进行的。每一个退房请求由$2$个数字$X_{i}、D_{i}$描述，表示编号为$X_{i} \cdots \cdots X_{i}+D_{i}-1 (1 \leqslant X_{i} \leqslant N-D_{i}+1)$房间中的客人全部离开。退房前，请求退掉的房间中的一些，甚至是所有，可能本来就无人入住。<br>而你的工作，就是写一个程序，帮服务员为旅客安排房间。你的程序一共需要处理$M (1 \leqslant M &lt; 50000)$个按输入次序到来的住店或退房的请求。第一个请求到来前，旅店中所有房间都是空闲的。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第$1$行: $2$个用空格隔开的整数$N$和$M$<br>第$2 \cdots \cdots M+1$行:第$i+1$描述了第$i$个请求，如果它是一个订房请求，则用$2$个数字$1$和$D_{i}$描述，数字间用空格隔开；如果它是一个退房请求，用$3$个以空格隔开的数字$2$、$X_{i}$和$D_{i}$描述</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个订房请求，输出$1$个数：如果请求能被满足，输出满足条件的最小的$r$；如果请求无法被满足，输出$0$</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>10 6<br>1 3<br>1 3<br>1 3<br>1 3<br>2 5 5<br>1 6</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>1<br>4<br>7<br>0<br>5</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们先将题目简化一下，这道题需要我们实现$2$个操作：<br>1、订房:相当于查询是否有连续$D$个位置是空的，如果有输出最左端点<br>2、退房:相当于将$X$到$X+D-1$这段位置置为空<br>因此，我们很容易看出，这是一道支持区间查询和区间修改的线段树题。<br>要解决这个问题，每个节点都需要维护$4$个变量：<br>1、$lm$从左数最多有多少个连续的$0$<br>2、$rm$从右数最多有多少个连续的$0$<br>3、$m$整个区间最多有多少个连续的$0$<br>4、$sum$区间的长度<br>（读者：什么！？不用延迟标记（俗称$lazy$标志）吗？）<br>（我：…延迟标记还要写在这里吗？区间修改不是肯定需要吗?）<br> 一开始，因为整个区间都是空的，所以我们将这些的值都赋为区间的长度。<br>当遇到一个查询的时候，就从根节点开始查询，为了保证最后得到的答案一定是靠左的，所以我们都先判断左边的连续$0$的个数是否大于我们需要的$D$，如果是就直接返回左端点，然后，用同样的方法判断判断中间和右边的部分。<br>当遇到修改的时候，就正常修改，只是在最后上传标志的时候会稍微复杂一点点，有几种情况需要判断。<br>最后，因为我们涉及了区间修改，所以每做一步操作都要下放标志<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(i) t[i].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(i) t[i].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m(i) t[i].m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm(i) t[i].lm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm(i) t[i].rm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(i) t[i].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(i) t[i].add</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l,r,m,lm,rm,sum,add;</span><br><span class="line">&#125;t[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//上传标志</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(sum(<span class="number">2</span>*p)==m(<span class="number">2</span>*p)) lm(p)=sum(<span class="number">2</span>*p)+lm(<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> lm(p)=lm(<span class="number">2</span>*p);</span><br><span class="line">  <span class="keyword">if</span>(sum(<span class="number">2</span>*p+<span class="number">1</span>)==m(<span class="number">2</span>*p+<span class="number">1</span>)) rm(p)=sum(<span class="number">2</span>*p+<span class="number">1</span>)+rm(<span class="number">2</span>*p);</span><br><span class="line">  <span class="keyword">else</span> rm(p)=rm(<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">  m(p)=max(m(<span class="number">2</span>*p),m(<span class="number">2</span>*p+<span class="number">1</span>));</span><br><span class="line">  m(p)=max(m(p),rm(<span class="number">2</span>*p)+lm(<span class="number">2</span>*p+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//下放标志</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> add=add(p);</span><br><span class="line">  add(p)=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l(p)==r(p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(add==<span class="number">1</span>)&#123;</span><br><span class="line">    lm(<span class="number">2</span>*p)=rm(<span class="number">2</span>*p)=m(<span class="number">2</span>*p)=sum(<span class="number">2</span>*p);</span><br><span class="line">    lm(<span class="number">2</span>*p+<span class="number">1</span>)=rm(<span class="number">2</span>*p+<span class="number">1</span>)=m(<span class="number">2</span>*p+<span class="number">1</span>)=sum(<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>*p)=add(<span class="number">2</span>*p+<span class="number">1</span>)=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(add==<span class="number">2</span>)&#123;</span><br><span class="line">    lm(<span class="number">2</span>*p)=rm(<span class="number">2</span>*p)=m(<span class="number">2</span>*p)=<span class="number">0</span>;</span><br><span class="line">    lm(<span class="number">2</span>*p+<span class="number">1</span>)=rm(<span class="number">2</span>*p+<span class="number">1</span>)=m(<span class="number">2</span>*p+<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">    add(<span class="number">2</span>*p)=add(<span class="number">2</span>*p+<span class="number">1</span>)=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//建树 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  l(p)=l;</span><br><span class="line">  r(p)=r;</span><br><span class="line">  lm(p)=rm(p)=m(p)=sum(p)=r-l+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  build(<span class="number">2</span>*p,l,mid);</span><br><span class="line">  build(<span class="number">2</span>*p+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span><span class="comment">//区间修改 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pushdown(p);</span><br><span class="line">  <span class="keyword">int</span> l=l(p),r=r(p);</span><br><span class="line">  <span class="keyword">if</span>(l==x&amp;&amp;y==r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>) lm(p)=rm(p)=m(p)=sum(p);</span><br><span class="line">    <span class="keyword">else</span> lm(p)=rm(p)=m(p)=<span class="number">0</span>;</span><br><span class="line">    add(p)=f;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(mid&gt;=y) change(<span class="number">2</span>*p,x,y,f);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;x) change(<span class="number">2</span>*p+<span class="number">1</span>,x,y,f);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    change(<span class="number">2</span>*p,x,mid,f);</span><br><span class="line">    change(<span class="number">2</span>*p+<span class="number">1</span>,mid+<span class="number">1</span>,y,f);</span><br><span class="line">  &#125;</span><br><span class="line">  pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span><span class="comment">//区间查询 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pushdown(p);</span><br><span class="line">  <span class="keyword">int</span> l=l(p),r=r(p),mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">  <span class="keyword">if</span>(m(<span class="number">2</span>*p)&gt;=x) <span class="keyword">return</span> ask(<span class="number">2</span>*p,x);</span><br><span class="line">  <span class="keyword">if</span>(rm(<span class="number">2</span>*p)+lm(<span class="number">2</span>*p+<span class="number">1</span>)&gt;=x) <span class="keyword">return</span> mid-rm(<span class="number">2</span>*p)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ask(<span class="number">2</span>*p+<span class="number">1</span>,x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">  build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> f,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f);</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">      <span class="keyword">if</span>(t[<span class="number">1</span>].m&lt;x) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=ask(<span class="number">1</span>,x);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        change(<span class="number">1</span>,p,p+x<span class="number">-1</span>,<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      change(<span class="number">1</span>,x,x+y<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2120 DTOJ1099仓库建设题解</title>
    <url>/2019/07/27/%E6%B4%9B%E8%B0%B7P2120-DTOJ1099%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problemnew/show/P2120" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>$L$公司有$N$个工厂，由高到底分布在一座山上。<br>工厂$1$在山顶，工厂$N$在山脚。 由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。<br>突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。<br>由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_{i}$件，在第$i$个工厂位置建立仓库的费用是$C_{i}$。<br>对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。<br>假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p>
<ul>
<li>工厂$i$距离工厂$1$的距离$X_{i}$（其中$X_{1}=0$）;</li>
<li>工厂$i$目前已有成品数量$P_{i}$;</li>
<li>在工厂$i$建立仓库的费用$C_{i}$;</li>
</ul>
<p>请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_{i},P_{i},C_{i}$, 意义如题中所述。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅包含一个整数，为可以找到最优方案的费用。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>3<br>0 5 10<br>5 3 100<br>9 6 10</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>32</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>在工厂$1$和工厂$3$建立仓库，建立费用为$10+10=20$，运输费用为$(9-5)*3=12$，总费用$32$。<br>如果仅在工厂$3$建立仓库，建立费用为$10$，运输费用为$(9-0)5+(9-5)3=57$，总费用$67$，不如前者优。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于20%的数据， $N \leqslant 500$；<br>对于40%的数据， $N \leqslant 10000$；<br>对于100%的数据， $N \leqslant 1000000$。 所有的$X_{i},P_{i},C_{i}$均在$32$位带符号整数以内，保证中间计算结果不超过$64$位带符号整数。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，这一道题是一道$DP$题，所以，我们先用普通的$DP$做一下这题。<br>假设$f_{i}$表示工厂$1$到$i$的最小总费用<br>令$sp_{i}=\sum \limits_{j=1}^{i} p_{j}$，$s_{i}=\sum \limits_{j=1}^{i} s_{j}p_{j}$<br>由于产品只能往山下运（即只能运往编号更大的工厂的仓库），所以当编号在区间$\left[l,r\right]$中的工厂只有一个仓库（即只有一个仓库在工厂$r$）时，这段区间的费用为$c_{r}+\sum \limits_{i=l}^{r} p_{i} \times \left(x_{r}-x_{i}\right)=c_{r}+x_{r} \times \left(sp_{r}-sp_{l-1}\right)-s_{r}+s_{l-1}$<br>所以，状态转移方程就是$f_{i}=\min \limits_{0 \leqslant j &lt; i} \left\{f_{j}+x_{i} \times \left(sp_{i}-sp_{j}\right)-s_{i}+s_{j}\right\}+c_{i}$<br>最终的结果是$f_{n}$<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,x[<span class="number">1000010</span>],c[<span class="number">1000010</span>],p[<span class="number">1000010</span>],sp[<span class="number">1000010</span>],s[<span class="number">1000010</span>],f[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  sp[<span class="number">0</span>]=s[<span class="number">0</span>]=f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">    sp[i]=sp[i<span class="number">-1</span>]+p[i],s[i]=s[i<span class="number">-1</span>]+x[i]*p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minf=<span class="number">9223372036854775807</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) minf=min(minf,f[j]+x[i]*(sp[i]-sp[j])-s[i]+s[j]);</span><br><span class="line">    f[i]=minf+c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种普通的$DP$的复杂度是$\Theta \left(n^{2}\right)$，只能得到55分，所以，我们需要优化一下程序。<br>假设我们在计算$f_{i}$，此时有两个决策$a,b$满足$a&gt;b$且$a$比$b$优，即$f_{a}+x_{i} \times \left(sp_{i}-sp_{a}\right)-s_{i}+s_{a}<f_{b}+x_{i} \times \left(sp_{i}-sp_{b}\right)-s_{i}+s_{b}$化简得：
$f_{a}+s_{a}-f_{b}-s_{b}<x_{i} \times \left(sp_{a}+sp_{b}\right)$
$\frac{f_{a}+s_{a}-f_{b}-s_{b}}{sp_{a}+sp_{b}}<x_{i}$
所以我们可以维护一个单调队列，使得从队尾到队首，$\frac{f_{a+1}+s_{a+1}-f_{a}-s_{a}}{sp_{a+1}+sp_{a}}$递减，保证队首决策最优，并每次决策从队首转移即可
代码如下：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,r,x[<span class="number">1000010</span>],c[<span class="number">1000010</span>],p[<span class="number">1000010</span>],sp[<span class="number">1000010</span>],s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000010</span>],q[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">    s[i]=s[i<span class="number">-1</span>]+x[i]*p[i],sp[i]=sp[i<span class="number">-1</span>]+p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r&amp;&amp;f[q[l+<span class="number">1</span>]]+s[q[l+<span class="number">1</span>]]-f[q[l]]-s[q[l]]&lt;x[i]*(sp[q[l+<span class="number">1</span>]]-sp[q[l]])) l++;</span><br><span class="line">    f[i]=f[q[l]]+c[i]+x[i]*(sp[i]-sp[q[l]])-s[i]+s[q[l]];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r&amp;&amp;(f[q[r]]+s[q[r]]-f[q[r<span class="number">-1</span>]]-s[q[r<span class="number">-1</span>]])*(sp[i]-sp[q[r]])&gt;(f[i]+s[i]-f[q[r]]-s[q[r]])*(sp[q[r]]-sp[q[r<span class="number">-1</span>]])) r--;</span><br><span class="line">    q[++r]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为每个元素入队出队次数都是$\Theta \left(1\right)$的，且转移复杂度也是$\Theta \left(1\right)$，所以总复杂度为$\Theta \left(n\right)$。</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>洛谷</tag>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2689 Prime Distance题解</title>
    <url>/2019/07/27/POJ2689%20Prime%20Distance%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="http://poj.org/problem?id=2689" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<h3 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h3><p>The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by $1$ and itself). The first prime numbers are $2,3,5,7$ but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, $2,3$ are the only adjacent primes that are also adjacent numbers.<br>Your program is given $2$ numbers: $L$ and $U$ ($1 \leqslant L&lt; U \leqslant 2,147,483,647$), and you are to find the two adjacent primes $C1$ and $C2$ ($L \leqslant C1&lt; C2 \leqslant U$) that are closest (i.e. $C2-C1$ is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes $D1$ and $D2$ ($L \leqslant D1&lt; D2 \leqslant U$) where $D1$ and $D2$ are as distant from each other as possible (again choosing the first pair if there is a tie).</p>
<h3 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h3><p>给定两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647$)，求闭区间 $\left[L,R\right]$中相邻两个质数的差的最小值和最大值是多少，分别输出这两对质数。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每行两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647,R-L \leqslant 10^6$)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个$L,R$，输出最小值和最大值，格式参照样例。若区间内无质数，输出”There are no adjacent primes.”。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>2 17<br>14 17</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>2,3 are closest, 7,11 are most distant.<br>There are no adjacent primes.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于$L,R$的范围很大，所以埃氏筛法和欧拉筛法都无法生成$\left[1,R\right]$的所有质数。但是$R-L$的范围很小且任何一个合数$n$一定包含一个不超过$\sqrt{n}$的质因子，所以我们只需要用筛法求出$2,3,\cdots,\sqrt{n}$的所有质数。而对于每一个质数$p$，标记$i \times p \left(\left\lceil\frac{L}{p}\right\rceil \leqslant i \leqslant \left\lceil\frac{R}{p}\right\rceil\right)$为合数。标记完后，剩下的所有数就是$\left[L,R\right]$中的质数了。再两两比较，找出差最大和最小的就可以了。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,t1,t2,x1,x2,y1,y2,l,r,a[<span class="number">100001</span>], b[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span><span class="comment">//筛出2~46340之间的质数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v,<span class="number">1</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">46340</span>;i++) <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">    a[++n]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="number">46340</span>/i;j++) v[i*j]=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  prime();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">1</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span>(l==<span class="number">1</span>) v[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(j=l/a[i];j&lt;=r/a[i];j++) <span class="keyword">if</span>(j&gt;<span class="number">1</span>) v[a[i]*j-l]=<span class="literal">false</span>;<span class="comment">//去除L~R中的合数</span></span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l;i&lt;=r;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(v[i-l]) b[++m]=i;<span class="comment">//存储L~R中的质数</span></span><br><span class="line">      <span class="keyword">if</span>(i==r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t1=<span class="number">2147483647</span>;</span><br><span class="line">    t2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">      j=b[i+<span class="number">1</span>]-b[i];</span><br><span class="line">      <span class="keyword">if</span>(j&lt;t1)&#123;</span><br><span class="line">        t1=j;</span><br><span class="line">        x1=b[i];</span><br><span class="line">        y1=b[i+<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j&gt;t2)&#123;</span><br><span class="line">        t2=j;</span><br><span class="line">        x2=b[i];</span><br><span class="line">        y2=b[i+<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">//比较差的大小</span></span><br><span class="line">    <span class="keyword">if</span>(!t2) <span class="built_in">cout</span>&lt;&lt;<span class="string">"There are no adjacent primes."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;x1&lt;&lt;<span class="string">","</span>&lt;&lt;y1&lt;&lt;<span class="string">" are closest, "</span>&lt;&lt;x2&lt;&lt;<span class="string">","</span>&lt;&lt;y2&lt;&lt;<span class="string">" are most distant."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1172 DTOJ Begin1777安全逃离题解</title>
    <url>/2019/07/27/%E6%B4%9B%E8%B0%B7P1172-DTOJ%20Begin1777%E5%AE%89%E5%85%A8%E9%80%83%E7%A6%BB%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problemnew/show/P1172" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>农夫john最近在研究如果发生重大事故，如何让农场里的奶牛逃离问题。他想要确信在紧急情况下，所有的奶牛都有一个安全逃离方案。因为在紧急情况下，奶牛们都会失去观察和判断能力，所以最近john一直在教奶牛们逃离的方法，他的方法很简单，就是任何时候都只向北方或东方逃离，北方是行坐标减1的方向，东方是列坐标加1的方向。奶牛们虽笨，不过这一点事关自己的生命，所以他们牢记在心，而且也一定会这么做。</p>
<p>当然也会出问题，奶牛们在逃离的方向上会横冲直撞，为了阻止奶牛之间互相冲撞造成伤害，john要求任何一个奶牛的逃离路线不能经过其它奶牛的初始位置。一个逃离方案是安全的如果它能够满足上面的要求，反之它就是不安全的。</p>
<p>奶牛们所在的土地（农场）被划分成了rr行和cc列的一个矩形地图。奶牛们都待在这个矩形中的某一个位置。</p>
<p>请帮助john确定给定的一个地图上是否存在一个安全的逃离方案。</p>
<p>比如，下面的两个图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3Uub3JnL3VwbG9hZC9waWMvNzI0MC5wbmc" alt=""></p>
<p>左边的例子表示了一个能够安全逃离的地图，因为没有任何一个奶牛的逃离路线上包括其他奶牛。右边的例子表示了一个不安全的地图，因为位于(4,1)(4,1)的奶牛不论是向东逃离还是向北逃离，它的路线上都会有别的奶牛，从这个图中拿掉任意一头奶牛，这个地图都会变成安全的。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第$1$行：两个整数$r,c$，用1个空格隔开，表示矩形的行数和列数（均 $\le 50$）。<br>第$2$行：一个整数$n$，表示奶牛的个数（$\le 100$）。<br>第$3$到$n+2$行：共$n$行，每行有$2$个整数，之间用$1$个空格隔开，分别表示这头奶牛所在的行和列。<br><strong>每输入完一行后，会输入多余的字符！！！</strong></p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如果这块土地是安全的，输出$0$。<br>如果移走任意一头奶牛这块土地还是不安全，输出$-1$。<strong>否则输出移走的那头奶牛的编号，如果有多个奶牛满足要求，输出所有的数</strong>。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>5 5<br>5<br>1 1<br>2 4<br>3 1<br>2 2<br>2 1</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>1<br>5</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这一题的题目有问题（我在百度上查了，所有题目都是错的。多亏了洛谷的在线测评，把题解复制在上面执行，就可以知道题目错误了）。我整整研究了一天才研究出来。最后，我是在另一个人提交的AC程序上找出了我的错误。这个错误你根本是不可能想到的（虽然我不知道以前的人是怎么发现的），这个错误是就是<strong>我在题目中加粗的字</strong>其实这个问题我在一个OJ上也有注意到（那个OJ可以下载不完整的数据），但是我并不知道这是一个漏洞。<br>这道题的思路就是模拟，首先遍历所有的奶牛，若全部安全，则输出0，结束。如果不是全部安全的，则每次将一只奶牛删除，再遍历全部，看看是否全是安全的，如果是，则输出该奶牛编号，直到所有情况都遍历完了，再讨论-1的情况。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">51</span>][<span class="number">51</span>],h,l,n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cow</span>&#123;</span>     <span class="comment">//结构体，也可以用x[101]和y[101] </span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">cow a[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anquan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;     <span class="comment">//每头奶牛安全的条件 </span></span><br><span class="line">  <span class="keyword">int</span> t1=<span class="number">1</span>,t2=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;i++) <span class="keyword">if</span>(m[i][y]) &#123;t1=<span class="number">0</span>;<span class="keyword">break</span>;&#125;     <span class="comment">//如果北面有奶牛，那么t1=0 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=y+<span class="number">1</span>;i&lt;=l;i++) <span class="keyword">if</span>(m[x][i]) &#123;t2=<span class="number">0</span>;<span class="keyword">break</span>;&#125;     <span class="comment">//如果东面有奶牛，那么t2=0 </span></span><br><span class="line">  <span class="keyword">if</span>(t1==<span class="number">0</span>&amp;&amp;t2==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//如果两边都有奶牛，则不安全，反之安全 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qaq</span><span class="params">()</span></span>&#123;     <span class="comment">//所有奶牛都安全 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l;j++) <span class="keyword">if</span>(m[i][j]) <span class="keyword">if</span>(!(anquan(i,j))) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">//遍历整个农场，如果有奶牛不安全，那么返回0 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//否则返回1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;     <span class="comment">//去掉一只奶牛后安全</span></span><br><span class="line">  m[x][y]=<span class="number">0</span>;     <span class="comment">//删除奶牛</span></span><br><span class="line">  <span class="keyword">return</span> qaq();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;h&gt;&gt;l&gt;&gt;n;</span><br><span class="line">  <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));<span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));     <span class="comment">//初始化 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i].x&gt;&gt;a[i].y;     <span class="comment">//输入 </span></span><br><span class="line">    m[a[i].x][a[i].y]=i;     <span class="comment">//也可以赋值为1 </span></span><br><span class="line">    gets(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(qaq()) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;     <span class="comment">//如果全部安全，输出0，结束 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(aq(a[i].x,a[i].y)) <span class="comment">/*如果去掉后安全*/</span><span class="keyword">if</span>(!temp) <span class="comment">/*如果是第一次输出*/</span><span class="built_in">cout</span>&lt;&lt;i,temp++; <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;i; </span><br><span class="line">    m[a[i].x][a[i].y]=i;     <span class="comment">//这步非常重要，不然第二次执行的时候就删除了两只奶牛 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!temp) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;     <span class="comment">//如果删掉任何一只奶牛都不安全，输出-1 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2019/07/25/Hello%20Hexo/</url>
    <content><![CDATA[<p>今天，我创建了Hexo博客。但我太弱了，希望各位大佬多多指教。</p>
]]></content>
  </entry>
</search>
