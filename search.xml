<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DTOJ5021 最近公共祖先</title>
    <url>/2020/11/11/DTOJ5021-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>注：本题来源于2020牛客暑期多校训练营（第六场）D题data structure</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>作为此次 NOIP 模拟的最后一道题，宫水三叶决定把题意说得简单一点<br>给一棵大小为$n$的以$rt$为根的树<br>有$m$组询问，每次询问 l,r,xl,r,xl,r,x，你要回答有多少$l \leqslant a &lt; b \leqslant r$，满足$a,b$的最近公共祖先为$x$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个整数$n,m,rt$<br>接下来$n-1$行，每行两个整数$x_i,y_i$，表示一条边<br>接下来$m$行，每行三个整数$l_i,r_i,x_i$，表示一组询问</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$m$行，第$i$行表示第$i$个询问的答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10 7</span><br><span class="line">4 2</span><br><span class="line">10 4</span><br><span class="line">3 2</span><br><span class="line">6 10</span><br><span class="line">9 2</span><br><span class="line">7 3</span><br><span class="line">1 4</span><br><span class="line">8 2</span><br><span class="line">5 3</span><br><span class="line">8 10 10</span><br><span class="line">2 6 2</span><br><span class="line">3 6 2</span><br><span class="line">4 6 4</span><br><span class="line">3 10 2</span><br><span class="line">8 8 10</span><br><span class="line">3 10 4</span><br><span class="line">2 3 2</span><br><span class="line">2 6 4</span><br><span class="line">1 7 10</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">7</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>本题采用捆绑测试<br>对于所有测试点，满足$1\leqslant n,m \leqslant 2\times 10^5,1\leqslant rt \leqslant n$<br>子任务编号 | $n,m$ | 分值<br>—|—|—<br>$1$|$\leqslant 200$|$5$<br>$2$|$\leqslant 2000$|$20$<br>$3$|$\leqslant 5\times 10^4$|$35$<br>$4$|$\leqslant 2\times 10^5$|$40$<br><strong>提示：本题时间限制为 2S ，请选手注意 IO 用时</strong></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>考虑将问题转化为：$x$的子树中在$[l,r]$之间的点对数，减去$x$的子节点的子树中在$[l,r]$之间的点对数（因为$x$的子节点一定是它的子树中在$[l,r]$之间的点对的公共祖先，所以最近公共祖先一定不为$x$）<br>前半部分很简单，直接使用主席树就可以了（这个稍微想一想就可以了，是基本的主席树）<br>主要是后半部分如何解决<br>有一个可以很容易想到的就是先重链剖分，然后就可以让重儿子按照上面的方式去算<br>对于轻儿子的话，没有什么太好的处理方法，所以考虑用莫队，$l$和$r$变化时，就让这个点一直沿着重链条就可以了<br>效率为$\Theta(mlogn+n\sqrt{n}logn)$，如果常数小（用莫队时的每一块的大小选得好），可能可以得$60$分<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,x,pos;</span><br><span class="line">&#125;q[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,ch[<span class="number">2</span>];</span><br><span class="line">&#125;t[<span class="number">20000010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ppap2&gt;Q[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,rt,tot,cnt,Tot,d,head[<span class="number">200010</span>],to[<span class="number">400010</span>],nxt[<span class="number">400010</span>],fa[<span class="number">200010</span>],siz[<span class="number">200010</span>],son[<span class="number">200010</span>],top[<span class="number">200010</span>],dfn[<span class="number">200010</span>],nfd[<span class="number">200010</span>],Dfn[<span class="number">200010</span>],root[<span class="number">200010</span>],k[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[<span class="number">200010</span>],sum[<span class="number">200010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)  &#123;f|=(ch==<span class="string">'-'</span>);ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">    x=f?-x:x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap2 &amp;x,<span class="keyword">const</span> ppap2 &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k[x.l]==k[y.l]?((k[x.l]&amp;<span class="number">1</span>)?x.r&lt;y.r:x.r&gt;y.r):k[x.l]&lt;k[y.l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[x],to[tot]=y,head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[x]=Fa,siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[x])&#123;</span><br><span class="line">        siz[x]+=dfs1(to[i],x);</span><br><span class="line">        <span class="keyword">if</span>(siz[to[x]]&gt;maxson) maxson=siz[to[x]],son[x]=to[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=Top,dfn[x]=++cnt,nfd[cnt]=x;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs2(son[x],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[x]&amp;&amp;to[i]!=son[x]) dfs2(to[i],to[i]);</span><br><span class="line">    Dfn[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((!t[p].l)&amp;&amp;(!t[p].r)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[p].l==x&amp;&amp;t[p].r==y) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=(t[p].l+t[p].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;=mid) <span class="keyword">return</span> ask(t[p].ch[<span class="number">0</span>],x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;=mid+<span class="number">1</span>) <span class="keyword">return</span> ask(t[p].ch[<span class="number">1</span>],x,y);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(t[p].ch[<span class="number">0</span>],x,mid)+ask(t[p].ch[<span class="number">1</span>],mid+<span class="number">1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> q,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[++Tot].l=l,t[Tot].r=r,p=Tot;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[p].sum++;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    t[p].ch[x&lt;=mid]=t[q].ch[x&lt;=mid];</span><br><span class="line">    <span class="keyword">if</span>(x&gt;mid) build(t[p].ch[<span class="number">1</span>],t[q].ch[<span class="number">1</span>],mid+<span class="number">1</span>,r,x);</span><br><span class="line">    <span class="keyword">else</span> build(t[p].ch[<span class="number">0</span>],t[q].ch[<span class="number">0</span>],l,mid,x);</span><br><span class="line">    t[p].sum=t[t[p].ch[<span class="number">0</span>]].sum+t[t[p].ch[<span class="number">1</span>]].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i=fa[top[x]];x=i) sum[i]+=s[top[x]],s[top[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i=fa[top[x]];x=i) s[top[x]]--,sum[i]-=s[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">js</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) build(root[i],root[i<span class="number">-1</span>],<span class="number">1</span>,n,nfd[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(son[i]) <span class="keyword">for</span>(ppap2 j:Q[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> x=ask(root[Dfn[i]],j.l,j.r)-ask(root[dfn[i]<span class="number">-1</span>],j.l,j.r),sum=ask(root[Dfn[son[i]]],j.l,j.r)-ask(root[dfn[son[i]]<span class="number">-1</span>],j.l,j.r);</span><br><span class="line">        ans[j.pos]+=<span class="number">1l</span>l*x*(x<span class="number">-1</span>)/<span class="number">2</span><span class="number">-1l</span>l*sum*(sum<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d=n/(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n*<span class="number">2</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) k[i]=(i<span class="number">-1</span>)/d;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l=<span class="number">1</span>,r=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) r++,add(r);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) l--,add(l);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) dec(r),r--;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) dec(l),l++;</span><br><span class="line">        ans[q[i].pos]-=sum[q[i].x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n),read(m),read(rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) read(x),read(y),add(x,y),add(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) read(q[i].l),read(q[i].r),read(q[i].x),q[i].pos=i,Q[q[i].x].push_back(q[i]);</span><br><span class="line">    dfs1(rt,<span class="number">0</span>),dfs2(rt,rt),js();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>考虑怎么优化呢？刚刚的问题在于轻儿子可能很多，这大大增加了第二部分的时间复杂度，怎么办呢？我们考虑以为伪树剖，设置一个闸值$Siz$，对于所有$size&gt;Siz$的子树，把它们都当做$x$的重儿子<br>这样，我们就可以减少轻儿子的数量，从而平衡两边的复杂度<br>好像还有可以优化的，就是主席树可以换成一个树状数组，这样代码即短，又可以节省时间（因为主席树是一棵升级版的线段树，虽然线段树的效率是$\Theta(nlogn)$，但是常数巨大，受许多因素影响，但是树状数组的效率比较稳定，这样更容易通过，不需要卡常）<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,x,h;</span><br><span class="line">&#125;q[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,h,f1,f2,f3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">200010</span>];</span><br><span class="line">&#125;t;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hson[<span class="number">200010</span>],lson[<span class="number">200010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;ppap2&gt; Q[<span class="number">200010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">int</span> n,m,rt,tot,cnt,Tot,d,nt=<span class="number">-1</span>,head[<span class="number">200010</span>],to[<span class="number">400010</span>],nxt[<span class="number">400010</span>],fa[<span class="number">200010</span>],siz[<span class="number">200010</span>],top[<span class="number">200010</span>],dfn[<span class="number">200010</span>],Dfn[<span class="number">200010</span>],root[<span class="number">200010</span>],k[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[<span class="number">200010</span>],sum[<span class="number">200010</span>],ans[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)  &#123;f|=(ch==<span class="string">'-'</span>);ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">    x=f?-x:x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap1 &amp;x,<span class="keyword">const</span> ppap1 &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k[x.l]==k[y.l]?((k[x.l]&amp;<span class="number">1</span>)?x.r&lt;y.r:x.r&gt;y.r):k[x.l]&lt;k[y.l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[x],to[tot]=y,head[x]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>,dfn[x]=++cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[x]) fa[to[i]]=x,dfs1(to[i]),siz[x]+=siz[to[i]];</span><br><span class="line">    <span class="keyword">int</span> Siz=<span class="built_in">sqrt</span>(siz[x])/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[x])</span><br><span class="line">        <span class="keyword">if</span>(siz[to[i]]&gt;Siz) hson[x].push_back(to[i]);</span><br><span class="line">        <span class="keyword">else</span> lson[x].push_back(to[i]);</span><br><span class="line">    Dfn[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=Top;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y:hson[x]) dfs2(y,Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y:lson[x]) dfs2(y,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=(x&amp;(-x))) t.c[x]++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=(x&amp;(-x))) ans+=t.c[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i=fa[top[x]];x=i) sum[i]+=s[top[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i;i=fa[top[x]];x=i) sum[i]-=--s[top[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">js</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Add(dfn[i]);</span><br><span class="line">        <span class="keyword">for</span>(ppap2 x:Q[i])&#123;</span><br><span class="line">            temp[x.f3]+=(ask(Dfn[x.x])-ask(dfn[x.x]<span class="number">-1</span>))*x.f2;</span><br><span class="line">            <span class="keyword">if</span>(x.f2==<span class="number">1</span>) ans[x.h]+=<span class="number">1l</span>l*temp[x.f3]*(temp[x.f3]<span class="number">-1</span>)/<span class="number">2</span>*(x.f1?<span class="number">1</span>:<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d=n/<span class="built_in">sqrt</span>(n*<span class="number">2</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) k[i]=(i<span class="number">-1</span>)/d;</span><br><span class="line">    sort(q+<span class="number">1</span>,q+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l=<span class="number">1</span>,r=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) add(++r);</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) add(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) dec(r--);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) dec(l++);</span><br><span class="line">        ans[q[i].h]-=sum[q[i].x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    read(n),read(m),read(rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) read(x),read(y),add(x,y),add(y,x);</span><br><span class="line">    dfs1(rt),dfs2(rt,rt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        read(q[i].l),read(q[i].r),read(q[i].x),q[i].h=i,temp.push_back(<span class="number">0</span>),nt++,Q[q[i].l<span class="number">-1</span>].push_back((ppap2)&#123;q[i].x,i,<span class="number">1</span>,<span class="number">-1</span>,nt&#125;),Q[q[i].r].push_back((ppap2)&#123;q[i].x,i,<span class="number">1</span>,<span class="number">1</span>,nt&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x:hson[q[i].x]) temp.push_back(<span class="number">0</span>),nt++,Q[q[i].l<span class="number">-1</span>].push_back((ppap2)&#123;x,i,<span class="number">0</span>,<span class="number">-1</span>,nt&#125;),Q[q[i].r].push_back((ppap2)&#123;x,i,<span class="number">0</span>,<span class="number">1</span>,nt&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    js();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>温馨提示：</strong><br>请不要把排序的$cmp$程序写成类似于这样的形式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap1 &amp;x,<span class="keyword">const</span> ppap1 &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k[x.l]==k[y.l]&amp;&amp;(k[x.l]&amp;<span class="number">1</span>)&amp;&amp;x.r&lt;y.r;</span><br><span class="line">    <span class="keyword">return</span> k[x.l]==k[y.l]&amp;&amp;x.r&gt;y.r;</span><br><span class="line">    <span class="keyword">return</span> k[x.l]&lt;k[y.l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>否则，你就会T，虽然我也不知道是什么原因，但是我知道：三目运算符行！（难道是太多<code>&amp;&amp;</code>了？求大佬解答）<del>就为了这个问题，我调了快一个小时/kk</del></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>树状数组</tag>
        <tag>图论</tag>
        <tag>树剖</tag>
        <tag>LCA</tag>
        <tag>分块</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>基础组合计数常用的概念和方法总结</title>
    <url>/2020/11/11/%E5%9F%BA%E7%A1%80%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、组合计数中的基本概念与性质"><a href="#一、组合计数中的基本概念与性质" class="headerlink" title="一、组合计数中的基本概念与性质"></a>一、组合计数中的基本概念与性质</h1><h2 id="1、排列"><a href="#1、排列" class="headerlink" title="1、排列"></a>1、排列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一般地，从n个不同元素中取出$m(m\leqslant n)$个元素，按照一定的顺序排成一列，叫做从$n$个元素中取出$m$个元素的一个排列<br>特别地，当$m=n$时，这个排列被称作全排列，记作$A_n^m$<br><a id="more"></a></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>$A_n^m=\frac{n!}{(n-m)!}$<br>证明：第一个数有$n$种选择，第二个数有$n-1$种选择，……，第$m$个数有$n-m+1$<br>$\therefore A_n^m=\prod \limits_{i=n}^{n-m+1}i=\frac{n!}{(n-m)!}$</p>
<h2 id="2、组合"><a href="#2、组合" class="headerlink" title="2、组合"></a>2、组合</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>从$n$个不同的元素中，任取$m(m\leqslant n)$个元素为一组，叫作从$n$个不同元素中取出$m$个元素的一个组合，记作$C_n^m$或$\binom{n}{m}$</p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>①$\binom{n}{m}=\frac{n!}{m!(n-m)!}$<br>证明：先从从$n$个元素中取出$m$个元素的一个排列，有$A^m_n$种取法，再把所有排列中的数排序，有$A^m_m$个是重复的<br>$\therefore \binom{n}{m}=\frac{A^m_n}{A^m_m}=\frac{n!}{m!(n-m)!}$<br>②$\binom{n}{m}=\binom{n}{n-m}$<br>证明（数学法）：$\binom{n}{m}=\frac{n!}{m!(n-m)!}=\frac{n!}{(n-m)!(n-(n-m))!}=\binom{n}{n-m}$</p>
<hr>
<p>证明（讲故事法）：从前，有一个班级有$n$个小朋友，老师要从中选$m$个小朋友扫地，共有$\binom{n}{m}$种方法，相当于从中选出$n-m$个小朋友不扫地，有$\binom{n}{n-m}$种方法<br>$\therefore \binom{n}{m}=\binom{n}{n-m}$<br><del>多么精彩的故事啊！此处应有掌声</del><br>③$\binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}$<br>证明（数学法）：$\binom{n}{m}=\frac{n!}{m!(n-m)!}=\frac{m}{n}\times \frac{n!}{m!(n-m)!}+\frac{n-m}{n}\times \frac{n!}{m!(n-m)!}=\frac{(n-1)!}{(m-1)!(n-m)!}+\frac{(n-1)!}{m!(n-m-1)!}=\binom{n-1}{m-1}+\binom{n-1}{m}$</p>
<hr>
<p>证明（讲故事法）：从前，有一个班级有$n$个小朋友，老师要从中选$m$个小朋友扫地，共有$\binom{n}{m}$种方法。也可以先决定$1$号小朋友选不选，如果选，就在剩下的$n-1$个小朋友中选出$m-1$个小朋友扫地，有$\binom{n-1}{m-1}$种方法；如果不选，就在剩下的$n-1$个小朋友中选出$m$个小朋友扫地，有$\binom{n-1}{m}$种方法，一共$\binom{n-1}{m-1}+\binom{n-1}{m}$种方法<br>$\therefore \binom{n}{m}=\binom{n-1}{m-1}+\binom{n-1}{m}$<br><del>多么精彩的故事啊！此处应有掌声</del><br>④$m\binom{n}{m}=n\binom{n-1}{m-1}$<br>证明（数学法）：$m\binom{n}{m}=m\times \frac{n!}{m!(n-m)!}=\frac{n!}{(m-1)!(n-m)!}=n\times \frac{(n-1)!}{(m-1)!(n-1-(m-1))!}=n\binom{n-1}{m-1}$</p>
<hr>
<p>证明（讲故事法）：从前，有一个班级有$n$个小朋友，老师要从中选$m$个小朋友扫地再选出一个人担任扫地长（？？？），共有$m\binom{n}{m}$种方法。也可以先选一个扫地长，再在剩下的$n-1$个小朋友中选出$m-1$个小朋友扫地，有$n\binom{n-1}{m-1}$种方法<br>$\therefore m\binom{n}{m}=n\binom{n-1}{m-1}$<br><del>多么精彩的故事啊！此处应有掌声</del><br>⑤$\sum \limits_{i=0}^n\binom{n}{i}=2^n$<br>证明（数学法）：$\sum \limits_{i=0}^n\binom{n}{i}=\sum \limits_{i=0}^n\binom{n}{i}\times 1^i\times 1^{n-i}=(1+1)^n=2^n$</p>
<hr>
<p>证明（讲故事法）：从前，有一个班级有$n$个小朋友，老师要从中选若干个小朋友扫地，共有$\sum \limits_{i=0}^n\binom{n}{i}$种方法。也可以先决定$1$号小朋友选不选，有$2$种方法，再决定$2$号小朋友选不选，也有$2$种方法……最后决定$n$号小朋友选不选，还是有$2$种方法，有$2^n$种方法<br>$\sum \limits_{i=0}^n\binom{n}{i}=2^n$<br><del>多么精彩的故事啊！此处应有掌声</del> </p>
<hr>
<p>我写的所谓的“讲故事法”在证明组合恒等式的时候非常的有用<del>但是这里不讲</del>，主要的难度就是在于故事是什么，剩下的就没有什么难度了</p>
<h1 id="二、组合计数中的一些常用技巧"><a href="#二、组合计数中的一些常用技巧" class="headerlink" title="二、组合计数中的一些常用技巧"></a>二、组合计数中的一些常用技巧</h1><h2 id="1、容斥原理"><a href="#1、容斥原理" class="headerlink" title="1、容斥原理"></a>1、容斥原理</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复<br>这种计数的方法称为容斥原理</p>
<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>$\left|\bigcup \limits_{i=1}^nA_i\right|=\sum \limits_{k=1}^n(-1)^{k-1}\sum \limits_{0&lt;i_1&lt;i_2&lt;\cdots&lt;i_k\leqslant n}\left|\bigcap \limits_{i=1}^kA_{i_k}\right|$<br>我觉得这个结论很显然，举个例子，当$n=3$时，我们可以画一个<del>Van</del>Venn图：<br><img src="https://img-blog.csdnimg.cn/20200216183300251.png" alt="在这里插入图片描述"><br>我不会严格证明，但是度娘上有，可以自己看</p>
<h2 id="2、捆绑与插空法"><a href="#2、捆绑与插空法" class="headerlink" title="2、捆绑与插空法"></a>2、捆绑与插空法</h2><p>这是啥？<br>这两种方法是用来解决排列时两个人要求不能在一起或者必须在一起的问题</p>
<h3 id="捆绑法"><a href="#捆绑法" class="headerlink" title="捆绑法"></a>捆绑法</h3><p>考虑这样一个问题：有$n$个人排队，其中有两个人一定要排在一起，问有几种排法<br>显然，我们可以考虑把这两个人绑在一起，将他们合并为一个人<br>所以相当于是$n-1$个人排队，最后记得考虑两个人内部的顺序，共$2(n-1)!$种</p>
<h3 id="插空法"><a href="#插空法" class="headerlink" title="插空法"></a>插空法</h3><p>考虑这样一个问题：有$n$个人排队，其中有两个人一定不排在一起，问有几种排法<br>上面是合并，现在呢？我们先把剩下的$n-2$个人排好序，留出$n-1$个空位，然后把这两个人塞到空位里去就完事了，共$(n-2)!(n-1)(n-2)$种</p>
<h2 id="3、隔板法"><a href="#3、隔板法" class="headerlink" title="3、隔板法"></a>3、隔板法</h2><p>组合计数中在生成函数以前及其重要的方法之一，延伸出去，就是<a href="https://blog.csdn.net/weixin_43849488/article/details/108089650" target="_blank" rel="noopener">斯特林数</a>以及正整数的拆分问题<br>考虑这样一个问题：有$n$个相同的球，$k$个不同的盒子，把$n$个球放到盒子里，盒子不允许为空，有多少种方案<br>如何计数呢？很简单，我们把$n$个球排成一行，在中间放上$k-1$块板<br>接着，我们把第$i-1$块板和第$i$块板之间的球放到第$i$个盒子中就完了<br>所以答案就是$\binom{n-1}{k-1}$<br>是不是很简单？<br>那么下一个问题：求不定方程$x_1+x_2+\cdots \cdots x_k=n$（$x_i$为正整数）的解的个数<br>聪明的你一定会发现，这个问题和上面的问题一毛一样<br>接着，下一个问题：有$n$个相同的球，$k$个不同的盒子，把$n$个球放到盒子里，盒子<strong>允许</strong>为空，有多少种方案<br>这怎么处理？我们考虑一种转化的思路<br>这个问题相当于：求不定方程$x_1+x_2+\cdots \cdots x_k=n$（$x_i$为<strong>自然数</strong>）的解的个数<br>所以，我们设$y_i=x_i+1$，则问题转化为求不定方程$y_1+y_2+\cdots \cdots y_k=n+k$（$x_i$为正整数）的解的个数<br>因此，答案就是$\binom{n+k-1}{k-1}$</p>
<hr>
<p>这就是基础的组合计数常用的概念和方法了，至于练习，建议做《数学奥林匹克竞赛小丛书》里的内容</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数的常见计算方法</title>
    <url>/2020/11/11/%E7%BB%84%E5%90%88%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="低级版"><a href="#低级版" class="headerlink" title="低级版"></a>低级版</h1><h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p>直接用组合数性质中的③式递推即可<br><a id="more"></a></p>
<h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mod,c[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) c[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    c[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$\Theta (n^2)$</p>
<h1 id="高级版"><a href="#高级版" class="headerlink" title="高级版"></a>高级版</h1><h2 id="方法概述-1"><a href="#方法概述-1" class="headerlink" title="方法概述"></a>方法概述</h2><p>这一种求组合数的方法用到了一个著名的定理——Lucas定理！<br>我们先来了解一下这个神奇的定理</p>
<h2 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><p>设$p$为质数，$\binom{n}{m}\equiv\binom{n/p}{m/p}\binom{n\%p}{m\%p}\pmod{p}$<br>证明：设$n=sp+q,m=tp+r$且$q,r&lt;p$<br>$\because (1+x)^p\equiv (1+x^p)\pmod{p}$（费马小定理）<br>$\therefore (1+x)^n\equiv (1+x)^{ps}(1+x)^q\equiv\left(1+x^p\right)^s(1+x)^q=\sum \limits_{i=0}^s\binom{s}{i}x^{ip}\times \sum \limits_{j=0}^{q}\binom{q}{j}x^j=\sum \limits_{i=0}^{sp+q}\binom{sp+q}{i}x^i\pmod{p}$<br>$\therefore \binom{s}{t}\binom{q}{r}\equiv\binom{sp+q}{tp+r}\equiv \binom{n}{m}\pmod{p}$（$x^{tp+r}$的系数）<br>$\therefore \binom{n}{m}\equiv\binom{n/p}{m/p}\binom{n\%p}{m\%p}\pmod{p}$<br>有了这个定理，我们就可以用来解决$p$为质数的情况了，只需要递归一下就可以了<br>但是$p$不是质数呢？<del>那肯定是出题人看你不爽，故意搞你</del><br>这时候，我们就要请出我们的救星——exLucas定理！</p>
<h2 id="exLucas定理"><a href="#exLucas定理" class="headerlink" title="exLucas定理"></a>exLucas定理</h2><p><a href="https://jrjacky.github.io/2020/03/13/exLucas%E5%AE%9A%E7%90%86/#more">exLucas定理</a></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>分段打表万岁！</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>初中生都看得懂的快速上手斯特林数指南--从盒放球问题说起</title>
    <url>/2020/11/11/%E5%88%9D%E4%B8%AD%E7%94%9F%E9%83%BD%E7%9C%8B%E5%BE%97%E6%87%82%E7%9A%84%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E6%8C%87%E5%8D%97-%E4%BB%8E%E7%9B%92%E6%94%BE%E7%90%83%E9%97%AE%E9%A2%98%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<p><del>第一次当标题党好方，但好像也没啥问题，因为我就是一个初中的菜鸡</del></p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol>
<li><a href="https://jrjacky.github.io/2020/11/11/%E5%9F%BA%E7%A1%80%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/">基础的组合计数知识</a></li>
<li>NTT（非必要）</li>
<li>看到一长串的式子不会晕过去的能力<a id="more"></a>
<h1 id="盒放球"><a href="#盒放球" class="headerlink" title="盒放球"></a>盒放球</h1>盒放球问题可以描述为：<blockquote>
<p>有$n$个相同/不同的球，$k$个相同/不同的盒子，把$n$个球放到盒子里，盒子允许/不允许为空，有多少种方案</p>
</blockquote>
</li>
</ol>
<p>稍微有点智商的人都知道，这一共有$2\times2\times2=8$个问题<br>我们一个个来看</p>
<h2 id="球相同，盒不同，不允许为空"><a href="#球相同，盒不同，不允许为空" class="headerlink" title="球相同，盒不同，不允许为空"></a>球相同，盒不同，不允许为空</h2><p>这个非常简单，只需要使用隔板法就可以了，在$n-1$个空中插入$k-1$个板，把球隔成$k$段，每一段对应地放到盒子中，所以有$\binom{n-1}{k-1}$种</p>
<h2 id="球相同，盒不同，允许为空"><a href="#球相同，盒不同，允许为空" class="headerlink" title="球相同，盒不同，允许为空"></a>球相同，盒不同，允许为空</h2><p>这回变成了允许为空，怎么办？<br>很简单，先在每个盒子里都放一个球，这样就转化为了<code>球相同，盒不同，不允许为空</code>的情况了！一共有$\binom{n+k-1}{k-1}$</p>
<h2 id="球相同，盒相同，不允许-允许为空"><a href="#球相同，盒相同，不允许-允许为空" class="headerlink" title="球相同，盒相同，不允许/允许为空"></a>球相同，盒相同，不允许/允许为空</h2><p>这个需要使用到母函数（生成函数），不是本篇文章的重点，所以先不讲</p>
<h2 id="球不同，盒不同，允许为空"><a href="#球不同，盒不同，允许为空" class="headerlink" title="球不同，盒不同，允许为空"></a>球不同，盒不同，允许为空</h2><p>这个应该没人不会吧……当然是$k^n$种了</p>
<h2 id="球不同，盒相同，不允许为空"><a href="#球不同，盒相同，不允许为空" class="headerlink" title="球不同，盒相同，不允许为空"></a>球不同，盒相同，不允许为空</h2><p>emmm……<br>这是一个很有难度的问题，我们先看看如何递推吧<br>假设有$S(n,k)$种，那么可能是前$n-1$个球就用了$k$个盒子，那么我们把第$n$个球放在$k$个盒子中的任意一个即可；如果前$n-1$个球用了$k-1$个盒子，那么我们就把第$n$个球放在第$k$个盒子中<br>所以$S(n,k)=S(n-1,k)\times k+S(n-1,k-1)$<br>话说我们不是要斯特林数吗？怎么还没讲？<br>别急，看看这个问题所使用的的字母：$S$，好像跟斯特林的首字母一样<br>不会吧不会吧，难道这就是传说中的斯特林数，原来斯特林数这么简单！！！<del>对，您太强了，所以觉得简单，可以爆踩我这个菜鸡，妈妈再也不用担心你的学习啦！（大雾</del><br>接下来，我们暂且放下剩下的两种盒放球问题，来看看我们刚刚计算的$S(n,k)$，也就是第二类斯特林数的定义</p>
<h1 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将$n$个元素分成$m$个<strong>无标号</strong>的集合$S(n,m)=\begin{Bmatrix}n\\m\end{Bmatrix}$<br>等等，啥叫无标号集合啊？如果用上面的盒放球问题来解释，就是盒子是相同的，如果严谨一点说，就是如果一<strong>堆</strong>集合调换顺序后和另一<strong>堆</strong>集合完全相同（所有对应的集合都相等），那么这两<strong>堆</strong>集合就是等价的<br>比如$\{\{1\},\{2,3\}\}$和$\{\{2,3\},\{1\}\}$就是等价的<br>看到这里，相信有的人还是理解不了第二类斯特林数，所以，我们举一个例子：$\begin{Bmatrix}3\\2\end{Bmatrix}=3$<br>三种方法如下：</p>
<ol>
<li>$\{\{1\},\{2,3\}\}$</li>
<li>$\{\{2\},\{1,3\}\}$</li>
<li>$\{\{3\},\{1,2\}\}$</li>
</ol>
<p>现在清楚多了吧？</p>
<h2 id="通项"><a href="#通项" class="headerlink" title="通项"></a>通项</h2><p>第二类斯特林数的通项为$\begin{Bmatrix}n\\m\end{Bmatrix}=\frac{1}{m!}\sum \limits_{i=0}^m(-1)^i\binom{m}{i}(m-i)^n$<br>可以通过盒放球问题，来感性理解这个公式：我们考虑容斥，假设有$i$个空盒，那么，我们先从$m$个盒子中，选出$i$个，剩下的盒子随便塞<br>最后，不要忘记<strong>无标号</strong>这个问题，所以我们需要除以$m!$<br>这个公式非常重要，它可以帮助我们用NTT计算出一整行的第二类斯特林数，这个后面会讲到</p>
<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><p>在开始讲NTT求第二类斯特林数之前，为了让大家放松心情，我们先来看看第二类斯特林数的特殊值：<br>$\begin{Bmatrix}n\\0\end{Bmatrix}=0,\begin{Bmatrix}n\\1\end{Bmatrix}=1,\begin{Bmatrix}n\\n-1\end{Bmatrix}=\binom{n}{2},\begin{Bmatrix}n\\n\end{Bmatrix}=1$<br>自己想吧，太简单了，不证了</p>
<h2 id="计算第二类斯特林数"><a href="#计算第二类斯特林数" class="headerlink" title="计算第二类斯特林数"></a>计算第二类斯特林数</h2><p><strong>Warning!Warning!Warning!前方高能，请没学过NTT迅速跳过这一节</strong><br>好的，我们开始推式子吧！<br>$\begin{Bmatrix}n\\m\end{Bmatrix}=\frac{1}{m!}\sum \limits_{i=0}^m(-1)^i\binom{m}{i}(m-i)^n=\frac{1}{m!}\sum \limits_{i=0}^m(-1)^i\frac{m!}{i!(m-i)!}(m-i)^n=\sum \limits_{i=0}^m\frac{(-1)^i}{i!}\frac{(m-i)^n}{(m-i)!}$<br>看，这是什么？是不是一个漂亮的卷积式？<br>还没看出来？设$f(x)=\sum \limits_{i\geqslant 0} \frac{(-1)^i}{i!}x^i,g(x)=\sum\limits_{i\geqslant 0}\frac{i^n}{i!}x^i$，则$\begin{Bmatrix}n\\m\end{Bmatrix}$就是$f(x)$和$g(x)$的卷积<br>所以，我们就可以愉快地使用逆天塔（NTT）了！<br><a href="https://www.luogu.com.cn/problem/P5395" target="_blank" rel="noopener">模板题</a>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ljc 167772161</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,r[<span class="number">800006</span>],lim,w[<span class="number">800006</span>],a[<span class="number">800006</span>],b[<span class="number">800006</span>],inv[<span class="number">800006</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fast_pow</span><span class="params">(ll a,ll b,ll p)</span></span>&#123;</span><br><span class="line">    ll t=<span class="number">1</span>;a%=p;</span><br><span class="line">    <span class="keyword">while</span> (b)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) t=t*a%p;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;a=a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll f[],<span class="keyword">int</span> lim,<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;r[i]) swap(f[r[i]],f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    w[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;lim;len&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll gen=fast_pow(<span class="number">3</span>,(ljc<span class="number">-1</span>)/(len&lt;&lt;<span class="number">1</span>)*id+ljc<span class="number">-1</span>,ljc);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++) w[i]=w[i<span class="number">-1</span>]*gen%ljc;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i+=len&lt;&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            ll *f1=f+i,*f2=f1+len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)&#123;</span><br><span class="line">                ll x=f1[j]%ljc,y=f2[j]*w[j]%ljc;</span><br><span class="line">                f1[j]=(x+y)%ljc;f2[j]=(x-y+ljc)%ljc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (id==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    ll Inv=fast_pow(lim,ljc<span class="number">-2</span>,ljc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) f[i]=f[i]*Inv%ljc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;n++;</span><br><span class="line">    inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) inv[i]=inv[i<span class="number">-1</span>]*inv[i]%ljc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>,one=<span class="number">1</span>;i&lt;n;one=ljc-one,i++)&#123;</span><br><span class="line">        a[i]=one*inv[i]%ljc;b[i]=fast_pow(i,n<span class="number">-1</span>,ljc)*inv[i]%ljc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lim=<span class="number">1</span>,len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lim&lt;=(n&lt;&lt;<span class="number">1</span>)) lim&lt;&lt;=<span class="number">1</span>,len++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(len<span class="number">-1</span>));</span><br><span class="line">    NTT(a,lim,<span class="number">1</span>);NTT(b,lim,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lim;i++) a[i]=a[i]*b[i]%ljc;</span><br><span class="line">    NTT(a,lim,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h2><p>你有没有见过这样的题目：让你求$\sum\limits_{i=1}^ni^k$的题目？<br>你可能会想：这不简单吗，每次使用快速幂不就好了嘛<br>不！没有那么简单！$n\leqslant 10^9,k\leqslant 5000$的时候你还能用快速幂吗？不能！<del>不要告诉我你要分段打表</del><br>但是！第二类斯特林数可以！<br>这只能说明：斯特林数（停顿）行！快速幂（停顿）不行！我爱斯特林数！<del>老伏拉夫了</del><br>那斯特林数到底怎么行了呢？我们要从一个假快速幂讲起</p>
<h3 id="快速幂？"><a href="#快速幂？" class="headerlink" title="快速幂？"></a>快速幂？</h3><p>$n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}$<br>其中$n^{\underline{i}}$表示$n$的$i$次下降幂，即$n^{\underline{i}}=\prod \limits_{k=0}^{i-1}(n-k)$<br>证明：<br>考虑归纳证明，当$m=1$时，$\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}=\begin{Bmatrix}1\\1\end{Bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{k+1}=n\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} n^{\underline{i}}=\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix}\left( n^{\underline{i+1}}+in^{\underline{i}}\right)=\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} n^{\underline{i+1}}+\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} in^{\underline{i}}=\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k\\i-1\end{Bmatrix} n^{\underline{i}}+\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k\\i\end{Bmatrix} in^{\underline{i}}=\sum \limits_{i=0}^{k+1} \left(\begin{Bmatrix}k\\i-1\end{Bmatrix}+i\begin{Bmatrix}k\\i\end{Bmatrix}\right) n^{\underline{i}}=\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k+1\\i\end{Bmatrix} n^{\underline{i}}$<br>$\therefore n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}$</p>
<h3 id="解决自然数幂和问题"><a href="#解决自然数幂和问题" class="headerlink" title="解决自然数幂和问题"></a>解决自然数幂和问题</h3><p>设$S_{n,k}=\sum\limits_{i=1}^ni^k$<br>$S_{n,k}=\sum\limits_{i=1}^ni^k=\sum\limits_{i=1}^n\sum \limits_{j=0}^{k} \begin{Bmatrix}k\\j\end{Bmatrix} i^{\underline{j}}$<br>考虑到$n$的范围太大，$k$的范围小，交换求和顺序<br>$=\sum \limits_{j=0}^{k} \begin{Bmatrix}k\\j\end{Bmatrix}\sum\limits_{i=1}^ni^{\underline{j}}=\sum \limits_{j=0}^{k} \begin{Bmatrix}k\\j\end{Bmatrix}j!\sum\limits_{i=1}^n\binom{i}{j}=\sum \limits_{j=0}^{k} \begin{Bmatrix}k\\j\end{Bmatrix}j!\binom{n+1}{j+1}$<br>斯特林数预处理，组合数和阶乘边算边推，所以效率就是$\Theta(k)$！<br><img src="https://img-blog.csdnimg.cn/20200818224238510.png#pic_center" alt="完美"><br>再次证明了我说的话：<strong>斯特林数行！快速幂不行！我爱斯特林数！</strong></p>
<h1 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h1><p>既然刚刚讲了第二类斯特林数，一定有第一类斯特林数吧？<br>有！接下来我们就来讲讲</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>将$n$个元素分成$m$个<strong>无标号</strong>的轮换$s(n,m)=\begin{bmatrix}n\\m\end{bmatrix}$<br>什么叫轮换？<br>就是把一堆数放在一个圈上，如果可以通过旋转使得圈上的每个位置上数都和另一个圈上的数是相等的，那么这两个圈等价（意思就是它们是同一个轮换）<br>比如，现在有三个轮换：<br><img src="https://img-blog.csdnimg.cn/2020021616135437.png" alt="在这里插入图片描述"><br>第一个轮换和第二个轮换是等价的，第一个和第三个轮换不是等价的<br>那么，什么叫<strong>无标号</strong>的轮换？<br>和<strong>无标号</strong>的集合类似，就是如果一<strong>堆</strong>轮换调换顺序后和另一<strong>堆</strong>轮换完全相同（所有对应的轮换等价），那么这两堆轮换就是等价的<br>比如，现在有两<strong>堆</strong>轮换：<br><img src="https://img-blog.csdnimg.cn/20200216163715754.png" alt="在这里插入图片描述"><br>第一堆轮换和第二堆轮换完全相同，是等价的<br>为了让大家更了解第一类斯特林数，我们举一个例子：$\begin{bmatrix}3\\2\end{bmatrix}=3$<br>三种方法如下：<br><img src="https://img-blog.csdnimg.cn/20200216163047456.png" alt="在这里插入图片描述"><br>第一类斯特林数还有另一种定义，就是$\prod \limits_{i=0}^{n-1}(x-i)$的$m$次项系数叫$\begin{bmatrix}n\\m\end{bmatrix}$<br>因为我太菜了，所以我并不知道第一类斯特林数是否有通项</p>
<h2 id="特殊值-1"><a href="#特殊值-1" class="headerlink" title="特殊值"></a>特殊值</h2><p>$\begin{bmatrix}n\\0\end{bmatrix}=0,\begin{bmatrix}n\\1\end{bmatrix}=1,\begin{bmatrix}n\\n-1\end{bmatrix}=\binom{n}{2},\begin{bmatrix}n\\n\end{bmatrix}=1$<br>自己想吧，太简单了，不证了</p>
<h2 id="快速幂？-1"><a href="#快速幂？-1" class="headerlink" title="快速幂？"></a>快速幂？</h2><p>和第二类斯特林数一样，第一类斯特林数也有假的快速幂，还有两个：<br>①$n^{\overline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i$<br>其中$n^{\overline{m}}$表示$n$的$i$次上升幂，即$n^{\overline{m}}=\prod \limits_{i=0}^{m-1}(n+i)$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i=\begin{bmatrix}1\\1\end{bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{\overline{k+1}}=(n+k)n^{\overline{k}}=n\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} n^i+k\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k\\i-1\end{bmatrix} n^i+\sum \limits_{i=0}^{k+1} k\begin{bmatrix}k\\i\end{bmatrix} n^i=\sum \limits_{i=0}^{k+1} \left(\begin{bmatrix}k\\i-1\end{bmatrix}+k\begin{bmatrix}k\\i\end{bmatrix}\right) n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k+1\\i\end{bmatrix} n^i$<br>$\therefore n^{\overline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i$<br>②$n^{\underline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i=\begin{bmatrix}1\\1\end{bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{\underline{k+1}}=(n-k)n^{\underline{k}}=n\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} (-1)^{k-i} n^i-k\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} (-1)^{k-i} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k\\i-1\end{bmatrix} (-1)^{k+1-i} n^i+\sum \limits_{i=0}^{k+1} k\begin{bmatrix}k\\i\end{bmatrix} (-1)^{k+1-i} n^i=\sum \limits_{i=0}^{k+1} \left(\begin{bmatrix}k\\i-1\end{bmatrix}+k\begin{bmatrix}k\\i\end{bmatrix}\right) (-1)^{k+1-i} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k+1\\i\end{bmatrix} (-1)^{k+1-i} n^i$<br>$\therefore n^{\underline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i$<br>通过第一个假快速幂，我们可以用分治NTT，求出第一类斯特林数，但是我太菜了，不会，等会了再来更博吧</p>
<h1 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h1><p>最后我们来讲讲斯特林反演<br>若$f(n)=\sum \limits_{i=1}^n\begin{Bmatrix}n\\i\end{Bmatrix}g(i)$，则$g(n)=\sum \limits_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}f(i)$<br>这个$-1$的次数怎么这么熟？<br>是的，这就是上面的第一类斯特林数的第二个假快速幂中$-1$次数<br>可以用斯特林反演说明第二类斯特林数的假快速幂和第一类斯特林数的第二个假快速幂是等价的<br>但是这玩意儿好像没啥用，至少我没用过<del>我就没做过几道斯特林数的题目</del>，但是我还是来证一下</p>
<h2 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h2><p>引理描述：$x^{\underline{n}}=(-1)^n(-x)^{\overline{n}},x^{\overline{n}}=(-1)^n(-x)^{\underline{n}}$<br>引理证明：$(-1)^n(-x)^{\overline{n}}=\sum\limits_{i=0}^{i=n-1} (-1)\times(-x+i)=\sum\limits_{i=0}^{i=n-1} (x-i)=x^{\underline{n}}$<br>$\therefore (-1)^n(-x)^{\underline{n}}=(-1)^{2n}x^{\overline{n}}=x^{\overline{n}}$</p>
<h2 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h2><p>引理描述：$\sum\limits_{i=m}^{n}(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}\begin{Bmatrix}i\\m\end{Bmatrix}=[n==m],\sum\limits_{i=m}^{n}(-1)^{n-i}\begin{Bmatrix}n\\i\end{Bmatrix}\begin{bmatrix}i\\m\end{bmatrix}=[n==m]$<br>引理证明：$n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} (-1)^i (-n)^{\overline{i}}=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} (-1)^i\sum \limits_{j=0}^{i} \begin{bmatrix}i\\j\end{bmatrix} (-n)^j=\sum \limits_{j=0}^{m}n^j \sum \limits_{i=j}^{m} \begin{Bmatrix}m\\i\end{Bmatrix}\begin{bmatrix}i\\j\end{bmatrix} (-1)^{i-j}$<br>$\therefore \sum \limits_{i=j}^{m} \begin{Bmatrix}m\\i\end{Bmatrix}\begin{bmatrix}i\\j\end{bmatrix} (-1)^{i-j}=[j==m]$<br>$\therefore \sum\limits_{i=m}^{n}(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}\begin{Bmatrix}i\\m\end{Bmatrix}=[n==m]$<br>同理可证，$\sum\limits_{i=m}^{n}(-1)^{n-i}\begin{Bmatrix}n\\i\end{Bmatrix}\begin{bmatrix}i\\m\end{bmatrix}=[n==m]$</p>
<h2 id="斯特林反演证明"><a href="#斯特林反演证明" class="headerlink" title="斯特林反演证明"></a>斯特林反演证明</h2><p>斯特林反演命题描述：若$f(n)=\sum \limits_{i=1}^n\begin{Bmatrix}n\\i\end{Bmatrix}g(i)$，则$g(n)=\sum \limits_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}f(i)$<br>证明：$g(n)=\sum\limits_{i=0}^n [i==n]g(i)=\sum\limits_{i=0}^{n}\sum\limits_{j=i}^{n}(-1)^{n-j}\begin{bmatrix}n\\j\end{bmatrix}\begin{Bmatrix}j\\i\end{Bmatrix}g(i)=\sum \limits_{j=1}^n(-1)^{n-j}\begin{bmatrix}n\\j\end{bmatrix}\sum \limits_{i=0}^j\begin{Bmatrix}j\\i\end{Bmatrix}g(i)=\sum \limits_{j=1}^n(-1)^{n-j}\begin{bmatrix}n\\j\end{bmatrix}f(j)$<br><img src="https://img-blog.csdnimg.cn/20200818224238510.png#pic_center" alt="完美"></p>
<h1 id="例题详解"><a href="#例题详解" class="headerlink" title="例题详解"></a>例题详解</h1><h2 id="第一类斯特林数-1"><a href="#第一类斯特林数-1" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><h3 id="FJOI2016-建筑师"><a href="#FJOI2016-建筑师" class="headerlink" title="[FJOI2016]建筑师"></a>[FJOI2016]建筑师</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><a href="https://www.luogu.com.cn/problem/P4609" target="_blank" rel="noopener">题目链接</a></p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>显然，这个建筑群一定会呈现这个样子：<br><img src="https://img-blog.csdnimg.cn/20200819200904457.png" alt="建筑"><br>其中，红色的代表一栋建筑，黑色的框代表一个建筑块（？？？），填充为红色的建筑高为$n$<br>去掉这个最高的建筑，剩下的建筑就一定被分成了$A+B-2$个块，其中左边有$A-1$个，右边有$B-1$个<br>这是因为每个建筑块有且仅有一个建筑能被看见（这是显然的吧……感性理解一下）<br>研究一下每一个建筑块会发现，对于一个一共有$k$个建筑的建筑块，当最高的建筑已经被选出时，这个建筑块一共有$(k-1)!$种方案<br>这让我们想到了单独一个环的排列也是$(k-1)!$种！<br>所以这岂不是第一类斯特林数？<br>最后，我们就会知道，答案是$\binom{A+B-2}{A-1}\begin{bmatrix}n-1\\A+B-2\end{bmatrix}$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a,b,MOD=<span class="number">1e9</span>+<span class="number">7</span>,s[<span class="number">50010</span>][<span class="number">210</span>],c[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>][<span class="number">0</span>]=c[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=min(i,<span class="number">200</span>);j++) s[i][j]=(<span class="number">1l</span>l*s[i<span class="number">-1</span>][j]*(i<span class="number">-1</span>)%MOD+s[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200</span>;i++)&#123;</span><br><span class="line">        c[i][<span class="number">0</span>]=c[i][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) c[i][j]=(c[i<span class="number">-1</span>][j]+c[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b,<span class="built_in">cout</span>&lt;&lt;<span class="number">1l</span>l*s[n<span class="number">-1</span>][a+b<span class="number">-2</span>]*c[a+b<span class="number">-2</span>][a<span class="number">-1</span>]%MOD&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="其他练习题"><a href="#其他练习题" class="headerlink" title="其他练习题"></a>其他练习题</h3><ol>
<li><a href="https://www.luogu.com.cn/problem/P5408" target="_blank" rel="noopener">洛谷P5408 第一类斯特林数·行</a></li>
<li><a href="codeforces.com/problemset/problem/960/G">CF960G Bandit Blues</a><h2 id="第二类斯特林数-1"><a href="#第二类斯特林数-1" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><h3 id="省选联考-2020-A-卷-组合数问题"><a href="#省选联考-2020-A-卷-组合数问题" class="headerlink" title="[省选联考 2020 A 卷] 组合数问题"></a>[省选联考 2020 A 卷] 组合数问题</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><a href="https://www.luogu.com.cn/problem/P6620" target="_blank" rel="noopener">题目链接</a><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4>$\sum\limits_{i=0}^ma_i\sum \limits_{k=0}^nx^k\binom{n}{k}k^i=\sum\limits_{i=0}^ma_i\sum \limits_{k=0}^nx^k\binom{n}{k}\sum\limits_{j=1}^ik^{\underline{j}}\begin{Bmatrix}i\\j\end{Bmatrix}=\sum\limits_{i=0}^ma_i\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}\sum \limits_{k=0}^nx^k\binom{n}{k}k^{\underline{j}}=\sum\limits_{i=0}^ma_i\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}\sum \limits_{k=0}^nx^k\binom{n}{k}j!\binom{k}{j}=\sum\limits_{i=0}^ma_i\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}j!\sum \limits_{k=0}^nx^k\binom{n}{k}\binom{k}{j}=\sum\limits_{i=0}^ma_i\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}j!\sum \limits_{k=0}^nx^k\binom{n}{j}\binom{n-j}{k-j}=\sum\limits_{i=0}^ma_i\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}j!\binom{n}{j}\sum \limits_{k=0}^{n-j}x^{k+j}\binom{n-j}{k}=\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}j!\binom{n}{j}x^j\sum \limits_{k=0}^{n-j}x^k\binom{n-j}{k}=\sum\limits_{j=1}^i\begin{Bmatrix}i\\j\end{Bmatrix}j!\binom{n}{j}x^j(x+1)^{n-j}$<br><img src="https://img-blog.csdnimg.cn/20200818224238510.png#pic_center" alt="完美"><br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,x,MOD,m,ans,a[<span class="number">1010</span>],sti[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">POW</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(<span class="number">1l</span>l*ans*a)%MOD;</span><br><span class="line">        a=(<span class="number">1l</span>l*a*a)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;x,&amp;MOD,&amp;m),sti[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++) sti[i][j]=((<span class="number">1l</span>l*sti[i<span class="number">-1</span>][j]*j)%MOD+sti[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD;</span><br><span class="line">    ans=(<span class="number">1l</span>l*a[<span class="number">0</span>]*POW((x+<span class="number">1</span>)%MOD,n))%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=(<span class="number">1l</span>l*POW(x%MOD,i)*POW((x+<span class="number">1</span>)%MOD,n-i))%MOD,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i<span class="number">-1</span>;j++) temp=(<span class="number">1l</span>l*temp*(n-j))%MOD;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=m;j++) (sum+=(<span class="number">1l</span>l*sti[j][i]*a[j])%MOD)%=MOD;</span><br><span class="line">        (ans+=(<span class="number">1l</span>l*sum*temp)%MOD)%=MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他练习题-1"><a href="#其他练习题-1" class="headerlink" title="其他练习题"></a>其他练习题</h3></li>
<li><a href="https://www.luogu.com.cn/problem/P4091" target="_blank" rel="noopener">[HEOI2016/TJOI2016]求和</a></li>
<li><a href="codeforces.com/problemset/problem/961/G">CF961G Partitions</a><h2 id="自然数幂和-1"><a href="#自然数幂和-1" class="headerlink" title="自然数幂和"></a>自然数幂和</h2><h3 id="CF932E-Team-Work"><a href="#CF932E-Team-Work" class="headerlink" title="CF932E Team Work"></a>CF932E Team Work</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><a href="https://www.luogu.com.cn/problem/CF932E" target="_blank" rel="noopener">题目链接（洛谷）</a><br><a href="codeforces.com/problemset/problem/932/E">题目链接（CF）</a><h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4>$\sum\limits_{i=1}^n\binom{n}{i}i^k=\sum\limits_{i=1}^n\binom{n}{i}\sum\limits_{j=0}^i\binom{i}{j}\begin{Bmatrix}k\\j\end{Bmatrix}j!=\sum\limits_{i=1}^n\frac{n!}{(n-i)!}\sum\limits_{j=0}^i\frac{\begin{Bmatrix}k\\j\end{Bmatrix}}{(i-j)!}=\sum\limits_{j=1}^{min(n,k)}\begin{Bmatrix}k\\j\end{Bmatrix}\sum\limits_{i=j}^n\frac{n!}{(n-i)!(i-j)!}=\sum\limits_{j=1}^{min(n,k)}\begin{Bmatrix}k\\j\end{Bmatrix}\sum\limits_{i=j}^n\frac{n!}{(n-j)!}\frac{(n-j)!}{(n-i)!(i-j)!}=\sum\limits_{j=1}^{min(n,k)}\begin{Bmatrix}k\\j\end{Bmatrix}\frac{n!}{(n-j)!}\sum\limits_{i=j}^n\binom{n-j}{i-j}=\sum\limits_{j=1}^{min(n,k)}\begin{Bmatrix}k\\j\end{Bmatrix}\frac{n!}{(n-j)!}2^{n-j}$<br>斯特林数预处理，$2^{n-j}$用快速幂，$\frac{n!}{(n-j)!}$边推边算，效率$\Theta(k)$<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,t,mod=<span class="number">1e9</span>+<span class="number">7</span>,ans,sti[<span class="number">5010</span>][<span class="number">5010</span>],c[<span class="number">300010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">POW</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=<span class="number">1l</span>l*ans*a%mod;</span><br><span class="line">        a=<span class="number">1l</span>l*a*a%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k,t=min(n,k),sti[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>,c[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=k;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=min(n,i);j++) sti[i][j]=(<span class="number">1l</span>l*sti[i<span class="number">-1</span>][j]*j%mod+sti[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) c[i]=<span class="number">1l</span>l*c[i<span class="number">-1</span>]*(n-i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++) ans=(ans+<span class="number">1l</span>l*c[i<span class="number">-1</span>]%mod*sti[k][i]%mod*POW(<span class="number">2</span>,n-i)%mod)%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于这道题目，有一道升级版的题目叫做<code>原题的价值</code>，需要使用NTT（当然，这道题你也可以使用NTT三模数的方式书写，但是太复杂啦！），可是我并不知道哪里可以提交这道题目（我们学校的OJ上有）<br>另外说一句，自然数幂和也可以用第一类斯特林数$\Theta\left(k^2\right)$解决，只是比较复杂，这里就不讲了<h3 id="相关练习题"><a href="#相关练习题" class="headerlink" title="相关练习题"></a>相关练习题</h3></li>
<li><a href="https://www.luogu.com.cn/problem/P4827" target="_blank" rel="noopener">[国家集训队] Crash 的文明世界</a></li>
<li><a href="codeforces.com/problemset/problem/1097/G">CF1097G Vladislav and a Great Legend</a></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流算法总结1--网络流最大流概述</title>
    <url>/2020/11/11/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%931-%E7%BD%91%E7%BB%9C%E6%B5%81%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="网络流中的一些概念"><a href="#网络流中的一些概念" class="headerlink" title="网络流中的一些概念"></a>网络流中的一些概念</h1><a id="more"></a>
<ol>
<li>边（弧）：在网络流问题中基本上所有的边都为有向边，所以在不加说明的情况下，文中出现的所有边都为有向边，有向边也成为弧，记为有序对$(a,b)$</li>
<li>图：一堆点加上一堆边就是一张图，也就是说，图是边集加上点集，用$G=\langle V,E\rangle$</li>
<li>路径：图中的一条路径就是一串相连的点，一条路径$v_1,v_2,\cdots\cdots,v_n$满足$\forall i\in [1,n],v_i\in V$且$\forall i\in [1,n),(v_i,v_{i+1})\in E$或$(v_{i+1},v_i)\in E$</li>
<li>前向弧：一条路径$v_1,v_2,\cdots\cdots,v_n$中，如果$(v_i,v_{i+1})\in E$，则称$(v_i,v_{i+1})$为前向弧</li>
<li>后向弧：一条路径$v_1,v_2,\cdots\cdots,v_n$中，如果$(v_{i+1},v_i)\in E$，则称$(v_i,v_{i+1})$为后向弧</li>
<li>割：一个图中如果存在一个边集$E’$，使得删除$E’$中的边后，原图分为两个集合，且这两个集合没有任何连边，那么$E’$就称为图$G$的一个割</li>
<li>边的容量：一条边所能承受的流量上界称为容量，$(u,v)$的容量用$C(u,v)$表示，类似于水管的截面面积，水管的截面面积就是它所能承受的水流流量上界</li>
<li>割的容量：把图$G$分为两个集合$S$和$T$的割中的所有边的流量之和记为$C(S,T)$，即$C(S,T)=\sum\limits_{u\in S,v\in T,(u,v)\in E} C(u,v)$</li>
<li>流量：类似于容量，用$F(u,v)$表示一条边的流量，$F(S,T)$表示一个割的流量</li>
<li>增广路： 一条路径，满足前向弧的流量<strong>严格小于</strong>容量，后向弧的流量大于$0$</li>
<li>可行流：从源点出发，到汇点结束，所有边的流量未超过容量且除源点和汇点外，流入任意一点的流量等于流出这一点的流量（如果你学过高中物理中的电学，你可以把这个理解为基尔霍夫第一定律）</li>
<li>最大流：可行流中流量最大的流</li>
<li>最小割：把源点和汇点分成两个集合，容量最小的割</li>
<li>残余网络：对于任意的流$f$，建立新图$G_f$满足连边方式相同，边的容量等于原边的容量减去流量（当然，如果新的边的容量为$0$，去掉这条边也无所谓）<h1 id="性质-amp-定理证明"><a href="#性质-amp-定理证明" class="headerlink" title="性质&amp;定理证明"></a>性质&amp;定理证明</h1><h2 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h2>可行流的流量等于它的一个割的流量<br>证明：假设割将源点（$V_S$）和汇点（$V_T$）分为两个集合$S$和$T$，可行流流量为$F$<br>$\therefore$当$T=\{V_T\}$时，$F(S,T)=\sum\limits_{(x,V_T)\in E} F(x,V_T)=F$<br>$\therefore$假设当$T\subsetneq T’$时成立<br>$\therefore$当$T=T’$时，设$V_P\in T$<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\therefore~F(S,T)=F(S\cup\{V_P\},T\setminus {V_P})-\sum\limits_{(V_P,x)\in E,x\in T} F(V_P,x)+\sum\limits_{(V_P,x)\in E,x\in S} F(V_P,x)=F(S\cup\{V_P\},T\setminus {V_P})=F$<h2 id="推论1"><a href="#推论1" class="headerlink" title="推论1"></a>推论1</h2>可行流的流量小于等于它的一个割的容量<br>证明：由性质1知，可行流的流量等于它的一个割的流量，小于等于这个割的容量<h2 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h2>若残余网络中仍有增广路，那么可行流$F$不是最大流<br>证明：$\because$增广路的前向弧可以增加流量，后向弧可以减少流量<br>$\therefore F$可以继续增大<br>$\therefore$可行流$F$不是最大流<h2 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h2>若残余网络中无增广路，则存在一个割，使得割的容量等于可行流的流量<br>证明：$\because$残余网络中无增广路<br>$\therefore$原图中的每一条从源点到汇点的路径，都一定有一个前向弧的流量为容量或有一个后向弧的流量为$0$<br>$\therefore$设集合$S$为从源点出发，不经过流量为容量的前向弧和流量为$0$的后向弧所能到达的所有点的集合，$T=V\setminus S$<br>$\therefore$$F=F(S,T)=\sum\limits_{u\in S,v\in T,(u,v)\in E} F(u,v)=$前向弧总流量-后向弧总流量$=$前向弧总容量$-0=$前向弧总容量$=C(S,T)$<h2 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h2>对于一个可行流，<strong>若</strong>存在一个它的割，使得割的容量等于可行流的流量，则这个可行流为最大流，且这个割为最小割<br>证明：设可行流的流量为$F$，割的容量为$C$<br>假设$C$不是最小割的容量<br>$\therefore$存在一个割的流量为$C_0$，且$C_0&lt;C$<br>又$\because F\leqslant C_0$<br>$\therefore C\leqslant C_0$，矛盾！<br>$\therefore$这个割为最小割<br>$\therefore F$到达了流量的上界<br>$\therefore$这个可行流的最大流</li>
</ol>
<hr>
<p>特别注意，这个性质并不代表最大流等于最小割（虽然这是对的），因为我们并没有说明这样的割一定存在</p>
<h2 id="最大流最小割定理"><a href="#最大流最小割定理" class="headerlink" title="最大流最小割定理"></a>最大流最小割定理</h2><p>最大流（的流量）等于最小割（的容量）<br>证明：取图$G$的最大流$F$<br>$\therefore$根据性质2的逆否命题可知：残余网络中无增广路<br>$\therefore$根据性质3可知：存在一个割，使得割的容量等于最大流的流量<br>$\therefore$根据性质4可知：这个割为最小割<br>$\therefore$最大流等于最小割</p>
<hr>
<p>这样，我们就完成了网络流中<strong>最重要！最重要！最重要！</strong> 的定理：最大流最小割定理，请大家一定记住这个定理，因为有时在解题过程中，我们需要使用最小割的方式来思考问题，最终通过最大流的算法解决<br>如果你难以理解我写的证明，那么你只要把这个定理的表述背下来即可（惊奇的发现表述和名称一样长耶！）</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6753&amp;DTOJ4963 2020 Multi-University Training Contest 1 cookies（看星）</title>
    <url>/2020/11/11/HDU6753-DTOJ4963-2020-Multi-University-Training-Contest-1-cookies%EF%BC%88%E7%9C%8B%E6%98%9F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6753" target="_blank" rel="noopener">原题</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>Elsa’s elder brother Eric has got $n$ cookies in his icebox and each cookie has a special number written on it. Let’s denote the number written on the $i^{th}$ cookie by $f_i$. $f_i$ is defined as follows<br><img src="https://img-blog.csdnimg.cn/2020081114373881.png" alt="f_i is defined as this"><br>Here, $divmed(x)$ states the median value of divisors of $x$. Let $x$ has $k$ divisors, then $divmed(x)$ is $\left\lceil\frac{k}{2}\right\rceil^{th}$ smallest divisor. For example, $divmed(100)=10$, $divmed(10)=2$, $divmed(1)=1$.<br>One day, Eric opened the icebox and recognized that some of his cookies are missing. His sister Elsa had eaten some of them.<br>On the first day, she ate cookies that have multiples of $p_1$ as indexes and then, re-indexed them starting from $1$ according to their original order. In the same way, she ate cookies with multiples of $p_i$ as indexes on the $i^{th}$ day and re-indexed them. If there were less than $p_i$ cookies left, she ate none of them. Elsa continued to do so for m days.</p>
<p>As Elsa is keen on math and Eric didn’t want to blame his sister, Eric asked her to find out the number written on the $k^{th}$ of remaining cookies.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of the input contains an integer$T(1\leqslant T\leqslant 60)$, denoting the number of test cases. The first line of each test case contains $3$ positive integers $n(1\leqslant n\leqslant 10^{10}), m(1\leqslant m\leqslant 10^5)$and$k(1\leqslant k\leqslant 10^{10})$. The next line contains m integers$p_1,p_2,\cdots \cdots,p_m (1\leqslant p_i\leqslant 10^{10})$.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output one line containing the answer. If the kth cookie doesn’t exist, then output $-1$ in a single line.</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">25 5 9</span><br><span class="line">3 5 8 12 10</span><br><span class="line">25 5 2</span><br><span class="line">3 5 8 12 10</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>在OI界，有一句名言：“暴力出奇迹，打表出省一”<br>如果你认为这句话不可能，那么你就错了<br>你可以点开HDU上的statistic，看看大家的代码长度（已按代码长度从小到大排序）：<br><img src="https://img-blog.csdnimg.cn/20200811145337691.png" alt="HDU中的statistic">也就是说，最短的代码也有22.5K！！！<br>这不是打表是什么？<br>接下来，我们就来看看这道打表题<br>显然，我们可以用二分或计算，找到第$k$个饼干初始的位置$K$，那么问题就在于求$\sum\limits_{i=1}^K divmed(i)$的值了<br>显然，这个东西计算效率很低，因为你肯定需要枚举$1\sim \sqrt{K}$之间的所有数，然后计算，效率很低（事实证明很低，我也算不出来）<br>所以我们可以考虑分段打表！<br>取$2500000$为一段，计算$\sum\limits_{i=t+1}^{t+2500000}divmed(i)$（$2500000|t$），然后把求出来的$4000$个值复制到主程序中，就可以了<br>计算时用类似于挨氏筛质数的方法就可以了<br>打表代码如下（写题解的时候打的，可能有问题，自己改一下）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> D=<span class="number">2500000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l,r,a[<span class="number">4010</span>],d[D+<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const long long a[4010]=&#123;0,"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=<span class="number">4000</span>;++t)&#123;</span><br><span class="line">        a[t]=a[t<span class="number">-1</span>],l=(t<span class="number">-1</span>)*D+<span class="number">1</span>,r=t*D;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*i&gt;r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> L=((l<span class="number">-1</span>)/i)*i+<span class="number">1</span>,j=(r/i)*i;i*i&lt;=j&amp;&amp;L&lt;=j;j-=i) d[j-l]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=l;i&lt;=r;i++) a[t]+=d[i-l];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld,"</span>,a[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&#125;;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我自己运行这个程序花了$24$分钟<br>然后剩下的内容就类似于分块了，如果有剩余的，暴力计算即可<br>最后还有一个要注意的点，就是为了节省时间，对剩余的部分，如果长度不到$1250000$，就加上正着算的结果，如果超过$1250000$，就减去倒着算的结果（这个优化在HDU上可加可不加，但是在DTOJ上不加就会挂，就像我一样，调了一个中午，连饭都没吃……<del>abcde真是太毒瘤啦！</del>）<br>完整代码如下（打表的内容自行填充）：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> D=<span class="number">2500000</span>,a[]=&#123;<span class="number">0</span>,<span class="number">876804130</span>,<span class="number">2440016214</span>,...,<span class="number">190808468780767</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,k,ans,flag,l,r,p[<span class="number">100010</span>],d[D+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;<span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    x=<span class="number">0</span>;<span class="keyword">int</span> f=<span class="number">0</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)  &#123;f|=(ch==<span class="string">'-'</span>);ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">    x=f?-x:x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    read(T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        read(n),read(m),read(k),flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) read(p[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=m;i;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i]==<span class="number">1</span>)&#123;k=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;n)&#123;flag=<span class="number">1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> k+=(k<span class="number">-1</span>)/(p[i]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag||k&gt;n)&#123;<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        ans=a[k/D];</span><br><span class="line">        <span class="keyword">if</span>(k%D)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%D&lt;=D/<span class="number">2</span>)&#123;</span><br><span class="line">            	l=(k/D)*D+<span class="number">1</span>,r=k;</span><br><span class="line">            	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)&#123;</span><br><span class="line">            		<span class="keyword">if</span>(i*i&gt;r) <span class="keyword">break</span>;</span><br><span class="line">            		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> L=((l<span class="number">-1</span>)/i)*i+<span class="number">1</span>,j=(r/i)*i;i*i&lt;=j&amp;&amp;L&lt;=j;j-=i) d[j-l]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=l;i&lt;=r;i++) ans+=d[i-l];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            	ans=a[k/D+<span class="number">1</span>],l=k+<span class="number">1</span>,r=(k/D+<span class="number">1</span>)*D;</span><br><span class="line">            	<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="number">100000</span>;i++)&#123;</span><br><span class="line">            		<span class="keyword">if</span>(i*i&gt;r) <span class="keyword">break</span>;</span><br><span class="line">            		<span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> L=((l<span class="number">-1</span>)/i)*i+<span class="number">1</span>,j=(r/i)*i;i*i&lt;=j&amp;&amp;L&lt;=j;j-=i) d[j-l]=i;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=l;i&lt;=r;i++) ans-=d[i-l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>打表</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分之重链剖分详解</title>
    <url>/2020/07/31/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E4%B9%8B%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p>在学习重链剖分前，首先要明白以下几个概念：</p>
<ol>
<li><del>中二</del>重儿子：就是一个节点的儿子中最“重”的那个，“重”表示的是子树大小最大，如果都一样大，就随便选一个就好了（用$son$数组存储）</li>
<li><del>亲</del>轻儿子：除了重儿子外其他的儿子</li>
<li>重边：重儿子和父亲之间的边</li>
<li>轻边：轻儿子和父亲之间的边</li>
<li>重链：重边连在一起形成的链</li>
<li>轻链：轻边连在一起形成的链（貌似没啥用）</li>
<li>重链顶点：一条重链中，深度最小的点（用$top$数组记录）<a id="more"></a>
</li>
</ol>
<p>为了方便大家理解，这里我画了一张图，来表示重链剖分后的结果：<br><img src="https://img-blog.csdnimg.cn/20200726185841813.png" alt="重链剖分后的结果"><br>其中，红色的线表示重边，连在一起，形成$3$条重链；黑色的线表示轻边，连在一起，形成$3$条轻链<br>这样，大家对这些概念应该都了解了吧？</p>
<h1 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h1><p>接下来，我们来介绍如何进行重链剖分<br>首先，我们进行第一遍dfs，求出子树的大小（$siz$），重儿子（$son$），父亲节点（$fa$）和每个点的深度（$dep$）<br>$size$、$fa$和$dep$的求法就不用说了吧……<br>我们来讲讲$son$的求法<br>首先，设一个变量$maxson$，初值为$-1$，记录最大的子树大小<br>接着，对于枚举的每棵子树，假设当前枚举的子树的根为$v$，判断$maxson$和$siz[v]$的大小<br>如果$siz[v]&gt;maxson$，那么$son[u]=v$<br>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Fa,<span class="keyword">int</span> Dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=Dep,fa[x]=Fa,siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i!=<span class="number">-1</span>;i=e[i].nxt) <span class="keyword">if</span>(e[i].v!=Fa)&#123;</span><br><span class="line">        siz[x]+=dfs1(e[i].v,x,Dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(siz[e[i].v]&gt;maxson) maxson=siz[e[i].v],son[x]=e[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> siz[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着，我们来讲一讲第二个dfs，这个dfs要求出dfs序（$dfn$）和重链顶点（$top$）<br>为了方便，我们首先先遍历重儿子，再遍历其他轻儿子，重儿子的重链顶点和该节点的重链顶点相同，轻儿子的重链顶点是自己<br>至于方便在什么地方，后面再说<br>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++cnt,top[x]=Top;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i!=<span class="number">-1</span>;i=e[i].nxt) <span class="keyword">if</span>(!dfn[e[i].v]) dfs2(e[i].v,e[i].v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，我们就完成了重链剖分的全过程</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>那么，剖分完后又有什么好处呢？</p>
<h2 id="求最近公共祖先"><a href="#求最近公共祖先" class="headerlink" title="求最近公共祖先"></a>求最近公共祖先</h2><p><del>众所周知，</del>有一种求最近公共祖先（LCA）的算法，使用的是倍增，这个算法预处理是$\Theta(nlogn)$的，单次询问是$\Theta(logn)$的<br>有比这个更快的算法吗？有！用重链剖分解决！<br>等等，这和重链剖分有什么关系呢？最近公共祖先和这两个点所在的重链也不一定一样啊，这怎么做呢？<br>别急，马上大家就会理解了<br>我们以下面这张图为例，求两个蓝色的点的最近公共祖先<br><img src="https://img-blog.csdnimg.cn/20200728110238209.png" alt="最近公共祖先"><br>模仿倍增法求LCA，我们就很容易理解重链剖分求LCA的方法了<br>我们只需要选择深度较深的点，不断向上跳到重链的顶端即可<br>首先，蓝色的点调到重链顶端（绿点），然后再向上跳一条边（黄点），这样就转换到了另外一条重链上<br>最后，当两个点在同一条重链上时，深度较小的那个点就是他们的最近公共祖先了<br>那么，重链剖分求LCA时，预处理为$\Theta(n)$，单次询问为$\Theta(logn)$<br>完整代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,nxt;</span><br><span class="line">&#125;e[<span class="number">2000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,root,tot,cnt,head[<span class="number">2000010</span>],dep[<span class="number">2000010</span>],fa[<span class="number">2000010</span>],son[<span class="number">2000010</span>],siz[<span class="number">2000010</span>],top[<span class="number">2000010</span>],dfn[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[x],head[x]=tot,e[tot].u=x,e[tot].v=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Fa,<span class="keyword">int</span> Dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=Dep,fa[x]=Fa,siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i!=<span class="number">-1</span>;i=e[i].nxt) <span class="keyword">if</span>(e[i].v!=Fa)&#123;</span><br><span class="line">        siz[x]+=dfs1(e[i].v,x,Dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(siz[e[i].v]&gt;maxson) maxson=siz[e[i].v],son[x]=e[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++cnt,top[x]=Top;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i!=<span class="number">-1</span>;i=e[i].nxt) <span class="keyword">if</span>(!dfn[e[i].v]) dfs2(e[i].v,e[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) <span class="keyword">return</span> y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,add(x,y),add(y,x);</span><br><span class="line">    dfs1(root,<span class="number">0</span>,<span class="number">1</span>),dfs2(root,root);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;LCA(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对树上的一条链进行修改和查询"><a href="#对树上的一条链进行修改和查询" class="headerlink" title="对树上的一条链进行修改和查询"></a>对树上的一条链进行修改和查询</h2><p>重链剖分还有什么作用呢？<br>它可以对树上的任意一条链进行修改<br>以下图为例，我们假设每个点有一个点权，我们要让两个蓝点之间的链上的每个点的权$+1$（包括两个蓝点），怎么操作呢？<br><img src="https://img-blog.csdnimg.cn/20200728111441342.png" alt="链修改操作"><br>首先，对于这种相连的东西一起修改的题目，我们很容易就会想到线段树<br>在树上建线段树，用的一定就是dfs序了<br>还记得我们前面遍历每个节点的子节点时，是先遍历它的重儿子吗？<br>当时我说这是为了方便<br>是的，就是在建线段树和计算时更方便了！<br>因为所有重链上的点的dfs序一定是连续的，这样，一条重链上的点的值修改只需要进行简单的线段树上区间修改即可<br>所以我们考虑把链划分成许多个重链相连（如下图）<br><img src="https://img-blog.csdnimg.cn/20200728111401768.png" alt="重链剖分"><br>那么，我们就可以分别修改每一段的值，查询时也一样，分别查询每一段的值，然后再加在一起即可<br>对于这个链的划分操作，和LCA的求法类似，只需要不断地跳到重链顶点的父亲节点，就可以了<br><a href="https://www.luogu.com.cn/problem/P3384" target="_blank" rel="noopener">模板题</a>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v,nxt;</span><br><span class="line">&#125;e[<span class="number">2000010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,siz,add;</span><br><span class="line">&#125;t[<span class="number">2000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,root,MOD,tot,cnt,a[<span class="number">2000010</span>],b[<span class="number">2000010</span>],head[<span class="number">2000010</span>],dep[<span class="number">2000010</span>],fa[<span class="number">2000010</span>],son[<span class="number">2000010</span>],siz[<span class="number">2000010</span>],top[<span class="number">2000010</span>],dfn[<span class="number">2000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[x],head[x]=tot,e[tot].u=x,e[tot].v=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Fa,<span class="keyword">int</span> Dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=Dep,fa[x]=Fa,siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxson=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i!=<span class="number">-1</span>;i=e[i].nxt) <span class="keyword">if</span>(e[i].v!=Fa)&#123;</span><br><span class="line">        siz[x]+=dfs1(e[i].v,x,Dep+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(siz[e[i].v]&gt;maxson) maxson=siz[e[i].v],son[x]=e[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++cnt,a[cnt]=b[x],top[x]=Top;</span><br><span class="line">    <span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i!=<span class="number">-1</span>;i=e[i].nxt) <span class="keyword">if</span>(!dfn[e[i].v]) dfs2(e[i].v,e[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[p].l=l,t[p].r=r,t[p].siz=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[p].sum=a[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add)&#123;</span><br><span class="line">    	t[p*<span class="number">2</span>].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>].siz*t[p].add)%MOD;</span><br><span class="line">    	t[p*<span class="number">2</span>+<span class="number">1</span>].sum=(t[p*<span class="number">2</span>+<span class="number">1</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].siz*t[p].add)%MOD;</span><br><span class="line">    	t[p*<span class="number">2</span>].add=(t[p*<span class="number">2</span>].add+t[p].add)%MOD;</span><br><span class="line">    	t[p*<span class="number">2</span>+<span class="number">1</span>].add=(t[p*<span class="number">2</span>+<span class="number">1</span>].add+t[p].add)%MOD;</span><br><span class="line">    	t[p].add=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r)&#123;t[p].sum+=t[p].siz*d,t[p].add+=d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) change(p*<span class="number">2</span>,l,r,d);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,d);</span><br><span class="line">    t[p].sum=(t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=t[p].l&amp;&amp;t[p].r&lt;=r) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(t[p].l+t[p].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=(ans+ask(p*<span class="number">2</span>,l,r))%MOD;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)  ans=(ans+ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r))%MOD;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        change(<span class="number">1</span>,dfn[top[x]],dfn[x],d);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    change(<span class="number">1</span>,dfn[x],dfn[y],d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]]) swap(x,y);</span><br><span class="line">        ans=(ans+ask(<span class="number">1</span>,dfn[top[x]],dfn[x]))%MOD;</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y]) swap(x,y);</span><br><span class="line">    ans=(ans+ask(<span class="number">1</span>,dfn[x],dfn[y]))%MOD;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;root&gt;&gt;MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;b[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n<span class="number">-1</span>;i++) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,add(x,y),add(y,x);</span><br><span class="line">    dfs1(root,<span class="number">0</span>,<span class="number">1</span>),dfs2(root,root),build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="keyword">int</span> op,x,y,z;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;z,z%=MOD,modify(x,y,z);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,query(x,y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;z,change(<span class="number">1</span>,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>,z%MOD);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>) <span class="built_in">cin</span>&gt;&gt;x,<span class="built_in">cout</span>&lt;&lt;ask(<span class="number">1</span>,dfn[x],dfn[x]+siz[x]<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="相关练习题"><a href="#相关练习题" class="headerlink" title="相关练习题"></a>相关练习题</h1><ol>
<li><a href="https://www.luogu.com.cn/problem/P4315" target="_blank" rel="noopener">洛谷P4315 月下“毛景树”</a></li>
<li><a href="https://www.luogu.com.cn/problem/P2146" target="_blank" rel="noopener">洛谷P2146 [NOI2015]软件包管理器</a> <a href="https://blog.csdn.net/weixin_43849488/article/details/105161019" target="_blank" rel="noopener">题解</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4949" target="_blank" rel="noopener">洛谷P4949 最短距离</a></li>
<li>其他需要用到LCA的题目，都可以使用重链剖分求，这里就不列举了</li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>树剖</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>编程中的较高端的数论知识总结2--狄利克雷卷积</title>
    <url>/2020/07/31/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BE%83%E9%AB%98%E7%AB%AF%E7%9A%84%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932-%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/</url>
    <content><![CDATA[<p><strong>注意！！！请务必先阅读完（或学会）<a href="https://jrjacky.github.io/2020/07/31/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BE%83%E9%AB%98%E7%AB%AF%E7%9A%84%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#more">莫比乌斯反演</a>，文章中默认大家都已经看过了</strong><br><a id="more"></a></p>
<h1 id="一些新的表示"><a href="#一些新的表示" class="headerlink" title="一些新的表示"></a>一些新的表示</h1><p>在这篇博客中，为了节省篇幅，也方便读者们学习，我会使用以下的这样简便的写法，当然这在数论中也是允许的，只是个人认为不是很规范，最好还是写清楚：</p>
<ol>
<li>我们用$f$来代替数论函数$f(n)$，但是在$n$说表示一个具体的数时，还是会写成$f(n)$的形式</li>
<li>$f+g$表示两个数论函数相加，减号也采用相同的写法，$f+g$的具体定义是：$(f+g)(n)=f(n)+g(n)$，减号相同</li>
<li>$xf$表示数论函数乘上一个倍数，具体是：$(xf)(n)=x\cdot f(n)$<h1 id="狄利克雷卷积是个啥"><a href="#狄利克雷卷积是个啥" class="headerlink" title="狄利克雷卷积是个啥"></a>狄利克雷卷积是个啥</h1><blockquote>
<p>是数论函数的重要运算之一<br>设$f(n)$、$g(n)$是两个数论函数，它们的狄利克雷乘积也是一个数论函数，简记为$h(n)=f(n)*g(n)$<br>——百度百科，有删改</p>
</blockquote>
</li>
</ol>
<p>哦，看了这个定义，好像没看出什么名堂来……<br>其实还是有的：</p>
<ol>
<li>两个数论函数的狄利克雷卷积也是一个数论函数<del>额，好像是废话</del></li>
<li>狄利克雷卷积在数论中就相当于乘法，因为它的表示符号就是乘号（星号，不能写成点乘或者叉乘的符号）</li>
</ol>
<p>所以，到底怎么计算呢？<br>是这样的：$h(n)=\sum\limits_{d|n}f(d)g\left(\frac{n}{d}\right)$<br>有时，我们也会把它写成：$h(n)=\sum\limits_{d_1d_2=n}f(d_1)g(d_2)$<br>显然，这两个东西是等价的……<br>除了把它简写成$h(n)=f(n)<em>g(n)$，我们当然也可以像前面一样，把它写成：$h=f</em>g$<br>在后文中，我就采用这种最简单的写法</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>既然是个运算，肯定得有些性质吧，我们先来看看最基本的三个性质中，它满足什么</p>
<ol>
<li>交换律：$f<em>g=g</em>f$，满足<br>证明：$(f<em>g)(n)=\sum\limits_{d_1d_2=n}f(d_1)g(d_2)=\sum\limits_{d_2d_1=n}f(d_2)g(d_1)=(g</em>f)(n)$</li>
<li>结合律：$f<em>(g</em>h)=(f<em>g)</em>h$，满足<br>证明：$(f<em>(g</em>h))(n)=\sum\limits_{d_1d_2=n}f(d_1)(g<em>h)(d_2)=\sum\limits_{d_1d_2=n}f(d_1)\sum\limits_{d_3d_4=d_2}g(d_3)h(d_4)=\sum\limits_{d_1d_2d_3=n}f(d_1)g(d_2)h(d_3)=\sum\limits_{d_2d_3d_1=n}f(d_2)g(d_3)h(d_1)=(h</em>(f<em>g))(n)=((f</em>g)*h)(n)$</li>
<li>分配律：$f<em>(g+h)=f</em>g+f<em>h$，满足<br>证明：$(f</em>(g+h))(n)=\sum\limits_{d_1d_2=n}f(d_1)(g(d_2)+h(d_2))=\sum\limits_{d_1d_2=n}f(d_1)g(d_2)+\sum\limits_{d_1d_2=n}f(d_1)h(d_2)=(f<em>g)(n)+(f</em>h)(n)=(f<em>g+f</em>h)(n)$</li>
</ol>
<p>好的，这三个基本性质好像都满足，看起来好像真的很像乘法耶！<br>还有什么性质吗？有！</p>
<ol>
<li>$(xf)<em>g=x(f</em>g)$<br>证明：$((xf)<em>g)=\sum\limits_{d_1d_2=n}xf(d_1)g(d_2)=x\sum\limits_{d_1d_2=n}f(d_1)g(d_2)=(x(f</em>g))(n)$<br>注意，这并不能用上面的分配律来证明，因为这是数字乘以函数，而不是函数乘以函数</li>
<li>$\epsilon<em>f=f$（$\epsilon$就是之前说过的单位元，即$\epsilon(n)=[n==1]$）<br>证明：$(\epsilon</em>f)(n)=\sum\limits_{d_1d_2=n}f(d_1)\epsilon(d_2)=\sum\limits_{d_1d_2=n}f(d_1)[d_2==1]=f(n)$</li>
<li>我们定义数论函数$f$的逆元指的是满足$f<em>g=\epsilon$的数论函数$g$，下面我们求证：对于任意数论函数$f$，它都有逆元$g$<br>证明：$(f</em>g)(n)=f(1)g(n)+\sum\limits_{d|n,d\neq1}f(d)g\left(\frac{n}{d}\right)=[n==1]$<br>$\therefore f(1)g(n)=[n==1]-\sum\limits_{d|n,d\neq1}f(d)g\left(\frac{n}{d}\right)$<br>$\therefore g(n)=\frac{1}{f(1)}\left([n==1]-\sum\limits_{d|n,d\neq1}f(d)g\left(\frac{n}{d}\right)\right)$<br>$\therefore$对于任意数论函数$f$，它都有逆元$g$，且$g(n)=\frac{1}{f(1)}\left([n==1]-\sum\limits_{d|n,d\neq1}f(d)g\left(\frac{n}{d}\right)\right)$</li>
<li>两个积性函数的狄利克雷卷积也是积性函数<br>证明：设$f,g$为积性函数，$gcd(m,n)=1$<br>$\therefore (f<em>g)(mn)=\sum\limits_{d|mn}f(d)g\left(\frac{mn}{d}\right)=\sum\limits_{d_1|m,d_2|n}f(d_1d_2)g\left(\frac{mn}{d_1d_2}\right)=\sum\limits_{d_1|m,d_2|n}f(d_1)f(d_2)g\left(\frac{m}{d_1}\right)g\left(\frac{n}{d_2}\right)=\left(\sum\limits_{d_1|m}f(d_1)g\left(\frac{m}{d_1}\right)\right)\left(\sum\limits_{d_2|n}f(d_2)g\left(\frac{n}{d_2}\right)\right)=(f</em>g)(m)(f*g)(n)$<h1 id="再谈莫比乌斯反演"><a href="#再谈莫比乌斯反演" class="headerlink" title="再谈莫比乌斯反演"></a>再谈莫比乌斯反演</h1>等等，莫比乌斯反演不是之前讲过了吗？为啥这里还有？<br>因为学了狄利克雷卷积后，我们对莫比乌斯反演又有了新的认识<br>先来回顾一下莫比乌斯反演的式子：$f(n)=\sum \limits_{d|n}\mu(d)F\left(\frac{n}{d}\right)$<br>看出什么名堂来了吗？<br>如果还没有的话，我再把狄利克雷卷积的式子写一下：$(f<em>g)(n)=\sum\limits_{d|n}f(d)g\left(\frac{n}{d}\right)$<br>看出来了吧！<br>把狄利克雷卷积的式子中的$f$替换成$\mu$，把$g$替换成$F$，你就会（惊奇？）地发现：$f=\mu</em>F$！！！<br>用同样的方法，我们来看看$F$的定义：$F(n)=\sum \limits_{d|n}f(d)$<br>你又会（惊奇？）地发现：$F=f<em>I$（还记得$I$函数吗？$I(n)=1$）<br>所以，我们会发现：$(\epsilon</em>f)(n)=f(n)=(\mu<em>F)(n)=(\mu</em>I<em>f)(n)$<br>所以$\mu</em>I=\epsilon$！<br>我们找到了$\mu$函数的第二种定义方式——$I$函数的逆元<br>现在，我们来证明$\mu$是$I$函数的逆元<br>证明：$\mu(n)=[n==1]-\sum\limits_{d|n}\mu(d)+\mu(n)=[n==1]-\sum\limits_{d|n,d\neq n}\mu(d)=[n==1]-\sum\limits_{d|n,d\neq1}\mu\left(\frac{n}{d}\right)=\frac{1}{I(1)}\left([n==1]-\sum\limits_{d|n,d\neq1}I(d)\mu\left(\frac{n}{d}\right)\right)$<br>$\therefore \mu$是$I$函数的逆元<br>其中，第一步用到了莫比乌斯函数的性质一<h1 id="常见计算"><a href="#常见计算" class="headerlink" title="常见计算"></a>常见计算</h1></li>
<li>$\mu*I=\epsilon$：上已证明</li>
<li>$I<em>\varphi=id$：<br>设$n=\prod\limits_{i=1}^kp_i^{\alpha_i}$<br>$\therefore 1\sim n$的数可以分为许多不同的集合，其中$A_{(\beta_1,\beta_2,\cdots,\beta_k)}=\{p\prod\limits_{i=1}^kp_i^{\beta_i}|gcd(p,\prod\limits_{i=1}^kp_i^{(\alpha_i-\beta_i)})=1\}$<br>$\therefore \left|A_{(\beta_1,\beta_2,\cdots,\beta_k)}\right|=\varphi\left(\prod\limits_{i=1}^kp_i^{(\alpha_i-\beta_i)}\right)$<br>$\therefore n=\sum\limits_{\beta_i\leqslant \alpha_i}\varphi\left(\prod\limits_{i=1}^kp_i^{(\alpha_i-\beta_i)}\right)=\sum\limits_{d|n}\varphi(d)$<br>$\therefore id=\varphi</em>I$</li>
<li>$\mu<em>id=\varphi$：<br>$\because id=\varphi</em>I$<br>$\therefore \varphi=id*\mu$</li>
<li>$I<em>I=\tau$：<br>$\because \tau=\sum \limits_{d|n}1$<br>$\therefore I</em>I=\tau$</li>
<li>$I<em>id=\sigma$<br>$\because \sigma=\sum \limits_{d|n} d$<br>$\therefore I</em>id=\sigma$<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1>单独只用到狄利克雷卷积的题目很少（至少我没做过），一般都会和其他的知识，如杜教筛、莫比乌斯反演等结合，狄利克雷卷积只是中间计算的工具<br>所以，在实际做题时，可以结合狄利克雷卷积进行计算</li>
</ol>
<p>相关文章：</p>
<ol>
<li><a href="https://jrjacky.github.io/2020/07/31/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BE%83%E9%AB%98%E7%AB%AF%E7%9A%84%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#more">编程中的较高端的数论知识总结1——莫比乌斯反演</a></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>编程中的较高端的数论知识总结1--莫比乌斯反演</title>
    <url>/2020/07/31/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BE%83%E9%AB%98%E7%AB%AF%E7%9A%84%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%931-%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前写过一篇名叫<a href="https://jrjacky.github.io/2019/07/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/#more">基础数论总结</a>的博客，自己认为写得不是很好，当时刚开始用CSDN写博客，$\LaTeX$公式写得不是很熟练，花了快$3$个月才写完，而且写得比较杂，有的地方也写得不够全，后来也没去改过<br>这次疫情期间，学校老师让我写一篇数论总结的博客，让我回学校后和其他同学分享，于是就有了这一系列博客<br>对于以前那篇，如果有不懂的可以自行在百度上查询，我也不会再去更改了<del>因为懒</del><br><a id="more"></a></p>
<h1 id="一些需要使用到的数论知识"><a href="#一些需要使用到的数论知识" class="headerlink" title="一些需要使用到的数论知识"></a>一些需要使用到的数论知识</h1><h2 id="简单的知识"><a href="#简单的知识" class="headerlink" title="简单的知识"></a>简单的知识</h2><p>在我的<a href="https://jrjacky.github.io/2019/07/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/#more">另一篇博客</a>中已经有了，这里就不再赘述</p>
<h2 id="简化的if语句"><a href="#简化的if语句" class="headerlink" title="简化的if语句"></a>简化的if语句</h2><p>在数论中，我们常常使用$[P]$来表示一个命题的正误<br>如果$P$是一个真命题，那么$[P]$的值就是$1$，反之，如果是假命题，值就是$0$<br>其实就相当于：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(P) [P]&#x3D;1;</span><br><span class="line">else [P]&#x3D;0;</span><br></pre></td></tr></table></figure></p>
<h2 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>数论函数指定义域为正整数的函数，每个数论函数都可视为复数的序列——度娘（有删改）</p>
<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><p>在数论函数中，最重要的性质就是积性，虽然我前面那篇博客已经写过了，但是因为太重要了，我还是要在写一遍<br>积性函数一共分为两类</p>
<h4 id="（普通的）积性函数"><a href="#（普通的）积性函数" class="headerlink" title="（普通的）积性函数"></a>（普通的）积性函数</h4><p>对于所有的积性函数，都满足一个性质：$\forall a,b\in \Z^+且gcd(a,b)=1,则f(ab)=f(a)f(b)$<br>例如，欧拉函数$\varphi(n)$就是一个典型的积性函数</p>
<h4 id="完全积性函数"><a href="#完全积性函数" class="headerlink" title="完全积性函数"></a>完全积性函数</h4><p>某些特殊的积性函数会满足：$\forall a,b\in \Z^+,则f(ab)=f(a)f(b)$，我们把这些函数叫做完全积性函数<br>最明显的完全积性函数就是$id(n)=n$，这显然是一个完全积性函数</p>
<h3 id="常见数论函数"><a href="#常见数论函数" class="headerlink" title="常见数论函数"></a>常见数论函数</h3><p>首先，是三个完全积性函数：</p>
<ol>
<li>$\epsilon(n)=[n==1]$（单位元）</li>
<li>$I(n)=1$</li>
<li>$id(n)=n$</li>
</ol>
<p>emmm……其实后面两个啥用都没有<br>接着，是一些常见的积性函数</p>
<ol>
<li>$\varphi (n)=n \times \prod \limits_{质数p|n}\left(1-\frac{1}{p}\right)$（欧拉函数）</li>
<li>$\mu (n)=\begin{cases}(-1)^t          n无平方因子，质因数个数为t\\0                 n有平方因子\end{cases}$（莫比乌斯函数，后面讲莫比乌斯反演时有用）</li>
<li>$\tau(n)=\sum \limits_{d|n}1$（正因子个数）</li>
<li>$\sigma(n)=\sum \limits_{d|n}d$（正因子和）</li>
</ol>
<p>不是积性函数的数论函数好像没有几个会考的，所以我也不列举了<del>其实我也不知道</del></p>
<h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="小小的计算"><a href="#小小的计算" class="headerlink" title="小小的计算"></a>小小的计算</h2><p>在讲述这个<strong>看似</strong>高级的东西之前，我们做一个小小的计算<br>我们假设有两个数论函数$f(n)$和$F(n)$，满足$F(n)=\sum \limits_{d|n}f(d)$<br>那么，我们来枚举一下前几项<br>$F(1)=f(1),F(2)=f(1)+f(2),F(3)=f(1)+f(3),F(4)=f(1)+f(2)+f(4),F(5)=f(1)+f(5)$<br>$F(6)=f(1)+f(2)+f(3)+f(6),F(7)=f(1)+f(7),F(8)=f(1)+f(2)+f(4)+f(8),F(9)=f(1)+f(3)+f(9)$<br>接着，我们来尝试着倒过来表示，枚举一下前几项<br>$f(1)=F(1),f(2)=F(2)-F(1),f(3)=F(3)-F(1),f(4)=F(4)-F(2),f(5)=F(5)-F(1)$<br>$f(6)=F(6)-F(3)-F(2)+F(1),f(7)=F(7)-F(1),f(8)=F(8)-F(4),f(9)=F(9)-F(3)$<br>我们来从中寻找一下规律，用$f(n)=\sum \limits_{d|n}g(d)F\left(\frac{n}{d}\right)$表示<br>问题是，$f(d)$究竟是多少呢？<br>我们来求一下：<br>$g(1)=1,g(2)=-1,g(3)=-1,g(4)=0,g(5)=-1,g(6)=1,g(7)=-1,g(8)=0,g(9)=0$<br>好像有平方因子的都是$0$，但是无平方因子的呢？好像都是$1$和$-1$，但是什么时候是$1$，什么时候又是$-1$呢？<br>通过观察，我们可以发现：$g(n)=(-1)^t$，$t$为$n$的质因子个数！<br>因此这个函数可以表示为：<br>$g(n)=\begin{cases}(-1)^t          n无平方因子，质因数个数为t\\0                 n有平方因子\end{cases}$<br>我们把这个函数成为莫比乌斯函数，用$\mu(n)$来表示<br>那么，我们得出来一个漂亮的式子：$f(n)=\sum \limits_{d|n}\mu(d)F\left(\frac{n}{d}\right)$<br>话说我们不是要讲高端的莫比乌斯反演吗，怎么讲了这么多废话？<br>这就是莫比乌斯反演啊！我们不知不觉的已经讲完了，是不是一点都不难呢？<br>其实，莫比乌斯反演的本质就是一个容斥，所以在做题时，我们可以先做出这个容斥，然后再考虑如何使用莫比乌斯反演</p>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><p>接下来，我们来具体讲解一下莫比乌斯反演中的一个重要元素——莫比乌斯函数</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>莫比乌斯函数有几个简单的性质，大家可以了解一下<br>①$\sum \limits_{d|n}\mu(d)=\begin{cases}1     (n=1)\\0     (n&gt;1)\end{cases}$<br>证明：当$n=1$时，$\sum \limits_{d|n}\mu(d)=\mu(1)=1$（显然）<br>&emsp;&emsp;&emsp;当$n&gt;1$时，设$n=\prod\limits_{i=1}^{k}p_i^{\alpha_i}$<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;又$\because n$中质因子个数为$t$的因子只有$\binom{k}{r}$个<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\therefore \sum \limits_{d|n}\mu(d)=\sum \limits_{i=0}^{k} (-1)^i\binom{k}{i}=(1-1)^k=0$<br>注：倒数第二步用到了二项式定理，在我的另一篇讲解组合计数的博客中有写到（该博客目前还未完成，不会的自行百度）<br>②$\sum \limits_{d|n}\frac{\mu(d)}{d}=\frac{\varphi(d)}{d}$<br>证明：令$F(n)=n,f(n)=\varphi(n)$<br>$\therefore F(n)=\sum \limits_{d|n}f(d)$（显然，不会的话自己思考一下）<br>$\therefore f(n)=\sum \limits_{d|n}\mu(d)F\left(\frac{n}{d}\right)$<br>$\therefore \sum \limits_{d|n}\frac{\mu(d)}{d}=\frac{\varphi(d)}{d}$<br>③$\mu(n)$为积性函数<br>证明：设$n=\prod\limits_{i=1}^{k}p_i^{\alpha_i},m=\prod\limits_{i=1}^{t}q_i^{\beta_i}$<br>$\therefore$若$\exists \alpha_i&gt;1$或$\beta_i&gt;1$，则$\mu(mn)=0=\mu(m)\mu(n)$<br>&emsp;否则，$\mu(mn)=(-1)^{k+t}=(-1)^k(-1)^t=\mu(m)\mu(n)$</p>
<h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>讲了这么多，我还是不知道莫比乌斯反演怎么求啊！<br>别着急，我这就讲<br>因为莫比乌斯函数是积性函数，我们可以使用线性筛来求解<br>线性筛大家应该都知道吧？我们在求解欧拉函数时就使用了这个方法，因为欧拉函数也是积性函数<br>具体代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=MAXN;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) p[++s]=i,mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s&amp;&amp;i*p[j]&lt;=MAXN;j++)&#123;</span><br><span class="line">            v[i*p[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p[j]) mu[i*p[j]]=-mu[i];</span><br><span class="line">            <span class="keyword">else</span>&#123;mu[i*p[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在<a href="https://github.com/jrjacky/template" target="_blank" rel="noopener">我的github仓库</a>中，有这些模板代码，大家可以自己去拷贝</p>
<h2 id="莫比乌斯反演的严格证明"><a href="#莫比乌斯反演的严格证明" class="headerlink" title="莫比乌斯反演的严格证明"></a>莫比乌斯反演的严格证明</h2><p>我们之前是用找规律的手法推出莫比乌斯反演的，那我们可不可以严格的证明呢？<br>显然是可以的，下面是证明过程：<br>$\because \sum \limits_{d|n}\mu(d)F\left(\frac{n}{d}\right)=\sum \limits_{d|n}\mu(d)\sum \limits_{i|\frac{n}{d}}f(i)=\sum \limits_{i|n}f(i)\sum \limits_{d|\frac{n}{i}}\mu(d)$<br>$\therefore$根据莫比乌斯函数的性质①，可知$\sum \limits_{d|\frac{n}{i}}\mu(d)=[i==n]$<br>$\therefore \sum \limits_{d|n}\mu(d)F\left(\frac{n}{d}\right)=\sum \limits_{i|n}f(i)\sum \limits_{d|\frac{n}{i}}\mu(d)=\sum \limits_{i|n}f(i)[i==n]=f(n)$<br>这就是莫比乌斯反演证明的全过程了，只有$3$行，但信息量很大，请大家好好消化这段证明过程</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>如果你已经掌握了上面的所有内容，那么恭喜你，你已经学完了莫比乌斯反演的全部内容了，剩下的就是实际练习了<br>在这里，我只详细写一道例题的题解，剩下的请大家自行完成（也可能会另外发题解在其他文章中）</p>
<h3 id="HAOI2011-Problem-b"><a href="#HAOI2011-Problem-b" class="headerlink" title="[HAOI2011]Problem b"></a>[HAOI2011]Problem b</h3><p>这是一道最最经典的莫比乌斯反演的题目，基本上每篇有例题的讲莫比乌斯反演的博客都会讲这道题</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>对于给出的$n$个询问，每次求有多少个数对$(x,y)$，满足$a \leqslant x \leqslant b$，$c \leqslant y \leqslant d$，且$\gcd(x,y) = k$，$\gcd(x,y)$函数为$x$和$y$的最大公约数</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行一个整数$n$，接下来$n$行每行五个整数，分别表示$a,b,c,d,k$</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共$n$行，每行一个整数表示满足要求的数对$(x,y)$的个数</p>
<h5 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h5><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 5 1 5 1</span><br><span class="line">1 5 1 5 2</span><br></pre></td></tr></table></figure>
<h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h5><p>对于$100\%$的数据满足：$1 \leqslant n,k \leqslant 5 \times 10^4$，$1 \leqslant a \leqslant b \leqslant 5 \times 10^4$，$1 \leqslant c \leqslant d \leqslant 5 \times 10^4$</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><h5 id="算法1（20分）"><a href="#算法1（20分）" class="headerlink" title="算法1（20分）"></a>算法1（20分）</h5><p>我们先不要考虑什么莫比乌斯反演之类的高级东西，先从简单出发，一步步深入，最终A掉这些题<br>这也是初学莫比乌斯反演，乃至学习新的数论算法的一个重要方法<br>你能想到的最最最暴力的方法是什么？当然是枚举啦！<br>枚举$[a,b]$之间的$x$和$[c,d]$之间的$y$，判断$gcd(x,y)$是否等于$k$就完事了<br>能不能稍微优化一下呢？当然可以！<br>我们枚举$\left[\lceil\frac{a}{k}\rceil,\lfloor\frac{b}{k}\rfloor\right]$之间的$x’$和$\left[\lceil\frac{c}{k}\rceil,\lfloor\frac{d}{k}\rfloor\right]$之间的$y’$，判断$gcd(x’,y’)$是否等于$1$即可，效率为$\Theta\left(T\frac{nmlog\frac{n}{k}}{k^2}\right)$</p>
<h5 id="算法2（50分）"><a href="#算法2（50分）" class="headerlink" title="算法2（50分）"></a>算法2（50分）</h5><p>设$Ans_{n,m}$为$a=1,b=n,c=1,d=m$的情况下的答案<br>那么，这道题的答案就是$Ans_{b,d}-Ans_{a-1d}-Ans_{b,c-1}+Ans_{a-1,c-1}$了<br>那如何优化计算$Ans_{n,m}$呢？<br>首先，可以采用和算法一一样的方法，转化为求$\sum \limits_{x=1}^{\lfloor\frac{n}{k}\rfloor}\sum \limits_{y=1}^{\lfloor\frac{m}{k}\rfloor}[gcd(x,y)==1]$<br>接着，我们假设$f_x=\sum \limits_{y=1}^{\lfloor\frac{m}{k}\rfloor}[gcd(x,y)==1]$，那么，$Ans_{n,m}=\sum \limits_{x=1}^{\lfloor\frac{n}{k}\rfloor} f_x$<br>所以，我们只需要求出$f_x$就可以了<br>设$x=\prod \limits_{i=1}^{k}p_i^{\alpha_i}$<br>那么，$f(x)=\lfloor\frac{m}{k}\rfloor+\sum\limits_{j=1}^{k}(-1)^{j}\sum\limits_{1\leqslant i_1<i_2<\cdots<i_j\leqslant k}\frac{\lfloor\frac{m}{k}\rfloor}{\prod\limits_{r=1}^{j} p_{i_r}}$
这一步需要花费$\Theta\left(2^k\right)$
因为$b,d\leqslant1000$，而$2\times 3\times 5\times 7\times 11=2310>1000$，所以$k&lt;=4$，所以可以得50分</p>
<h5 id="算法3（还是50分）"><a href="#算法3（还是50分）" class="headerlink" title="算法3（还是50分）"></a>算法3（还是50分）</h5><p>假设$f_k=\sum \limits_{x=1}^{n}\sum \limits_{y=1}^{m}[gcd(x,y)==k],g_k=\sum \limits_{x=1}^{n}\sum \limits_{y=1}^{m}[k|gcd(x,y)]$<br>那么，我们可以轻松地得出：$g_k=\sum\limits_{d=1}^{\lfloor\frac{n}{k}\rfloor}f_{kd}=\lfloor\frac{n}{k}\rfloor\lfloor\frac{m}{k}\rfloor$<br>所以，我们就可以得到：$f_{ki}=g_{ki}-\sum\limits_{j=1}^{\lfloor\frac{n}{k}\rfloor}f_{kij}$<br>时间复杂度为$\Theta\left(T\frac{n}{k}log\left(\frac{n}{k}\right)\right)$</p>
<h5 id="算法4（70分）"><a href="#算法4（70分）" class="headerlink" title="算法4（70分）"></a>算法4（70分）</h5><p>接下来，我们就要真正使用到莫比乌斯反演了<br>因为$g_k=\sum\limits_{d=1}^{\lfloor\frac{n}{k}\rfloor}f_{kd}$，所以$f_k=\sum \limits_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu_dg_{kd}=\sum \limits_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu_d\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor$<br>使用线性筛预处理$\mu_d$，复杂度为$\Theta\left(n+T\frac{n}{k}\right)$</p>
<h5 id="算法5（100分）"><a href="#算法5（100分）" class="headerlink" title="算法5（100分）"></a>算法5（100分）</h5><p>看到$\lfloor\frac{n}{kd}\rfloor$这种式子，大家应该都能反应过来要使用数论分块进行计算<br>以计算$\sum\limits_{d=1}^{n}\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$为例，讲解数论分块算法<br>枚举每一个$\lfloor\frac{n}{d}\rfloor$和$\lfloor\frac{m}{d}\rfloor$都分别相等的块，假设开始位置为$i$，那么结束位置$j=min\left(\left\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\right\rfloor,\left\lfloor\frac{m}{\lfloor\frac{m}{i}\rfloor}\right\rfloor\right)$<br>这样的话，复杂度就是$\Theta(n+T(\sqrt{n}+\sqrt{m}))$<br>正解代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d,k,mu[<span class="number">50010</span>],v[<span class="number">50010</span>],sum[<span class="number">50010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fk</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//数论分块</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) swap(x,y);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=x;i=j+<span class="number">1</span>)&#123;</span><br><span class="line">        j=min(x/(x/i),y/(y/i));</span><br><span class="line">        ans+=(<span class="keyword">long</span> <span class="keyword">long</span>)(sum[j]-sum[i<span class="number">-1</span>])*(x/i)*(y/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) mu[i]=<span class="number">1</span>,v[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">50000</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        mu[i]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=<span class="number">50000</span>;j+=i)&#123;</span><br><span class="line">            v[j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>((j/i)%i==<span class="number">0</span>) mu[j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> mu[j]*=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//计算mu_d</span></span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50000</span>;i++) sum[i]=sum[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;k;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;fk(b/k,d/k)-fk(b/k,(c<span class="number">-1</span>)/k)-fk((a<span class="number">-1</span>)/k,d/k)+fk((a<span class="number">-1</span>)/k,(c<span class="number">-1</span>)/k)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="题目推荐"><a href="#题目推荐" class="headerlink" title="题目推荐"></a>题目推荐</h3><ol>
<li><a href="https://www.luogu.com.cn/problem/P2257" target="_blank" rel="noopener">洛谷P2257 YY的GCD</a></li>
<li><a href="https://www.luogu.com.cn/problem/P4449" target="_blank" rel="noopener">洛谷P4449 于神之怒</a></li>
<li><a href="https://www.luogu.com.cn/problem/P1829" target="_blank" rel="noopener">洛谷P1829 Crash的数字表格/JZPTAB</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3312" target="_blank" rel="noopener">洛谷P3312 数表</a></li>
<li><a href="https://www.luogu.com.cn/problem/P3327" target="_blank" rel="noopener">洛谷P3327 约数个数和</a><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li>
<li>WC2016中山纪念中学宋新波莫比乌斯反演PPT</li>
<li>PoPoQQQ的莫比乌斯反演PPT</li>
</ol>
<p>相关文章：</p>
<ol>
<li><a href="https://jrjacky.github.io/2020/07/31/%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%BE%83%E9%AB%98%E7%AB%AF%E7%9A%84%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%932-%E7%8B%84%E5%88%A9%E5%85%8B%E9%9B%B7%E5%8D%B7%E7%A7%AF/#more">编程中的较高端的数论知识总结2——狄利克雷卷积</a></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>FJOI2020游记</title>
    <url>/2020/07/31/FJOI2020%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名初二的蒟蒻，能参加省选我感到很荣幸，但是我有一个大问题，就是我模板背不熟！！！所以……总之就是准备赶紧去背模板吧<br>这是我第一次参加省选，大佬勿喷<br>同时，这也是我真正意义上的第一次自己去外地（以前有去过集训，但是都是家长带着去的……）<br><a id="more"></a></p>
<h1 id="Day-1（2020-6-23）"><a href="#Day-1（2020-6-23）" class="headerlink" title="Day-1（2020.6.23）"></a>Day-1（2020.6.23）</h1><p>今天是上文化课的最后一天了，因为明天请假，不用上了，所以就作了语文和英语，数学就不做了<br>开电脑后惊奇地发现洛谷的省选联考数据居然有了，赶紧去康了康，发现不会正解，只会暴力……（我还是太菜了<br>结果第一题暴力LOJ直接过了，洛谷开了O2也过了？？？（€€£怕不是用脚造数据……，i了i了</p>
<h1 id="Day0（2020-6-24）"><a href="#Day0（2020-6-24）" class="headerlink" title="Day0（2020.6.24）"></a>Day0（2020.6.24）</h1><p>早上，坐动车到福州去，动车上不忘复习文化课，毕竟7月20号还要进行地理和生物的小中考啊<br>二等座，桌子靠墙，我坐在靠走道的位置，没桌子（气炸），只好放在腿上写<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9pbWFnZV9ob3N0aW5nLzExbWgzdWM5LnBuZw?x-oss-process=image/format,png" alt="看到了吧，桌子靠不到/kk">下动车坐地铁，记得前年来考NOIP时也在这里<br>走了半天路，11点半出发，下午2点半才到……饿死我了<br>结果居然还住的是速8，门外还写着什么华轩酒店？？？（一脸懵）<br>去吃了餐麦当劳，就去熟悉考场了，在那里呆了半个小时，打了个主席树模板（好像没有网？）<br>晚上在房间里搞了个什么考前指导……</p>
<h1 id="Day1-2020-6-25"><a href="#Day1-2020-6-25" class="headerlink" title="Day1(2020.6.25)"></a>Day1(2020.6.25)</h1><p>上午考试，第一题一看就不会……<br>好像二三题也都不会，第二题打了个暴力，就去找第三题的规律了<br>手枚4的情况，找出了两个答案，和样例一样，就又枚举了5的情况，找出了30种，也对<br>写了个dfs暴力，求出了前十项，然鹅并没有找出规律……<br>就这样度过了4个小时，预计0+10+0=10<br>中午讨论题目才知道，第一题是个费用流……我还是太菜了<br>用oeis查了第三题，发现是什么<a href="http://oeis.org/A006318" target="_blank" rel="noopener">大薛定谔数</a>，然后我谔谔了……<br>下午三点出了成绩，结果：爆零！（意料之中<br>了解到了一个新的€€£行为：申诉失败也要交钱，i了i了（还好我没去）<br>大佬们讨论FJOI2020Day1得出的结论：</p>
<ol>
<li>第三题题目质量极差，纯属找规律，整个考场没人满分</li>
<li>部分分给得贼少，基本上不是100就是0</li>
<li>没有空间限制（据说问监考老师会得到这样的答案：请自行根据数据范围判断）更不用说码长限制了</li>
</ol>
<p>晚上吃饭一群人在讨论数学竞赛的题如何打暴力，然后我有谔谔了……这不是信竞吗，怎么搞到数竞去了……<br>晚上又有考前（中？）指导……</p>
<h1 id="Day2-2020-6-26"><a href="#Day2-2020-6-26" class="headerlink" title="Day2(2020.6.26)"></a>Day2(2020.6.26)</h1><p>据说福建省选的题Day2比较简单？所以我还是信心满满地走进了考场（目标：得分！）<br>一上考场先看了第二题：这是什么鬼几何题？直接放弃<br>然后就去看第三题了<br>苦思冥想怎么写线段树，最后还是没想出来……<br>写了个暴力，预计有分（忘了多少）<br>剩下半小时写了第一题的部分分，预计也有分（也忘了）<br>预计Day2能达成目标！<br>出了考场，才知道第二题非常难，而且这场考试比Day1更难……<br>下午出成绩：再次爆零！<br>废了废了，动车上又去复习小中考了，回去就去搞文化课去了<br>先把期末考和小中考拿下，明年如果有机会，我一定会再来的</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3681 购物（shopping）</title>
    <url>/2020/07/31/DTOJ3681-%E8%B4%AD%E7%89%A9%EF%BC%88shopping%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Jesseliu</code>喜欢购物（是的千真万确！），<strong>他</strong>（？？？）尤其喜欢那种横扫一片商店的快感（？？？）<br>最近，他打算对南门口的商店实行他疯狂的购物计划<br>南门口的商业区中最繁华的就是黄兴路步行街了<br>这条街上有$n$个商店，<code>Jesseliu</code>打算进攻$m$次，每次扫荡第$[l_i,r_i]$个商店<br><code>Jesseliu</code>会把他经过的每个商店扫荡一空(换句话说,就是一个商店不会被算两次)<br>因为连续地扫一片商店是很爽的（？？？），所以<code>Jesseliu</code>把一次扫荡的$happy$值定义为所有连续的一段没被扫空的商店$happy$值之和的平方的和，已被扫空的不再计算<br>现在你不经意间得知了<code>Jesseliu</code>的购物计划（？？？），而你需要将这些计划排序并求出<code>Jesseliu</code>最多获得的$happy$值之和，如果算错了<code>Jesseliu</code>就会卖萌，这可是很致命的哦！（？？？）</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为$n$和$m$，意义如描述之所示<br>接下来一行$n$个数，第$i$个数表示第$i$个商店的$happy$值<br>接下来$m$行，每行两个数<br>$l_i,r_i$表示<code>Jesseliu</code>第$i$次行动要扫荡第$l_i$到第$r_i$个商店</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行,包含一个数即为<code>Jesseliu</code>最多获得的$happy$值之和</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14 2</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br><span class="line">4 9</span><br><span class="line">2 12</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">121</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30 \%$的数据，$n \leqslant 10,m \leqslant 8$<br>对于$60 \%$的数据，$n \leqslant 1000,m \leqslant 1000$<br>对于$100 \%$的数据，$n \leqslant 5000,m \leqslant 10^6,happy$值$\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然，这是一个DP<br>我们假设$f_i$表示前$i$个的最大值（如果有的区间$[l,r]$满足$l\leqslant i<r$，那么就去除$(i,r]$的部分）
我们需要先计算出两个值，一个是$R_i$，表示包含$i$的$r$最大的区间，即$\max \limits_{j \in [1,n],i\in [l_j,r_j]}r_j$，另一个是$h_i$的前缀和$s_i$
这个值的求法非常简单，首先$R_{l_i}=max\{R_{l_i},r_i\}$，接着$R_i=max\{R_i,R_{i-1}\}$
求出这个值之后，我们就可以计算$f_i$了
首先枚举$i \in [1,n]$，再枚举$j \in [i,R_i]$，我们就可以得到$f_j=max\{f_{i-1}+(s_j-s_{i-1})^2\}$就可以了
最后的答案就是$\max \limits_{i \in [1,n]}f_i$了
附上代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,h[<span class="number">5010</span>],s[<span class="number">5010</span>],l[<span class="number">1000010</span>],r[<span class="number">1000010</span>],R[<span class="number">5010</span>],f[<span class="number">5010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"shopping.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"shopping.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;h[i]),s[i]=s[i<span class="number">-1</span>]+h[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) R[l[i]]=max(R[l[i]],r[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) R[i]=max(R[i],R[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=R[i];j++) f[j]=max(f[j],f[i<span class="number">-1</span>]+(s[j]-s[i<span class="number">-1</span>])*(s[j]-s[i<span class="number">-1</span>]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=max(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2351 情报传递（message）</title>
    <url>/2020/07/31/DTOJ2351-%E6%83%85%E6%8A%A5%E4%BC%A0%E9%80%92%EF%BC%88message%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>奈特公司是一个巨大的情报公司，它有着庞大的情报网络，情报网络中共有$n$名情报员<br>每名情报员可能有若干名（可能没有）下线，除$1$名大头目外其余$n-1$名情报员有且仅有$1$名上线<br>奈特公司纪律森严，每名情报员只能与自己的上、下线联系（？？？），同时，情报网络中任意两名情报员一定能够通过情报网络传递情报<br>奈特公司每天会派发以下两种任务中的一个任务：</p>
<ol>
<li>搜集情报：指派T号情报员搜集情报</li>
<li>传递情报：将一条情报从X号情报员传递至Y号情报员</li>
</ol>
<p>情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为$0$<br>一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加$1$点危险值（开始搜集情报的当天危险值仍为$0$，第$2$天危险值为$1$，第$3$天危险值为$2$，以此类推）<br>传递情报并不会使情报员的危险值增加<br>为了保证传递情报的过程相对安全，每条情报都有一个风险控制值$C$<br>奈特公司认为，参与传递这条情报的所有情报员中，危险值大于$C$的情报员将对这条情报构成威胁<br>现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对这条情报构成威胁的情报员有多少个</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第$1$行包含$1$个正整数$n$，表示情报员个数<br>第$2$行包含$n$个非负整数，其中第$i$个整数$P_i$表示$i$号情报员上线的编号<br>特别地，若$P_i=0$，表示i号情报员是大头目<br>第$3$行包含$1$个正整数$q$，表示奈特公司将派发$q$个任务（每天一个）<br>随后$q$行，依次描述$q$个任务<br>每行首先有$1$个正整数$k$<br>若$k=1$，表示任务是传递情报，随后有$3$个正整数$X_i、Y_i、C_i$，依次表示传递情报的起点、终点和风险控制值<br>若$k=2$，表示任务是搜集情报，随后有$1$个正整数$T_i$，表示搜集情报的情报员编号</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个传递情报任务输出一行，应包含两个整数，分别是参与传递情报的情报员个数和对该条情报构成威胁的情报员个数<br>输出的行数应等于传递情报任务的个数，每行仅包含两个整数，用一个空格隔开<br>输出不应包含多余的空行和空格</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0 1 1 2 2 3 3</span><br><span class="line">6</span><br><span class="line">1 4 7 0</span><br><span class="line">2 1</span><br><span class="line">2 4</span><br><span class="line">2 7</span><br><span class="line">1 4 7 1</span><br><span class="line">1 4 7 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 0</span><br><span class="line">5 2</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>对于$3$个传递情报任务，都是经过$5$名情报员，分别是$4$号、$2$号、$1$号、$3$号和$7$号<br>其中，对于第$1$个任务，所有情报员（危险值为$0$）都不对情报构成威胁<br>对于第$2$个任务，有$2$名情报员对情报构成威胁，分别是$1$号情报员（危险值为$3$）和$4$号情报员（危险值为$2$），$7$号情报员（危险值为$1$）并不构成威胁<br>对于第$3$个任务，只有$1$名情报员对情报构成威胁</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，只包含传递情报任务<br>另有$30\%$的数据，保证传递情报任务中$C_i$等于$0$<br>对于$100\%$的数据，$n\leqslant 2\times 10^5，q\leqslant 2\times 10^5，0\leqslant P_i，C_i\leqslant n，1\leqslant T_i，X_i，Y_i\leqslant n$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，题目相当于要求我们回答两个问题：</p>
<ol>
<li>两个点之间的链的长度</li>
<li>两个点之间的链上有多少个数大于$c$</li>
</ol>
<p>第一个问题极其简单，直接计算$dep_x+dep_y-2\times dep_{lca(x,y)}+1$就可以了<br>对于第二个问题，我们可以先把所有数读入，再建一棵主席树，把所有的$2$操作全部先做完，再同一回答询问<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,Root,head[<span class="number">200010</span>],nxt[<span class="number">400010</span>],to[<span class="number">400010</span>],dfn[<span class="number">200010</span>],nfd[<span class="number">200010</span>],Fa[<span class="number">200010</span>][<span class="number">21</span>],dep[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> m,cnt,root[<span class="number">200010</span>],T[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c,d;</span><br><span class="line">&#125;s[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,sum;</span><br><span class="line">&#125;t[<span class="number">4000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++cnt,nfd[cnt]=x,Fa[x][<span class="number">0</span>]=fa,dep[x]=dep[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa) dfs(to[i],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(dep[x]-(<span class="number">1</span>&lt;&lt;i)&gt;=dep[y]) x=Fa[x][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(Fa[x][i]!=Fa[y][i]) x=Fa[x][i],y=Fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> Fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> fa,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[p].sum=t[fa].sum+<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d&lt;=mid) change(t[p].ls,t[fa].ls,l,mid,d),t[p].rs=t[fa].rs;</span><br><span class="line">    <span class="keyword">else</span> change(t[p].rs,t[fa].rs,mid+<span class="number">1</span>,r,d),t[p].ls=t[fa].ls;</span><br><span class="line">    t[p].sum=t[t[p].ls].sum+t[t[p].rs].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> LCA,<span class="keyword">int</span> fa,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;R&gt;=r) <span class="keyword">return</span> t[b].sum+t[c].sum-t[LCA].sum-t[fa].sum;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ans=ask(t[b].ls,t[c].ls,t[LCA].ls,t[fa].ls,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) ans+=ask(t[b].rs,t[c].rs,t[LCA].rs,t[fa].rs,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"message.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"message.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(!x) Root=i;</span><br><span class="line">        <span class="keyword">else</span> add(x,i),add(i,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(Root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">19</span>;j++) <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Fa[i][j]=Fa[Fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i].a,&amp;s[i].b);</span><br><span class="line">        <span class="keyword">if</span>(s[i].a==<span class="number">1</span>) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s[i].c,&amp;s[i].d);</span><br><span class="line">        <span class="keyword">if</span>(s[i].a==<span class="number">2</span>) T[s[i].b]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) change(root[nfd[i]],root[Fa[nfd[i]][<span class="number">0</span>]],<span class="number">0</span>,m,T[nfd[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i].a==<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> LCA=lca(s[i].b,s[i].c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dep[s[i].b]+dep[s[i].c]-dep[LCA]*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(i-s[i].d<span class="number">-1</span>&lt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ask(root[s[i].b],root[s[i].c],root[LCA],root[Fa[LCA][<span class="number">0</span>]],<span class="number">0</span>,m,<span class="number">1</span>,i-s[i].d<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2548 翻转硬币</title>
    <url>/2020/07/31/DTOJ2548-%E7%BF%BB%E8%BD%AC%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>$n$枚硬币正面朝上摆成一排，给定$a_1,a_2,\cdots,a_m$，每次操作可以翻转连续$a_i$个硬币。要求经过最少次数的操作，使得仅第$x_1,x_2,\cdots,x_k$枚硬币反面朝上，输出最少次数</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个整数$n,k,m$<br>第二行$k$个整数表示需要反面朝上的硬币位置，从$1$编号<br>第三行$m$个整数表示$a_1,a_2,\cdots,a_m$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数表示答案，若无解，则输出$-1$</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 8 2</span><br><span class="line">1 2 3 5 6 7 8 9</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据，$n,m\leqslant 10$<br>对于$60\%$的数据，$m\leqslant 20$<br>对于$100\%$的数据，$1\leqslant n\leqslant 10000,1\leqslant k\leqslant 10,1\leqslant m\leqslant100,1\leqslant a[i]\leqslant n$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为每次翻转改变的是相邻硬币<strong>相对</strong>的状态<br>所以我们用$d_i$表示相邻硬币相对的状态，即$0$表示状态相同，$1$表示状态不同<br>现在，假设我们翻转$[x+1,x+a_i)$，那么，我们只会影响$d_x$和$b_{x+a_i}$，有三种情况：</p>
<ol>
<li>$d_{x}=d_{x+a_i}=0$：这个翻转没啥用</li>
<li>$d_{x}=d_{x+a_i}=1$：两个都变成$0$</li>
<li>$d_{x}=0,d_{x+a_i}=1$：就相当于是把$x+a_i$移到了$x$</li>
</ol>
<p>所以我们可以先预处理出每个$d_i=1$的$i$到其他$d_j=1$的$j$的距离$g_{i,j}$<br>然后我们就可以状压状压$dp$了<br>我们用$f_s$为到达状态$s$所需最少次数<br>我们假设$s$中为$1$的位最大是$k$（即最大的满足$i\&amp;2^k=1$的$k$），那么$f_{s-2^j-2^k}=min\{f_{s}+g_{j,k}\}$，其中，$j$是$s$中为$1$的位，且$j\neq k$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k,nd=<span class="number">-1</span>,c[<span class="number">10010</span>],a[<span class="number">110</span>],d[<span class="number">30</span>],f[<span class="number">1048580</span>],g[<span class="number">30</span>][<span class="number">30</span>],dis[<span class="number">10010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[x]=<span class="number">0</span>,q.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        x=q.front(),q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x-a[i]&gt;=<span class="number">0</span>&amp;&amp;dis[x]+<span class="number">1</span>&lt;dis[x-a[i]]) dis[x-a[i]]=dis[x]+<span class="number">1</span>,q.push(x-a[i]);</span><br><span class="line">            <span class="keyword">if</span>(x+a[i]&lt;=n&amp;&amp;dis[x]+<span class="number">1</span>&lt;dis[x+a[i]]) dis[x+a[i]]=dis[x]+<span class="number">1</span>,q.push(x+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("coin.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("coin.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;j),c[j]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">if</span>(c[i]!=c[i+<span class="number">1</span>]) d[++nd]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1048576</span>;i++) f[i]=<span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nd;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=nd;j++) g[i][j]=<span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=nd;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++) dis[j]=<span class="number">100000000</span>;</span><br><span class="line">        bfs(d[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=nd;j++) g[j][i]=g[i][j]=min(g[i][j],dis[d[j]]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[(<span class="number">1</span>&lt;&lt;nd+<span class="number">1</span>)<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=(<span class="number">1</span>&lt;&lt;nd+<span class="number">1</span>)<span class="number">-1</span>,k;i;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=nd;k&gt;=<span class="number">0</span>;--k) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;k)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=nd;j++) <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;j!=k) f[i-(<span class="number">1</span>&lt;&lt;j)-(<span class="number">1</span>&lt;&lt;k)]=min(f[i-(<span class="number">1</span>&lt;&lt;j)-(<span class="number">1</span>&lt;&lt;k)],f[i]+g[j][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>]&lt;<span class="number">100000000</span>) <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2549 有没有wifi</title>
    <url>/2020/07/31/DTOJ2549-%E6%9C%89%E6%B2%A1%E6%9C%89wifi/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><a id="more"></a>
<p>一家餐馆可以视为一个$L\times W$的矩形，其安装了$N$个无线路由器，每个无线路由器给定坐标$x_i,y_i$以及覆盖半径$R_i$（可以安装在餐馆外部）<br>老板邀请了一位神奇程序员来调整无线路由器的发射倍率（？？？），可以将所有路由器的覆盖半径乘以一个系数$K$，求最小的$K$使得无线覆盖整个餐馆的同时又最节省成本</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$T$，表示数据组数<br>以下$T$组数据，每组数据第一行三个整数$N,L,W$，表示路由器个数和餐馆大小<br>接下来$N$行，每行三个不超过$1000$的正整数$x_i,y_i,R_i$表示一个路由器的坐标和原始覆盖半径</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一个实数K，保留3位小数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 2 2</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.414</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>数据编号$1$ $N=1$ 数据组数$=20$</p>
<p>数据编号$2$ $N=2$ 数据组数$=20$</p>
<p>数据编号$3$ $N&lt;=10$ 数据组数$=20$</p>
<p>数据编号$4$ $N&lt;=10$ 数据组数$=1000$</p>
<p>数据编号$5$ $N&lt;=50$ 数据组数$=10$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一个极其暴力的暴力……（居然第一题A了那么多人，第三题只有我A了……）<br>看到这道题，第一眼的思路就是二分<br>那么我们就看怎么判断是否所有地方都被覆盖了<br>如果一个矩形，如果它的四个角都被同一个圆覆盖了，那么显然，这整个矩形都被圆覆盖了；如果它的四个角都没有被任何一个圆覆盖，那么显然，这个矩形就完全没有被覆盖；除了上面这两种情况以外的其他情况，我们可以直接暴力地把整个矩形拆成四个小矩形（左上、右上、左下、右下四块），就可以啦！<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">double</span> R,r;</span><br><span class="line">&#125;a[<span class="number">60</span>];</span><br><span class="line"><span class="keyword">int</span> n,L,W;</span><br><span class="line"><span class="keyword">double</span> l,r,eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">(<span class="keyword">double</span> x1,<span class="keyword">double</span> y1,<span class="keyword">double</span> x2,<span class="keyword">double</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x2-x1&lt;eps||y2-y1&lt;eps) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> flag1=<span class="number">0</span>,flag2=<span class="number">0</span>,flag3=<span class="number">0</span>,flag4=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">0</span>,f2=<span class="number">0</span>,f3=<span class="number">0</span>,f4=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(dis(x1,y1,a[i].x,a[i].y)&lt;=a[i].r) flag1=f1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dis(x1,y2,a[i].x,a[i].y)&lt;=a[i].r) flag2=f2=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dis(x2,y2,a[i].x,a[i].y)&lt;=a[i].r) flag3=f3=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dis(x2,y1,a[i].x,a[i].y)&lt;=a[i].r) flag4=f4=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(f1&amp;&amp;f2&amp;&amp;f3&amp;&amp;f4) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag1||!flag2||!flag3||!flag4) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> x3=(x1+x2)/<span class="number">2</span>,y3=(y1+y2)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> pd(x1,y1,x3,y3)&amp;&amp;pd(x3,y3,x2,y2)&amp;&amp;pd(x1,y3,x3,y2)&amp;&amp;pd(x3,y1,x2,y3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"wifi.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"wifi.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;L,&amp;W);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>,&amp;a[i].x,&amp;a[i].y,&amp;a[i].R);</span><br><span class="line">        l=<span class="number">0</span>,r=<span class="number">1000.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l+eps&lt;r)&#123;</span><br><span class="line">            <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i].r=a[i].R*mid;</span><br><span class="line">            <span class="keyword">if</span>(pd(<span class="number">0</span>,<span class="number">0</span>,L,W)) r=mid;</span><br><span class="line">            <span class="keyword">else</span> l=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>,l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3702 月读（tsukuyomi）</title>
    <url>/2020/07/31/DTOJ3702-%E6%9C%88%E8%AF%BB%EF%BC%88tsukuyomi%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>有些时候，出题人真的不想写背景（？？？）<br>总而言之，月读现在有一棵大小为$N$，树上每条边上有一个数字，月读有$M$次询问，每次询问一对$(x,y)$，你需要回答从$x$到$y$的路径上的数字重新排列能否形成一个回文序列，若可行输出<code>Yes</code>，否则输出<code>No</code><br>月读为了加快您的读入，每次询问的$x,y$是通过某种方式生成的，为了加快您的输出，你只需要最后输出回答<code>Yes</code>的个数和即可</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数$N,M$<br>接下来$N-1$行：三个整数$u_i,v_i,w_i$​，描述一条边$(u_i,v_i)$与边上的数字$w_i$<br>接下来一行$A_1,B_1$<br>$M$个询问以如下方式生成<br>$x_i=A_i \% n+1,y_i=B_i \% n+1$<br>$A_i=A_{i-1} \times 666073 \% (10^9+7)$<br>$B_i=B_{i-1} \times 233 \% 998244353$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个数字，代表回答<code>Yes</code>的个数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">1 4 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于此题有六个测试点：<br>A（$10$分）$N,M \leqslant 2000$<br>B（$23$分）$N,M \leqslant 10^5,u_i=v_i+1$<br>C（$15$分）$N,M \leqslant 10^5$<br>D（$15$分）$N,M \leqslant 10^6,w_i \leqslant 30$<br>E（$17$分）$N,M \leqslant 10^6$<br>F（$20$分）$N \leqslant 10^6,M \leqslant 10^7$<br>对于所有的$wi \leqslant n$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>如果重新排列能形成一个回文序列的话，那么满足出现的次数是奇数的数字最多只能有一个<br>所以我们可以对每一种边权进行哈希赋值，和$0$一起存入哈希表中<br>接着，我们记$Xor_i$为根到$i$点的边权异或和<br>那么，如果询问的点为$x,y$，只要$f_x\land f_y$在哈希表里出现过，回答就是$Yes$<br><strong>注意：如果你在DTOJ上提交，建议你不要使用C++11(NOI)，使用C++11，否则可能会超时</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,Tot,tot,cnt,Head[<span class="number">1000010</span>],Nxt[<span class="number">1000010</span>],head[<span class="number">1000010</span>],to[<span class="number">2000010</span>],ver[<span class="number">2000010</span>],nxt[<span class="number">2000010</span>],dfn[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> POW[<span class="number">1000010</span>],<span class="built_in">pow</span>[<span class="number">2000010</span>],Ver[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">char</span> ch=getchar();</span><br><span class="line">   <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)w=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">   <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) s=s*<span class="number">10</span>+ch-<span class="string">'0'</span>,ch=getchar();</span><br><span class="line">   <span class="keyword">return</span> s*w;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=x%<span class="number">1000007</span>;</span><br><span class="line">    Nxt[++Tot]=Head[y],Head[y]=Tot,Ver[Tot]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y=x%<span class="number">1000007</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Head[y];i;i=Nxt[i]) <span class="keyword">if</span>(Ver[i]==x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v,ver[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa,<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> Pow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++cnt,<span class="built_in">pow</span>[cnt]=Pow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa) dfs(to[i],x,POW[ver[i]]),<span class="built_in">pow</span>[++cnt]=POW[ver[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read(),POW[<span class="number">0</span>]=<span class="number">1</span>,Add(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) POW[i]=POW[i<span class="number">-1</span>]*<span class="number">793999</span>,Add(POW[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++) u=read(),v=read(),w=read(),add(u,v,w),add(v,u,w);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>,(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++) <span class="built_in">pow</span>[i]^=<span class="built_in">pow</span>[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">int</span> a,b,ans=<span class="number">0</span>;</span><br><span class="line">    a=read(),b=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++)</span><br><span class="line">        x=a%n+<span class="number">1</span>,y=b%n+<span class="number">1</span>,a=<span class="number">666073l</span>l*a%<span class="number">1000000007</span>,b=<span class="number">233l</span>l*b%<span class="number">998244353</span>,ans+=Find(<span class="built_in">pow</span>[dfn[x]]^<span class="built_in">pow</span>[dfn[y]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3629 染色游戏（paint）</title>
    <url>/2020/07/31/DTOJ3629-%E6%9F%93%E8%89%B2%E6%B8%B8%E6%88%8F%EF%BC%88paint%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>蒜头是一名优秀的画家<br>蒜头有一张长度为$n$的画卷，在位置$i$上画图案会获得$a_i$的美观度<br>蒜头是一个有追求的人，因此他希望他的画从左往右是越来越美观的，即对于任意两个画了图案的格子$l &lt; r$，有$a_l \leqslant a_r$<br>但蒜头发现，人们评判画卷的好坏，并不会只从画出的图案来考虑<br>具体来说，一张画卷的美观度，定义为所有画了图案的位置的美观度之和与在图上选择两个可以重复的位置使得两位置之间不存在画了图案的位置的方案数之差<br>现在，蒜头想要知道，他画出的画卷的最大美观度是多少<br>形式化地，一段连续的长度为$m$的空白位置会让美观度降低$\frac{m(m+1)}{2}$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行是一个数$n$，表示序列的长度<br>接下来一行$n$个数，第$i$个数表示$a_i$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行表示最大美观度</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><h4 id="输入样例1"><a href="#输入样例1" class="headerlink" title="输入样例1"></a>输入样例1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 3 2 7 3 2 4</span><br></pre></td></tr></table></figure>
<h4 id="输入样例2"><a href="#输入样例2" class="headerlink" title="输入样例2"></a>输入样例2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">-3 -4 -2 -2 -6 -8 -1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><h4 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1"></a>输出样例1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h4 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2"></a>输出样例2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-11</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$100 \%$的数据，$-10^8 \leqslant a_i \leqslant 10^8$<br>对于子任务$1$，$19$分，$n \leqslant 20$<br>对于子任务$2$，$22$分，$n \leqslant 5000$<br>对于子任务$3$，$18$分， $n \leqslant 10^6$，数据随机<br>对于子任务$4$，$41$分，$n \leqslant 10^6$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们先不考虑“对于任意两个画了图案的格子$l<r$，有$a_l \leqslant a_r​$”这个条件，正常的进行DP
我们用$f_i$表示只画前$i$个并且一定画第$i$时最大的美观度
我们先写出转移方程：$f_i=\max \limits_{j<i}\{f_j+a_i-\frac{(i-j-1)(i-j)}{2}\}$
我们把$\frac{(i-j-1)(i-j)}{2}$展开，得到：$f_j+a_i-\frac{(i-j-1)(i-j)}{2}=f_j+a_i-\frac{i^2}{2}-\frac{j^2}{2}+ij+\frac{i}{2}-\frac{j}{2}$
接着，我们设$j<i$且$\max \limits_{k<i}\{f_k+a_i-\frac{(i-k-1)(i-k)}{2}\}=f_j+a_i-\frac{(i-j-1)(i-j)}{2}$
那么，我们可以得到$-f_j+\frac{j^2}{2}+\frac{j}{2}=ij-f_i+a_i-\frac{i^2}{2}+\frac{i}{2}$
这样，我们就可以进行斜率优化DP了
解决了DP，我们再从头来考虑一下“对于任意两个画了图案的格子$l<r$，有$a_l \leqslant a_r​$”这个条件
这个东西怎么这么熟悉呢？哦！是二维偏序！
所以我们可以使用CDQ分治！
但是排序用什么算法呢？快排吗？
好像太慢了，要$\Theta(nlog^2n)$
如何优化呢？既然是CDQ分治，我们排序就也用分治嘛！我们可以使用归并排序，这样可以预处理出CDQ分治的每一层，节省时间
算了一下，复杂度是$\Theta(nlogn)$
附上代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,q[<span class="number">1000010</span>],a[<span class="number">1000010</span>],ord[<span class="number">1000010</span>],rk[<span class="number">21</span>][<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans,f[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x,<span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[x]&lt;a[y]||(a[x]==a[y]&amp;&amp;x&lt;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Slope</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*f[x]<span class="number">-1l</span>l*x*x-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;rk[d][l]=ord[l];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Merge_Sort(l,mid,d+<span class="number">1</span>),Merge_Sort(mid+<span class="number">1</span>,r,d+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,rank=l<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[d+<span class="number">1</span>][i]&lt;rk[d+<span class="number">1</span>][j]) rk[d][++rank]=rk[d+<span class="number">1</span>][i++];</span><br><span class="line">        <span class="keyword">else</span> rk[d][++rank]=rk[d+<span class="number">1</span>][j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) rk[d][++rank]=rk[d+<span class="number">1</span>][i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) rk[d][++rank]=rk[d+<span class="number">1</span>][j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ_DC</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        f[ord[l]]=max(f[ord[l]],a[ord[l]]<span class="number">-1l</span>l*(ord[l]<span class="number">-1</span>)*ord[l]/<span class="number">2</span>);</span><br><span class="line">        ans=max(ans,f[ord[l]]<span class="number">-1l</span>l*(n-ord[l])*(n-ord[l]+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,H=<span class="number">1</span>,T=<span class="number">0</span>;</span><br><span class="line">    CDQ_DC(l,mid,d+<span class="number">1</span>),q[H]=q[T]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=mid+<span class="number">1</span>,k=l;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=rk[d][i];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=mid&amp;&amp;rk[d][k]&lt;j)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> w=rk[d][k];</span><br><span class="line">            <span class="keyword">while</span>(H&lt;T&amp;&amp;((Slope(w)-Slope(q[T]))*(q[T]-q[T<span class="number">-1</span>])&gt;=(Slope(q[T])-Slope(q[T<span class="number">-1</span>]))*(w-q[T]))) T--;</span><br><span class="line">            q[++T]=w,k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(H&lt;T&amp;&amp;(Slope(q[H+<span class="number">1</span>])-Slope(q[H])&gt;=<span class="number">-2l</span>l*j*(q[H+<span class="number">1</span>]-q[H]))) H++;</span><br><span class="line">        <span class="keyword">if</span>(H&lt;=T&amp;&amp;H) f[j]=max(f[j],f[q[H]]+a[j]<span class="number">-1l</span>l*(j-q[H]<span class="number">-1</span>)*(j-q[H])/<span class="number">2</span>);</span><br><span class="line">        ans=max(ans,f[j]<span class="number">-1l</span>l*(n-j)*(n-j+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    CDQ_DC(mid+<span class="number">1</span>,r,d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"paint.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"paint.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),ord[i]=i,f[i]=<span class="number">-1e18</span>;</span><br><span class="line">    sort(ord+<span class="number">1</span>,ord+n+<span class="number">1</span>,cmp),ans=<span class="number">-1l</span>l*n*(n+<span class="number">1</span>)/<span class="number">2</span>,Merge_Sort(<span class="number">1</span>,n,<span class="number">0</span>),CDQ_DC(<span class="number">1</span>,n,<span class="number">1</span>),<span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>斜率优化DP</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3312 行走</title>
    <url>/2020/07/31/DTOJ3312-%E8%A1%8C%E8%B5%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>“我有个愿望，我希望走到你身边。”<br>这是个奇异的世界，世界上的$n-1$条路联结起来形成一棵树，每条路有一个对应的权值$c_i$（？？？）<br>现在我会给出$q$组询问或操作<br>每次询问我会从一个$x$点走到$y$点，初始在$x$点我会有一个数字$v$，然后每走过一条权值为$c$的边，我的$v$就会变成$\left\lfloor \frac{v}{c} \right\rfloor$ ,问最后到<br>$y$时$v$变成了什么<br>每次修改我会修改一条边的权值，保证修改后的权值小于等于原来的权值且不会小于$1$<br>每组询问或操作的格式如下：<br>询问：$1~x~y~v$表示从$x$走到$y$，一开始的数字为$v$<br>操作：$2~p~c$表示将第$p$条边的边权修改为$c$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n$和$q$表示点个数和询问与操作个数<br>接下来$n-1$行每行三个整数$u,v,c$表示$u$与$v$之间有一条边权为$c$的边<br>接下来$q$行每行第一个数$type$<br>如果$type=1$那么接下来三个数$x,y,v$表示一组询问<br>如果$type=2$那么接下来两个数$p,c$表示一组操作</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组询问输出一个数表示最后的答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><h4 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 6</span><br><span class="line">1 2 1</span><br><span class="line">1 3 7</span><br><span class="line">1 4 4</span><br><span class="line">2 5 5</span><br><span class="line">2 6 2</span><br><span class="line">1 4 6 17</span><br><span class="line">2 3 2</span><br><span class="line">1 4 6 17</span><br><span class="line">1 5 5 20</span><br><span class="line">2 4 1</span><br><span class="line">1 5 1 3</span><br></pre></td></tr></table></figure>
<h4 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 2 7</span><br><span class="line">1 3 3</span><br><span class="line">3 4 2</span><br><span class="line">3 5 5</span><br><span class="line">1 4 2 100</span><br><span class="line">1 5 4 1</span><br><span class="line">2 2 2</span><br><span class="line">1 1 3 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><h4 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">20</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>对于样例数据1：<br>一开始那棵树长这个样：<br><img src="https://img-blog.csdnimg.cn/20200731211318195.png" alt="在这里插入图片描述"></p>
<p>第一个询问最后的答案就是：$\left\lfloor \frac{\left\lfloor \frac{17}{4} \right\rfloor}{2} \right\rfloor=2$<br>第三条边改变之后，树变成了这样：<br><img src="https://img-blog.csdnimg.cn/20200731211409769.png" alt="在这里插入图片描述"></p>
<p>第二个询问的答案就是：$\left\lfloor \frac{\left\lfloor \frac{17}{2} \right\rfloor}{2} \right\rfloor=4$<br>第三个询问中起点和终点一样，故答案为$20$<br>改了第四条边之后，树变成了这样：<br><img src="https://img-blog.csdnimg.cn/20200731211501847.png" alt="在这里插入图片描述"></p>
<p>最后一个询问答案就是$\left\lfloor \frac{\left\lfloor \frac{3}{1} \right\rfloor}{1} \right\rfloor=3$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$70 \%$的数据保证$1 \leqslant n \leqslant 10^3$<br>对于$100 \%$的数据保证$1 \leqslant n \leqslant 10^5,1 \leqslant c_i \leqslant 10^{18}$<br>保证每次修改后的边权小于等于原来的边权且不会小于$1$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为我不知道$q$的范围，所以，我还是尽量让时间复杂度变小了<del>太怂了</del><br>所以我进行了两个优化：</p>
<ol>
<li>边权是$1$的边就不操作了</li>
<li>当两个点的距离$\geqslant 62$时，答案一定是$0$（因为$c\leqslant 10^{18}\leqslant 2305843009213693952=2^{61}\leqslant$所有这两个点之间的路径的点权的乘积）</li>
</ol>
<p>所以，我们可以用一个并查集把所有连续的、边权是$1$的点全部并到一个集合里，然后直接暴力向上跳就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ver;</span><br><span class="line">&#125;e[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,q,tot,head[<span class="number">100010</span>],fa[<span class="number">100010</span>],dep[<span class="number">100010</span>],Fa[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> b[<span class="number">100010</span>],b1[<span class="number">100010</span>],b2[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">long</span> <span class="keyword">long</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].ver=w,e[tot].to=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(!fa[e[i].to]) fa[e[i].to]=x,b[e[i].to]=e[i].ver,dep[e[i].to]=dep[x]+<span class="number">1</span>,dfs(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Fa[x]==x?x:Fa[x]=find(Fa[x]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"walk.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"walk.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    fa[<span class="number">1</span>]=<span class="number">1</span>,dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Fa[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;i++) <span class="keyword">if</span>(b[i]==<span class="number">1</span>) x=find(fa[i]),y=find(i),Fa[y]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,op,x,y,p,nb1,nb2;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>,&amp;x,&amp;y,&amp;v),x=find(x),y=find(y),nb1=nb2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x!=y&amp;&amp;nb1+nb2&lt;<span class="number">62</span>)</span><br><span class="line">                <span class="keyword">if</span>(dep[x]&gt;dep[y]) b1[++nb1]=b[x],x=find(fa[x]);</span><br><span class="line">                <span class="keyword">else</span> b2[++nb2]=b[y],y=find(fa[y]);</span><br><span class="line">            <span class="keyword">if</span>(nb1+nb2&gt;=<span class="number">62</span>) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nb1;i++) v/=b1[i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=nb2;i&gt;=<span class="number">1</span>;i--) v/=b2[i];</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>,&amp;p,&amp;v),p&lt;&lt;=<span class="number">1</span>,y=e[p].to,x=fa[y];</span><br><span class="line">            <span class="keyword">if</span>(fa[e[p<span class="number">-1</span>].to]==y) p--,y=e[p].to,x=fa[y];</span><br><span class="line">            b[y]=v;</span><br><span class="line">            <span class="keyword">if</span>(!(b[y]^<span class="number">1</span>)) x=find(x),y=find(y),Fa[y]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3305 环（circle）</title>
    <url>/2020/07/31/DTOJ3305-%E7%8E%AF%EF%BC%88circle%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>小A</code>有一个环，环上有$n$个正整数<br>他有特殊的能力（？？？），能将环切成$k$段，每段包含一个或者多个数字<br>对于一个切分方案，<code>小A</code>将以如下方式计算优美程度：<br>首先对于每一段，求出他们的数字和<br>然后对于每段的和，求出他们的最大公约数，即为优美程度<br>他想通过合理地使用他的特殊能力，使得切分方案的优美程度最大</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$，表示环上的数字个数<br>接下来一行包含$n$个正整数，第$i$个数$a_i$表示环上第$i$个数</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出$n$行，第$i$行表示切成$i$段时的最大优美程度</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 3 3 3 3 3 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$20\%$的数据，$n \leqslant 16,a_i \leqslant 10$<br>对于$40\%$的数据，$n \leqslant 100,a_i \leqslant 1000$<br>对于$100\%$的数据，$n \leqslant 2000,1 \leqslant a_i \leqslant 5 \times 10^7$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然，答案是$\sum \limits_{i=1}^na_i$的约数<br>所以我们可以枚举$\sum \limits_{i=1}^na_i$的每一个约数，对于每一个约数$d$，计算最多能切成几段，使得这几段$gcd$起来是$d$<br>现在的问题就是到底能分成几段<br>这个非常简单<br>我们统计前缀和$sum_i$，如果$sum_i\equiv sum_j\pmod{d}$，那么$i\sim j$就可以分一段<br>所以，我们可以用一个map统计$sum_i$模$d$的余数，然后答案就是这个map中值最大的那个<br>最终的答案就是后缀最大值啦！<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">2010</span>],ans[<span class="number">2010</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; mod;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mod.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s;i&lt;=n;i++) s=++mod[a[i]%k],ans[s]=max(ans[s],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"circle.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"circle.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(a[n]);i++) <span class="keyword">if</span>(!(a[n]%i))&#123;</span><br><span class="line">        work(i);</span><br><span class="line">        <span class="keyword">if</span>(i*i!=a[n]) work(a[n]/i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) ans[i]=max(ans[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3701 天照</title>
    <url>/2020/07/31/DTOJ3701-%E5%A4%A9%E7%85%A7/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>有些时候，出题人真的不想写背景（？？？）<br>总而言之，天照现在有一个长度为$N$序列，她有$M$次询问，对于第$i$次询问$l_i,r_i,x_i$你需要回答：<br>$(A_l+x_i)~xor~(A_{l+1}+x_i)~xor \cdots xor~(A_r+x_i)$<br>其中$xor$代表按位异或，我们会用一些手段来保证强制在线</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为两个整数$N,M,type$，代表序列的长度和询问的个数以及数据的类型<br>第二行为$N$个数字，其中第$i$个数字代表$A_i$<br>接下来$M$行，每行代表一个询询问$l_i,r_i,x_i$，其中真实的$l_i,r_i,x_i$需要异或$type \times lastans$，其中$lastans$为上一次询问的答案，初始为$0$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$M$行，代表每次询问的答案。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2 0</span><br><span class="line">1 2 3 4</span><br><span class="line">1 3 1</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于此题，有五个测试点：<br>A（$5$分）$N,M \leqslant 2000$<br>B（$16$分）$type=0,l_i=1,r_i=n$<br>C（$20$分）$type=0$<br>D（$18$分）$l_i=1,r_i=n$<br>E（$41$分）$N,M \leqslant 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于答案的第$k$位（从大到小考虑），大于$k$的位都是没啥用，把$A$和$x$数组大于$k$的位都去掉<br>首先，我们先考虑$x_i=0$的情况<br>如果$x_i=0$，那第$i$位是$1$的数只能是$(100\cdots 0)_2\sim (111\cdots 1)_2$之间，是一段连续的区间<br>接着，我们来考虑$x_i&gt;0$的情况<br>$x_i&gt;0$，那第$i$位是$1$的数还是一段连续的区间，我们可以求出这一段区间的范围<br>所以我们只需要求出$A_{l_i}\sim A_{r_i}$中有多少个数字在这一段区间中<br>用主席树（可持久化线段树）维护$A_i$就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,type,tot,ans,a[<span class="number">100010</span>],root[<span class="number">32</span>][<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HJT</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs;</span><br><span class="line">    <span class="keyword">bool</span> sum;</span><br><span class="line">&#125;t[<span class="number">30000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;t[v].sum=(t[u].sum^<span class="number">1</span>);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) t[v].ls=++tot,t[v].rs=t[u].rs,change(t[u].ls,t[v].ls,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> t[v].rs=++tot,t[v].ls=t[u].ls,change(t[u].rs,t[v].rs,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    t[v].sum=(t[t[v].ls].sum^t[t[v].rs].sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;R||r&lt;L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R) <span class="keyword">return</span> (t[v].sum^t[u].sum);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (ask(t[u].ls,t[v].ls,l,mid,L,R)^ask(t[u].rs,t[v].rs,mid+<span class="number">1</span>,r,L,R));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"amaterasu.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"amaterasu.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;type);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">20</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        root[j][i]=++tot,change(root[j][i<span class="number">-1</span>],root[j][i],<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;(j+<span class="number">2</span>))<span class="number">-1</span>,a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&amp;(<span class="number">1</span>&lt;&lt;j)) a[i]-=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,l,r,x;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;x),l^=(type*ans),r^=(type*ans),x^=(type*ans),ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">20</span>,temp1,temp2;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            temp1=ask(root[j][l<span class="number">-1</span>],root[j][r],<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;(j+<span class="number">2</span>))<span class="number">-1</span>,max((<span class="number">1</span>&lt;&lt;j)-x,<span class="number">0</span>),(<span class="number">1</span>&lt;&lt;(j+<span class="number">1</span>))-x<span class="number">-1</span>);</span><br><span class="line">            temp2=ask(root[j][l<span class="number">-1</span>],root[j][r],<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;(j+<span class="number">2</span>))<span class="number">-1</span>,(<span class="number">1</span>&lt;&lt;(j+<span class="number">1</span>))+(<span class="number">1</span>&lt;&lt;j)-x,(<span class="number">1</span>&lt;&lt;(j+<span class="number">2</span>))-x<span class="number">-1</span>);</span><br><span class="line">            ans+=(temp1^temp2)*(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">if</span>(x&amp;(<span class="number">1</span>&lt;&lt;j)) x-=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3342 工业题</title>
    <url>/2020/07/31/DTOJ3342-%E5%B7%A5%E4%B8%9A%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>ρ</code>有一个函数$f(i,j)$<br>当$i&gt;0$且$j&gt;0$时，有$f(i,j)=f(i,j-1) \times a+f(i-1,j) \times b$<br><code>ρ</code>告诉你了$n,m,a,b,f(i,0)(1 \leqslant i \leqslant n),f(0,i)(1 \leqslant i \leqslant m)$<br><code>ρ</code>也要你告诉他$f(n,m)$<br>不过<code>ρ</code>很善良，他只要知道$f(n,m)<del>mod</del>998244353$<br>这样你就不用打工业的高精度（？？？）</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：四个正整数$n,m,a,b$<br>第二行：$n$个正整数，第$i$个表示$f(i,0)$<br>第三行：$m$个正整数，第$i$个表示$f(0,i)$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行：一个整数，代表$f(n,m)<del>mod</del>998244353$</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4 3 2</span><br><span class="line">1 3 5 7</span><br><span class="line">2 4 6 8</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50807</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$20 \%$的数据：$n,m \leqslant 10,a,b \leqslant 3,f(i,0),f(0,i) \leqslant 10$<br>$50 \%$的数据：$n,m \leqslant 10^3$<br>另外$10 \%$的数据：$n=1$<br>另外$10 \%$的数据：$a=b=1$<br>另外$10 \%$的数据：$f(i,0)=f(0,i)=1$<br>$100 \%$的数据：$n,m \leqslant 3 \times 10^5$，其他所有输入数据均在<code>long long</code>范围内</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>刚看到题目，就让我想到了以前的一道题：<a href="https://blog.csdn.net/weixin_43849488/article/details/102538587" target="_blank" rel="noopener">DTOJ3603 table</a><br>这道题也是一样的道理，只需要计算边界点到这个点的路径条数，再乘以$a$的次方，$b$的次方<br>唯一要注意的点是：边界上是不满足递推式的，所以第一步的方向是确定的<br>通过计算，我们可以得出递推式：<br>$f_{i,0}$的贡献是：$f_{i,0}\times \binom{m-1}{n+m-1-i}\times a^m\times b^{n-i}$<br>$f_{0,i}$的贡献是：$g[i]\times \binom{n-1}{n+m-1-i}\times a^{m-i}\times b^n$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,ans,MOD=<span class="number">998244353</span>,f[<span class="number">600010</span>],g[<span class="number">600010</span>],jc[<span class="number">600010</span>],cj[<span class="number">600010</span>],pa[<span class="number">600010</span>],pb[<span class="number">600010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> jc[y]*cj[x]%MOD*cj[y-x]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("a.in","r",stdin);</span></span><br><span class="line"><span class="comment">//	freopen("a.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lld%lld"</span>,&amp;m,&amp;n,&amp;a,&amp;b),a=a%MOD,b=b%MOD; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;f[i]),f[i]=f[i]%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;g[i]),g[i]=g[i]%MOD;</span><br><span class="line">    jc[<span class="number">0</span>]=pa[<span class="number">0</span>]=pb[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">600000</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">    cj[<span class="number">600000</span>]=POW(jc[<span class="number">600000</span>],MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">599999</span>;i&gt;=<span class="number">0</span>;i--) cj[i]=cj[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> na=POW(a,MOD<span class="number">-2</span>),nb=POW(b,MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">600000</span>;i++) pa[i]=pa[i<span class="number">-1</span>]*a%MOD,pb[i]=pb[i<span class="number">-1</span>]*b%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans=(ans+f[i]*C(n<span class="number">-1</span>,n+m<span class="number">-1</span>-i)%MOD*pa[n]%MOD*pb[m-i]%MOD)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans+g[i]*C(m<span class="number">-1</span>,n+m<span class="number">-1</span>-i)%MOD*pa[n-i]%MOD*pb[m]%MOD)%MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>组合</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3704 威士忌（whiskey）</title>
    <url>/2020/07/31/DTOJ3704-%E5%A8%81%E5%A3%AB%E5%BF%8C%EF%BC%88whiskey%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Alan</code>喝了假威士忌，想问你一个问题：<br><code>nvliu66</code>推荐大家读三本书《百年孤独》、《城市发展史》、《美国大城市的生与死》（？？？）<br>三本书的总页数分别为$p,q,r$<br>现有$n$个<code>nvliu66</code>的粉丝，作为<code>nvliu66</code>的粉丝，想必每本书都至少读过一页，其中第$i$个粉丝读过$a_i$页《百年孤独》、$b_i$页《城市发展史》、$c_i$页《美国大城市的生与死》$(1 \leqslant a_i \leqslant p,1 \leqslant b_i \leqslant q,1 \leqslant c_i \leqslant r)$<br>如果粉丝$x$有不少于两本书阅读过的页数都严格多余粉丝$y$，即当 $a_x&gt;a_y,b_x&gt;b_y,c_x&gt;c_y$ 三个条件中有至少两个成立时，那么称$x$比$y$更“博闻强识”（？？？）<br><code>Alan</code>作为<code>nvliu66</code>的粉丝，也决定去读$a_0$ 页《百年孤独》、$b_0$页《城市发展史》、$c_0$页《美国大城市的生与死》 $(1 \leqslant a_0 \leqslant p,1 \leqslant b_0 \leqslant q,1 \leqslant c_0 \leqslant r)$<br>如果<code>Alan</code>比$n$个粉丝都要博闻强识，那么他就会感到很奴比（？？？）<br><code>Alan</code>想知道自己有多少种不同的读书方案使自己会很奴比，两个读书方案不同当且仅当存在一本书读取的页数不同</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，四个整数$n,p,q,r$<br>接下来$n$行，每行三个整数$a_i,b_i,c_i$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，表示答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 4 5</span><br><span class="line">2 2 5</span><br><span class="line">1 3 4</span><br><span class="line">4 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30 \%$的数据，$n,p,q,r \leqslant 100$<br>对于$60 \%$的数据，$n,p,q,r \leqslant 50000$<br>对于$100 \%$的数据，$n,p,q,r \leqslant 500000$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们先将这些粉丝按$a_i$的大小来排序，然后我们枚举$a_0$的大小，有两种情况：</p>
<ol>
<li>如果$a_i&gt;a_0$，那我们就要要求$b&gt;b_i$并且$c&gt;c_i$，为了方便，我们可以先预处理求出$maxb_i$和$maxc_i$（后缀最大值）</li>
<li>如果$a_i<a_0$，那我们就要要求$b>b_i$或$c&gt;c_i$，所以我们把所有的$(b_i,c_i)$数对转化为直角坐标系上的点，那么$(b_0,c_0)$就不能在任何一个以$(b_i,c_i)$组成的矩形中，又因为这些矩形的并集的$y$是递减的，所以我们就可以用一棵线段树来维护这些矩形的并集的面积</li>
</ol>
<p>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;s[<span class="number">500010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> min,add;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum;</span><br><span class="line">&#125;t[<span class="number">2000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,p,q,r,maxb[<span class="number">500010</span>],maxc[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    t[p*<span class="number">2</span>].add=t[p*<span class="number">2</span>+<span class="number">1</span>].add=t[p*<span class="number">2</span>].min=t[p*<span class="number">2</span>+<span class="number">1</span>].min=t[p].add,t[p*<span class="number">2</span>].sum=(mid-l+<span class="number">1</span>)*t[p].add,t[p*<span class="number">2</span>+<span class="number">1</span>].sum=(r-mid)*t[p].add,t[p].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> (t[p].min&lt;x?l:l+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(t[p].add) spread(p,l,r);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t[p*<span class="number">2</span>].min&lt;x) <span class="keyword">return</span> find(p*<span class="number">2</span>,l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> find(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;t[p].min=t[p].add=d,t[p].sum=(r-l+<span class="number">1</span>)*d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add) spread(p,l,r);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) change(p*<span class="number">2</span>,l,mid,L,R,d);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) change(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R,d);</span><br><span class="line">    t[p].sum=t[p*<span class="number">2</span>].sum+t[p*<span class="number">2</span>+<span class="number">1</span>].sum,t[p].min=min(t[p*<span class="number">2</span>].min,t[p*<span class="number">2</span>+<span class="number">1</span>].min);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R) <span class="keyword">return</span> t[p].sum;</span><br><span class="line">    <span class="keyword">if</span>(t[p].add) spread(p,l,r);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid) ans+=Ask(p*<span class="number">2</span>,l,mid,L,R);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid) ans+=Ask(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=find(<span class="number">1</span>,<span class="number">1</span>,r,b);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=c) <span class="keyword">return</span> <span class="number">1l</span>l*(c-x+<span class="number">1</span>)*b-Ask(<span class="number">1</span>,<span class="number">1</span>,r,x,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"whiskey.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"whiskey.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;p,&amp;q,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s[i].a,&amp;s[i].b,&amp;s[i].c);</span><br><span class="line">    sort(s+<span class="number">1</span>,s+n+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) maxb[i]=max(maxb[i+<span class="number">1</span>],s[i].b),maxc[i]=max(maxc[i+<span class="number">1</span>],s[i].c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Ans=ask(q,r)-ask(maxb[i],r)-ask(q,maxc[i])+ask(maxb[i],maxc[i]);</span><br><span class="line">        ans+=Ans*(s[i].a-s[i<span class="number">-1</span>].a);</span><br><span class="line">        <span class="keyword">int</span> x=find(<span class="number">1</span>,<span class="number">1</span>,r,s[i].b);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=s[i].c) change(<span class="number">1</span>,<span class="number">1</span>,r,x,s[i].c,s[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans+<span class="number">1l</span>l*(p-s[n].a)*ask(q,r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3489 可怜与超市（supermarket）</title>
    <url>/2020/07/31/DTOJ3489-%E5%8F%AF%E6%80%9C%E4%B8%8E%E8%B6%85%E5%B8%82%EF%BC%88supermarket%EF%BC%89/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>九条可怜有$b$块钱，她准备去超市买东西<br>超市有$n$样商品，其中第$i$个商品的价格是$c_i$元，并且每种商品只能购买一次<br>由于可怜是超市的忠实顾客，超市给了可怜$n$张优惠券，其中第$i$张优惠券可以让第$i$样商品的售价减少$d_i$<br>当然，可怜在使用优惠券时必须购买对应的商品<br>但是，优惠券的使用是有条件的<br>具体地，对于$i&gt;1$，使用第$i$张优惠券时必须先使用第$x_i$张优惠券<br>那么，可怜用这$b$块钱最多可以购买多少商品呢？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n,b$<br>接下来$n$行，第$i$行描述第$i$个商品及优惠券</p>
<ul>
<li>若$i=1$，则有两个整数$c_i,d_i$</li>
<li>若$i&gt;1$，则有三个整数$c_i,d_i,x_i$<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>输出一个整数，表示可怜最多可以购买多少商品。<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 16</span><br><span class="line">10 9</span><br><span class="line">10 5 1</span><br><span class="line">12 2 1</span><br><span class="line">20 18 3</span><br><span class="line">10 2 3</span><br><span class="line">2 1 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">3 1</span><br><span class="line">3 1 1</span><br><span class="line">3 1 2</span><br><span class="line">3 1 3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>对于$30\%$的数据，$n\leqslant 20$<br>对于$60\%$的数据，$n\leqslant 300$<br>对于$100\%$的数据，$1 \leqslant n \leqslant 5000,1 \leqslant b \leqslant 10^9,1 \leqslant d_i &lt; c_i \leqslant 10^9,1 \leqslant x_i &lt; i$<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>这道题主要的难点在于处理“使用第$i$张优惠券时必须先使用第$x_i$张优惠券”这个问题<br>这非常容易让我们联想到树，我们把$i$向$x_i$连一条边，就可以构成一棵树<br>然后就很容易想到可以使用树形DP了<br>我们用$f_{i,j,k}$表示第$i$个节点，买了$j$个，用($k=1$)还是没用($k=0$)优惠券<br>简单计算一下，就可以得出递推式：<br>$f_{x,j+k,0}=min(f_{x,j+k,0},f_{x,j,0}+f_{y,k,0})$<br>$f_{x,j+k,1}=min(f_{x,j+k,1},f_{x,j,1}+min(f_{y,k,1},f_{y,k,0}))$<br>（其中，$y$为$x$的子节点）<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,tot,t,ans,a[<span class="number">5010</span>],b[<span class="number">5010</span>],head[<span class="number">5010</span>],nxt[<span class="number">5010</span>],to[<span class="number">5010</span>],size[<span class="number">5010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">5010</span>][<span class="number">5010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,f[x][<span class="number">1</span>][<span class="number">0</span>]=a[x],f[x][<span class="number">1</span>][<span class="number">1</span>]=a[x]-b[x],size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        dfs(to[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=size[x];j&gt;=<span class="number">0</span>;j--) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=size[to[i]];k++)&#123;</span><br><span class="line">            f[x][j+k][<span class="number">0</span>]=min(f[x][j+k][<span class="number">0</span>],f[x][j][<span class="number">0</span>]+f[to[i]][k][<span class="number">0</span>]);</span><br><span class="line">            f[x][j+k][<span class="number">1</span>]=min(f[x][j+k][<span class="number">1</span>],f[x][j][<span class="number">1</span>]+min(f[to[i]][k][<span class="number">1</span>],f[to[i]][k][<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        size[x]+=size[to[i]];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"supermarket.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"supermarket.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;k,&amp;a[<span class="number">1</span>],&amp;b[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i],&amp;b[i],&amp;t),add(t,i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++) f[i][j][<span class="number">0</span>]=f[i][j][<span class="number">1</span>]=<span class="number">1e18</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) <span class="keyword">if</span>(f[<span class="number">1</span>][i][<span class="number">0</span>]&lt;=k||f[<span class="number">1</span>][i][<span class="number">1</span>]&lt;=k)&#123;ans=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3123 最大割cut</title>
    <url>/2020/07/31/DTOJ3123-%E6%9C%80%E5%A4%A7%E5%89%B2cut/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>考虑一张$n$个点的边带权无向图，点从$1\sim n$编号<br>对于图中的任意一个点集(可以为空集或是全集），称所有那些恰好有一个端点在这个点集中的边所组成的边集为割<br>我们再定义一个割的权值为：这个割中所含的所有边边权的异或和<br>现在初始时给定一张n个点的空图，接下来会有若干次加（无向）边操作，每次加边后请你求出当前图中权值最大的割的权值</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数$n,m$表示图的点数与加入的总边数<br>接下来$m$行每行三个正整数$x,y,w$表示加入一条连接$(x,y)$的权值为w的边<br>$x,y$可能相同，两点之间可能会有多条边<br>$w$将以二进制形式从高位向低位给出</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出$m$行，按顺序给出每次加边后当前图中权值最大的割的权值<br>权值也要以二进制形式输出，形式与输入格式中描述的一致</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">1 2 1</span><br><span class="line">1 2 1</span><br><span class="line">3 3 111</span><br><span class="line">1 3 101101</span><br><span class="line">1 2 1011</span><br><span class="line">2 3 111011</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">101101</span><br><span class="line">101101</span><br><span class="line">110000</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>设$l=\log_2{w}$<br><img src="https://img-blog.csdnimg.cn/20200429090501639.png" alt="在这里插入图片描述"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>异或有一个神奇的性质——$a\land a=0$<br>所以，我们可以把边权转化为点权，点权为所有与这个点相连的边的异或和，对于点集内部的边，异或后就消掉了（因为是无向图），剩下的自然就是割的异或和了<br>所以我们可以线性基来计算<br>但是这题有一个很恶心的点——每加一个点就要重新算一遍线性基，如果暴力修改，就算用bitset效率也只有$\Theta(nl^3)$<br>所以我们可以以时间为下标，用线段树分治求答案<br>叶子节点求答案，非叶子节点将权值加入线性基<br><strong>注意：线段树中的bitset必须使用vector，不然就会像我一样，明明对了，却MLE了……</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;1001&gt; Add,ans,ver[<span class="number">501</span>],xxj[<span class="number">1001</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">bitset</span>&lt;1001&gt; &gt; st[<span class="number">4001</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,top1,top2,z1[<span class="number">1001</span>],z2[<span class="number">1001</span>],v[<span class="number">1001</span>],lst[<span class="number">501</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(Add[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])&#123;v[i]=<span class="number">1</span>,xxj[i]=Add;<span class="keyword">return</span> i;&#125;</span><br><span class="line">        <span class="keyword">else</span> Add=Add^xxj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Add[i]==<span class="number">1</span>&amp;&amp;ans[i]!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(Add[i]!=<span class="number">1</span>&amp;&amp;ans[i]==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.reset();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--)<span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">        Add=ans^xxj[i];</span><br><span class="line">        <span class="keyword">if</span>(pd()) ans=Add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[i]&amp;&amp;flag) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans[i]) <span class="built_in">printf</span>(<span class="string">"1"</span>),flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==L&amp;&amp;r==R)&#123;st[p].push_back(Add);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) change(p*<span class="number">2</span>,l,mid,L,R);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid+<span class="number">1</span>&lt;=L) change(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>,l,mid,L,mid),change(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=st[p].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        Add=st[p][i];</span><br><span class="line">        <span class="keyword">int</span> temp=add();</span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="number">-1</span>) z2[++top2]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    z1[++top1]=top2;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">int</span> ls=z1[--top1];</span><br><span class="line">        <span class="keyword">while</span>(top2!=ls) v[z2[top2--]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    ask(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    ask(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> ls=z1[--top1];</span><br><span class="line">    <span class="keyword">while</span>(top2!=ls) v[z2[top2--]]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,ns;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d %s"</span>,&amp;x,&amp;y,s),ns=<span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(x==y) <span class="keyword">continue</span>;</span><br><span class="line">        ans.reset();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=ns<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) ans[ns-j<span class="number">-1</span>]=s[j]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!lst[x]) ver[x]=ans,lst[x]=i;</span><br><span class="line">        <span class="keyword">else</span> Add=ver[x],change(<span class="number">1</span>,<span class="number">1</span>,m,lst[x],i<span class="number">-1</span>),ver[x]^=ans,lst[x]=i;</span><br><span class="line">        <span class="keyword">if</span>(!lst[y]) ver[y]=ans,lst[y]=i;</span><br><span class="line">        <span class="keyword">else</span> Add=ver[y],change(<span class="number">1</span>,<span class="number">1</span>,m,lst[y],i<span class="number">-1</span>),ver[y]^=ans,lst[y]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(lst[i]) Add=ver[i],change(<span class="number">1</span>,<span class="number">1</span>,m,lst[i],m);</span><br><span class="line">    ask(<span class="number">1</span>,<span class="number">1</span>,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3084 置换permutation</title>
    <url>/2020/07/31/DTOJ3084-%E7%BD%AE%E6%8D%A2permutation/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>定义一个置换$P$的平方$Q$为对$[1,2,3,\cdots \cdots,n -1,n]$做两次该置换得到的排列，即$Q_i=P_{p_i}$<br>现在已知一个置换的平方，求该置换</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$表示排列长度<br>第二行$n$个整数表示所求置换的平方</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>若有解则输出一行$n$个数表示原置换（输出任意一个），否则输出$-1$</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2 1 4 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 2 1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$20\%$的数据：$n\leqslant 10$<br>$100\%$的数据：$1\leqslant n\leqslant 10^6$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们先来观察一下置换平方后是什么鬼<br>假设我们有一个置换：$(2,3,1,5,4)$<br>它可以被拆解为两个环：$[2,3,1][5,4]$<br>我们把它平方一下：$(3,1,2,4,5)$<br>发现它可以拆成三个环：$[3,1,2][4][5]$<br>我们发现，如果是一个偶环，平方后就拆开了，如果是一个奇环，就还会是一个奇环<br>得到了这个规律以后，我们就可以处理这道题了<br>先把平方后的结果拆成环，对于偶环，就两两合并，比如$[1,3,5]$和$[2,4,6]$合并为$[1,2,3,4,5,6]$；对于奇环，通过观察，可以发现，我们需要把它拆成两半之后合并，比如$[1,3,2]$拆成$[2,1][3]$合并为$[2,3,1]$（注意，这里的环指的并不是按照置换中的顺序排的，而是按遍历的顺序）<br>最后，对于输出$-1$的情况当然只有一个啦，那就是有奇数个偶环<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,Size,q[<span class="number">1000010</span>],v[<span class="number">1000010</span>],p[<span class="number">1000010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h[<span class="number">1000010</span>],l[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"permutation.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"permutation.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;!v[j];j=q[j]) v[j]=<span class="number">1</span>,s++,h[i].push_back(j);</span><br><span class="line">        l[s].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>((!(i&amp;<span class="number">1</span>))&amp;&amp;(l[i].size()&amp;<span class="number">1</span>))&#123;<span class="built_in">printf</span>(<span class="string">"-1"</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v)),Size=l[<span class="number">1</span>].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Size;i++) p[l[<span class="number">1</span>][i]]=l[<span class="number">1</span>][i]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        Size=l[i].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Size;j++)</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x=h[l[i][j]][<span class="number">0</span>],y=h[l[i][j]][i/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">while</span>(!v[x]) v[x]=v[y]=<span class="number">1</span>,p[x]=y,x=q[x],p[y]=x,y=q[y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x=h[l[i][j]][<span class="number">0</span>],y=h[l[i][j+<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">while</span>(!v[x]&amp;&amp;!v[y]) v[x]=v[y]=<span class="number">1</span>,p[x]=y,x=q[x],p[y]=x,y=q[y];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3085 树tree</title>
    <url>/2020/07/31/DTOJ3085-%E6%A0%91tree/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>有$n$个点，它们从$1$到$n$进行标号，第$i$个点的限制为度数不能超过$A_i$<br>现在对于每个$s(1\leqslant s\leqslant n)$，问从这$n$个点中选出一些点组成大小为$s$的有标号无根树的方案数<br>$mod~1004535809$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$<br>第二行$n$个整数表示$A_i$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行$n$个整数，第$i$个整数表示$s=i$时的答案。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 2</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$20\%$的数据：$n&lt;6$<br>$60\%$的数据：$n\leqslant 50$<br>$100\%$的数据：$n\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>要完成这一题，需要知道一个神奇的数列——prufer数列！<br>每一棵不同的无根树，都对应这不同的prufer数列<br>也就是说，prufer数列和无根树是一一对应的<br>所以我们只需要计算可以组成多少种prufer数列<br>prufer数列有一个神奇的性质——每一个节点出现的次数是它的度数减一<br>这就是我们为什么要使用prufer数列了<br>我们假设计算前$i$个点并且每个点的度数是$D_i$，那么总共就有$\frac{(i-2)!}{\sum \limits_{i=1}^{n}D_i!}$<br>这是一个简单的有限可重全排列<br>我们用$f_{i,j,k}$表示计算前$i$个点，已经选出了$j$个点，序列长度为$k$的方案数除以$(i-2)!$<br>那么，我们就可以进行转移：$f_{i+1,j,k}+=f_{i,j,k},f_{i+1,j+1,k+d}+=f_{i,j,k}\times \frac{1}{d!}$<br>那么，答案就是$f_{n,i,i-2}\times (i-2)!$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD=<span class="number">1004535809</span>,jc[<span class="number">110</span>],ny[<span class="number">110</span>],f[<span class="number">110</span>][<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"tree.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"tree.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),jc[<span class="number">0</span>]=ny[<span class="number">0</span>]=f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),jc[i]=jc[i<span class="number">-1</span>]*i%MOD;</span><br><span class="line">    ny[n]=POW(jc[n],MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i;i--) ny[i]=ny[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;k++) <span class="keyword">if</span>(f[i][j][k])&#123;</span><br><span class="line">        f[i+<span class="number">1</span>][j][k]=(f[i+<span class="number">1</span>][j][k]+f[i][j][k])%MOD;</span><br><span class="line">        <span class="keyword">int</span> len=min(n-k<span class="number">-2</span>,a[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=len;l++) f[i+<span class="number">1</span>][j+<span class="number">1</span>][k+l]=(f[i+<span class="number">1</span>][j+<span class="number">1</span>][k+l]+f[i][j][k]*ny[l]%MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">" %lld"</span>,f[n][i][i<span class="number">-2</span>]*jc[i<span class="number">-2</span>]%MOD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>组合</tag>
        <tag>图论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>通俗易懂的斯特林数介绍</title>
    <url>/2020/04/22/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><a id="more"></a>
<p>将$n$个元素分成$m$个无标号的轮换$\begin{bmatrix}n\\m\end{bmatrix}$<br>什么叫轮换？<br>就是把一堆数放在一个圈上，如果可以通过旋转使得圈上的每个位置上数都和另一个圈上的数是相等的，那么这两个圈等价（意思就是它们是同一个轮换）<br>比如，现在有三个轮换：<br><img src="https://img-blog.csdnimg.cn/2020021616135437.png" alt="在这里插入图片描述"><br>第一个轮换和第二个轮换是等价的，第一个和第三个轮换不是等价的<br>那么，什么叫无标号的轮换？<br>就是如果一堆轮换调换顺序后和另一堆轮换完全相同（所有对应的轮换等价），那么这两堆轮换就是等价的<br>比如，现在有两堆轮换：<br><img src="https://img-blog.csdnimg.cn/20200216163715754.png" alt="在这里插入图片描述"><br>第一堆轮换和第二堆轮换完全相同，是等价的<br>为了让大家更了解第一类斯特林数，我们举一个例子：$\begin{bmatrix}3\\2\end{bmatrix}=3$<br>三种方法如下：<br><img src="https://img-blog.csdnimg.cn/20200216163047456.png" alt="在这里插入图片描述"><br>第一类斯特林数还有另一种定义，就是$\prod \limits_{i=0}^{n-1}(x-i)$的$m$次项系数叫$\begin{bmatrix}n\\m\end{bmatrix}$</p>
<h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>将$n$个元素分成$m$个无标号的集合$\begin{Bmatrix}n\\m\end{Bmatrix}$<br>上面我们已经解释过了无标号的意思，相信大家都知道无标号集合的意思了<br>为了让大家更了解第一类斯特林数，我们举一个例子：$\begin{Bmatrix}3\\2\end{Bmatrix}=3$<br>三种方法如下：</p>
<ol>
<li>$\{\{1\},\{2,3\}\}$</li>
<li>$\{\{2\},\{1,3\}\}$</li>
<li>$\{\{3\},\{1,2\}\}$<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="通项"><a href="#通项" class="headerlink" title="通项"></a>通项</h2>第一类斯特林数貌似没有通项公式（或者是没用或者我太菜了不知道）<br>第二类斯特林数的通项为$\begin{Bmatrix}n\\m\end{Bmatrix}=\frac{1}{m^2}\sum \limits_{i=0}^m(-1)^i\binom{m}{k}(m-i)^n$貌似也没什么用……我不会证……记住就好了<del>我好像也记不住？？？</del><h2 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h2><h3 id="第一类斯特林数-1"><a href="#第一类斯特林数-1" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3>$\begin{bmatrix}n\\m\end{bmatrix}=(n-1)\begin{bmatrix}n-1\\m\end{bmatrix}+\begin{bmatrix}n-1\\m-1\end{bmatrix}$<br>证明：假如$n-1$个元素构成了$m-1$个无标号的轮换，第$n$个元素独自构成一个无标号的轮换，有$\begin{bmatrix}n-1\\m-1\end{bmatrix}$种方法。如果$n-1$个元素构成了$m$个无标号的轮换，将第$n$个元素插入到任意元素的左边，有$(n-1)\begin{bmatrix}n-1\\m\end{bmatrix}$种方法<br>$\therefore \begin{bmatrix}n\\m\end{bmatrix}=(n-1)\begin{bmatrix}n-1\\m\end{bmatrix}+\begin{bmatrix}n-1\\m-1\end{bmatrix}$<h3 id="第二类斯特林数-1"><a href="#第二类斯特林数-1" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3>$\begin{Bmatrix}n\\m\end{Bmatrix}=m\begin{Bmatrix}n-1\\m\end{Bmatrix}+\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$<br>证明：假如$n-1$个元素构成了$m-1$个无标号的集合，第$n$个元素独自构成一个无标号的集合，有$\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$种方法。如果$n-1$个元素构成了$m$个集合，将第$n$个元素插入到任意集合中，有$m\begin{Bmatrix}n-1\\m\end{Bmatrix}$种方法<br>$\therefore \begin{Bmatrix}n\\m\end{Bmatrix}=m\begin{Bmatrix}n-1\\m\end{Bmatrix}+\begin{Bmatrix}n-1\\m-1\end{Bmatrix}$<h2 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h2><h3 id="第一类斯特林数-2"><a href="#第一类斯特林数-2" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h3>$\begin{bmatrix}n\\0\end{bmatrix}=0,\begin{bmatrix}n\\1\end{bmatrix}=1,\begin{bmatrix}n\\n-1\end{bmatrix}=\binom{n}{2},\begin{bmatrix}n\\n\end{bmatrix}=1$<br>自己想吧，太简单了，不证了<h3 id="第二类斯特林数-2"><a href="#第二类斯特林数-2" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h3>$\begin{Bmatrix}n\\0\end{Bmatrix}=0,\begin{Bmatrix}n\\1\end{Bmatrix}=1,\begin{Bmatrix}n\\n-1\end{Bmatrix}=\binom{n}{2},\begin{Bmatrix}n\\n\end{Bmatrix}=1$<br>自己想吧，太简单了，不证了<h2 id="快速幂？？？"><a href="#快速幂？？？" class="headerlink" title="快速幂？？？"></a>快速幂？？？</h2>①$n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}$<br>其中$n^{\underline{i}}$表示$n$的$i$次下降幂，即$n^{\underline{i}}=\prod \limits_{k=0}^{i-1}(n-k)$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}=\begin{Bmatrix}1\\1\end{Bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{k+1}=n\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} n^{\underline{i}}=\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix}\left( n^{\underline{i+1}}+in^{\underline{i}}\right)=\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} n^{\underline{i+1}}+\sum \limits_{i=0}^{k} \begin{Bmatrix}k\\i\end{Bmatrix} in^{\underline{i}}=\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k\\i-1\end{Bmatrix} n^{\underline{i}}+\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k\\i\end{Bmatrix} in^{\underline{i}}=\sum \limits_{i=0}^{k+1} \left(\begin{Bmatrix}k\\i-1\end{Bmatrix}+i\begin{Bmatrix}k\\i\end{Bmatrix}\right) n^{\underline{i}}=\sum \limits_{i=0}^{k+1} \begin{Bmatrix}k+1\\i\end{Bmatrix} n^{\underline{i}}$<br>$\therefore n^m=\sum \limits_{i=0}^{m} \begin{Bmatrix}m\\i\end{Bmatrix} n^{\underline{i}}$<br>②$n^{\overline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i$<br>其中$n^{\overline{m}}$表示$n$的$i$次上升幂，即$n^{\overline{m}}=\prod \limits_{i=0}^{m-1}(n+i)$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i=\begin{bmatrix}1\\1\end{bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{\overline{k+1}}=(n+k)n^{\overline{k}}=n\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} n^i+k\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k\\i-1\end{bmatrix} n^i+\sum \limits_{i=0}^{k+1} k\begin{bmatrix}k\\i\end{bmatrix} n^i=\sum \limits_{i=0}^{k+1} \left(\begin{bmatrix}k\\i-1\end{bmatrix}+k\begin{bmatrix}k\\i\end{bmatrix}\right) n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k+1\\i\end{bmatrix} n^i$<br>$\therefore n^{\overline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} n^i$<br>③$n^{\underline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i$<br>证明：<br>当$m=1$时，$\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i=\begin{bmatrix}1\\1\end{bmatrix} n=n$<br>假设$m=k$时成立<br>当$m=k+1$时，$n^{\underline{k+1}}=(n-k)n^{\underline{k}}=n\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} (-1)^{k-i} n^i-k\sum \limits_{i=0}^{k} \begin{bmatrix}k\\i\end{bmatrix} (-1)^{k-i} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k\\i-1\end{bmatrix} (-1)^{k+1-i} n^i+\sum \limits_{i=0}^{k+1} k\begin{bmatrix}k\\i\end{bmatrix} (-1)^{k+1-i} n^i=\sum \limits_{i=0}^{k+1} \left(\begin{bmatrix}k\\i-1\end{bmatrix}+k\begin{bmatrix}k\\i\end{bmatrix}\right) (-1)^{k+1-i} n^i=\sum \limits_{i=0}^{k+1} \begin{bmatrix}k+1\\i\end{bmatrix} (-1)^{k+1-i} n^i$<br>$\therefore n^{\underline{m}}=\sum \limits_{i=0}^{m} \begin{bmatrix}m\\i\end{bmatrix} (-1)^{m-i} n^i$<h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2>若$f(n)=\sum \limits_{i=1}^n\begin{Bmatrix}n\\i\end{Bmatrix}g(i)$，则$g(n)=\sum \limits_{i=1}^n(-1)^{n-i}\begin{bmatrix}n\\i\end{bmatrix}f(i)$<br>这个$-1$的次数怎么这么熟？<br>是的，这就是上面的③式中$-1$次数<br>可以用斯特林反演说明①式和③式是等价的<br>但是这玩意儿好像没啥用，至少我没用过<del>我就没做过几道斯特林数的题目</del>，所以我也不会证……<br><strong>ps：定义部分从百度百科上的内容删改而成</strong></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2162 magic</title>
    <url>/2020/04/22/DTOJ2162-magic/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>给定一个$n$个点，$m$条边的有向图<br>对于任意一个点$i$，都有两个权值$a_i,b_i$<br>你可以花费$b_i$的费用将这个点的$a_i$变成$0$<br>另外对于圈中的每个点你需要付出$wi=Max(i,j)\in E~aj$<br>请最小化所有费用之和</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数$n$，$m$<br>接下来一行$n$个数，表示$a_i$<br>接下来一行$n$个数，表示$b_i$<br>接下来$m$行，每行$2$个数$i,j$，表示一行$(i,j)$的边</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个数，表示最小化的费用</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">100000 10000</span><br><span class="line">100000 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>最优的方案是花费$1$的费用将$a_2$变成$0$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30\%$的数据，$n\leqslant 20$<br>对于$100\%$的数据，$n\leqslant 1000,m\leqslant 50000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>奇奇怪怪的建图、跑网络流方法……<br>对于原图中的每一个点，建$i$的出度个点，把这些点和终点连上流量为$b_i$的边，然后把这些个点按$a_i$的值从小到大排序<br>然后搞个差分，再在这些个点之间连上流量为<code>inf</code>的边<br>最后跑一个网络流就可以啦！<br><strong>注意，DFS中的取地址符非常重要，去掉了之后会超时，虽然我也不知道为啥<del>反正就是加了就过了</del>，因为我平常些Dinic的时候也不加这个取地址符</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,h;</span><br><span class="line">&#125;temp[<span class="number">200010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,ver;</span><br><span class="line">&#125;e[<span class="number">400010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t[<span class="number">200010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,S,T,tot=<span class="number">1</span>,len,ans,a[<span class="number">1010</span>],b[<span class="number">1010</span>],u[<span class="number">50010</span>],v[<span class="number">50010</span>],head[<span class="number">200010</span>],Head[<span class="number">200010</span>],d[<span class="number">200010</span>],vis[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X=<span class="number">0</span>; <span class="keyword">bool</span> flag=<span class="number">1</span>; <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>) flag=<span class="number">0</span>; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">'0'</span>; ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line">    <span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(ppap1 a,ppap1 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].to=v,e[tot].ver=w;</span><br><span class="line">    e[++tot].nxt=head[v],head[v]=tot,e[tot].to=u,e[tot].ver=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++) d[i]=<span class="number">1e9</span>;</span><br><span class="line">    d[S]=<span class="number">0</span>,q.push(S);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop(),Head[x]=head[x];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(d[e[i].to]&gt;d[x]+<span class="number">1</span>&amp;&amp;e[i].ver&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            d[e[i].to]=d[x]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!vis[e[i].to]) vis[e[i].to]=<span class="number">1</span>,q.push(e[i].to);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[T]!=<span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Flow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==T||(!Flow)) <span class="keyword">return</span> Flow;</span><br><span class="line">    <span class="keyword">int</span> k,flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> &amp;i=Head[x];i;i=e[i].nxt) <span class="keyword">if</span>(d[e[i].to]==d[x]+<span class="number">1</span>&amp;&amp;(k=dfs(e[i].to,min(e[i].ver,Flow)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        e[i].ver-=k,e[i^<span class="number">1</span>].ver+=k,Flow-=k,flow+=k;</span><br><span class="line">        <span class="keyword">if</span>(!Flow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    S=<span class="number">200002</span>,T=S+<span class="number">1</span>,len=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i]=read(),add(i,T,b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) u[i]=read(),v[i]=read(),t[u[i]].push_back(v[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,size;i&lt;=n;i++)&#123;</span><br><span class="line">        size=t[i].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++) temp[j].h=t[i][j],temp[j].v=a[t[i][j]];</span><br><span class="line">        sort(temp,temp+size,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>,tem;j&lt;size;j++)&#123;</span><br><span class="line">            tem=++len;</span><br><span class="line">            <span class="keyword">if</span>(!j) add(S,tem,temp[j].v);</span><br><span class="line">            <span class="keyword">else</span> add(S,tem,temp[j].v-temp[j<span class="number">-1</span>].v),add(tem<span class="number">-1</span>,tem,<span class="number">1e9</span>);</span><br><span class="line">            add(tem,temp[j].h,<span class="number">1e9</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(bfs()) ans+=dfs(S,<span class="number">1e9</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2161 Christmas</title>
    <url>/2020/04/22/DTOJ2161-Christmas/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>给出一个长度为$n$的整数序列。你的程序需要依次完成如下操作：</p>
<ol>
<li>$A~a~b~c$：将区间$[a,b]$中的每个数加上$c$</li>
<li>$M~a~b~c$: 对区间$[a,b]$中的每个数$x$，令$x=max(x,c)$</li>
<li>$Q~a$：求序列第$a$个数的值是多少，以及这个值在之前的询问中改变了多少次，你的程序需要输出这两个值<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>第一行输入一个数$n$，表示序列的长度<br>接下来一行$n$个数，表示最开始的序列<br>接下来一行输入一个数$m$，表示操作个数<br>接下来$m$行，每行一个询问，其中操作的形式如试题描述（参考样例）<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>对于每个询问输出两个数，分别为那个数的值，以及那个数被修改了多少次<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">5</span><br><span class="line">A 1 2 4</span><br><span class="line">M 2 3 5</span><br><span class="line">Q 1</span><br><span class="line">Q 2</span><br><span class="line">Q 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1</span><br><span class="line">6 1</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>
<h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3>第一个操作后序列变成了$5,6,3$<br>第二次操作后序列变成了$5,6,5$<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>对于$30\%$的数据，$n,m \leqslant 10000$<br>对于另外$30\%$的数据，操作中的值均随机生成的<br>对于$100\%$的数据，$n,m \leqslant 10^5$<br>操作过程中所有数字在<code>int</code>范围内<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>我太菜了，只会分块……<br>这道题使用分块非常简单，代码超短（比如我的代码就是最短的），内存也很小（我的内存也是最小的），但是贼慢，跑了$3008ms$（居然还是第8名）<br>首先我们规定一些变量：$x_i$表示数值，$opt_i$表示操作次数，$xadd_i$表示数值的<code>lazy</code>标志，$optadd_i$表示操作次数的<code>lazy</code>标志，二维数组$q_{i,j}$表示第$i$块中，针对$M~a~b~c$操作的<code>lazy</code>标志，保证一维数组$q_i$中的数值单调递增，$l_i$表示一维数组$q_i$的长度<br>对于$A~a~b~c$操作，如果$a$和$b$在同一块中，那么就直接下传标记，直接暴力修改即可<br>如果$a$和$b$不在同一个块中，$a$和$b$所在的块中一样下传标记然后暴力修改，中间的直接$xadd_i+=c,optadd_i++$就可以了<br>对于$M~a~b~c$操作，如果$a$和$b$在同一块中，那么就直接下传标记，直接暴力修改即可<br>如果$a$和$b$不在同一个块中，$a$和$b$所在的块中一样下传标记然后暴力修改，对于中间的每一段，如果$c-add_i&gt;q_{i,l_i}$（因为如果小于就没有存储的必要了），就执行$q_{i,++l_i}=c-add_i$<br>值得一提的是，因为谁也不知道$l_i$等于几，所以当$l_i&gt;1000$时，我们就下传一下标记，清空$q_i$数组<br>对于$Q~a$，就直接下传标记然后输出$x_i$和$opt_i$即可<br>但是，整个程序的核心——下传标记还没有讲呢！<br>对，下面，我们就来讲讲这个函数<br>假设我们需要下传第$k$段的内容，那么，常规操作就是$x_i+=xadd_k,opt_i+=optadd_k$，但是我们还需要下传$q_i$呢！<br>我们首先找出比$x_i$大的$q_{k,j}$设它的下标为$(k,temp)$（因为数组中的值是单调递增的，所以直接使用<code>upper-bound</code>即可），如果没有这个$temp$，那就直接正常下传就好了，但是如果有，就说明这个数需要更新成$c$，并且操作次数要加上$l_k-temp+1$（因为单调递增，这个$c-add_k$更新了，后面的肯定都要更新）<br>听起来很难理解，看看代码实现吧！<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,d,x[<span class="number">100010</span>],opt[<span class="number">100010</span>],add[<span class="number">330</span>],Add[<span class="number">330</span>],q[<span class="number">330</span>][<span class="number">1010</span>],l[<span class="number">330</span>];</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;b;i++) x[i]+=c,opt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a;i&lt;b;i++) <span class="keyword">if</span>(x[i]&lt;c) x[i]=c,opt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=d*k,temp;i&lt;d*k+d;i++)&#123;</span><br><span class="line">    	temp=upper_bound(q[k]+<span class="number">1</span>,q[k]+l[k]+<span class="number">1</span>,x[i])-q[k];</span><br><span class="line">    	<span class="keyword">if</span>(temp&lt;=l[k]) x[i]=q[k][l[k]],opt[i]+=l[k]-temp+<span class="number">1</span>;</span><br><span class="line">    	opt[i]+=Add[k],x[i]+=add[k];</span><br><span class="line">    &#125;</span><br><span class="line">    l[k]=add[k]=Add[k]=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n,d=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++) q[i][<span class="number">0</span>]=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c;i&lt;=m;i++)&#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;op&gt;&gt;a,a--;</span><br><span class="line">    	<span class="keyword">if</span>(op==<span class="string">'A'</span>)&#123;</span><br><span class="line">    		<span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c,b--;</span><br><span class="line">    		<span class="keyword">if</span>(!c) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">if</span>(a/d==b/d)&#123;spread(a/d),change1(a,b+<span class="number">1</span>,c);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            spread(a/d),change1(a,(a/d+<span class="number">1</span>)*d,c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a/d+<span class="number">1</span>;i&lt;b/d;i++) add[i]+=c,Add[i]++;</span><br><span class="line">            spread(b/d),change1((b/d)*d,b+<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">'M'</span>)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c,b--;</span><br><span class="line">            <span class="keyword">if</span>(a/d==b/d)&#123;spread(a/d),change2(a,b+<span class="number">1</span>,c);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            spread(a/d),change2(a,(a/d+<span class="number">1</span>)*d,c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=a/d+<span class="number">1</span>;i&lt;b/d;i++)&#123;</span><br><span class="line">        		<span class="keyword">if</span>(c-add[i]&gt;q[i][l[i]]) q[i][++l[i]]=c-add[i];</span><br><span class="line">        		<span class="keyword">if</span>(l[i]&gt;<span class="number">1000</span>) spread(i);</span><br><span class="line">            &#125;</span><br><span class="line">            spread(b/d),change2((b/d)*d,b+<span class="number">1</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> spread(a/d),<span class="built_in">cout</span>&lt;&lt;x[a]&lt;&lt;<span class="string">" "</span>&lt;&lt;opt[a]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2444 祖玛</title>
    <url>/2020/04/22/DTOJ2444-%E7%A5%96%E7%8E%9B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>祖玛是一款曾经风靡全球的游戏，其玩法是：在一条轨道上初始排列着若干个彩色珠子，其中任意三个相邻的珠子不会完全同色<br>此后，你可以发射珠子到轨道上并加入原有序列中<br>一旦有三个或更多同色的珠子变成相邻，它们就会立即消失<br>这类消除现象可能会连锁式发生，其间你将暂时不能发射珠子<br><img src="https://img-blog.csdnimg.cn/20200422112913278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>开发商最近准备为玩家写一个游戏过程的回放工具<br>他们已经在游戏内完成了过程记录的功能，而回放功能的实现则委托你来完成<br>游戏过程的记录中，首先是轨道上初始的珠子序列，然后是玩家接下来所做的一系列操作<br>你的任务是，在各次操作之后及时计算出新的珠子序列</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个由大写字母<code>A~Z</code>组成的字符串，表示轨道上初始的珠子序列，不同的字母表示不同的颜色<br>第二行是一个数字$n$，表示整个回放过程共有$n$次操作<br>接下来的$n$行依次对应于各次操作<br>每次操作由一个数字k和一个大写字母$\Sigma$描述，以空格分隔。其中，$\Sigma$为新珠子的颜色<br>若插入前共有$m$颗珠子，则$k\in [0,m]$表示新珠子嵌入之后（尚未发生消除之前）在轨道上的位序</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$n$行，依次给出各次操作（及可能随即发生的消除现象）之后轨道上的珠子序列<br>如果轨道上已没有珠子，则以<code>-</code>表示。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ACCBA</span><br><span class="line">5</span><br><span class="line">1 B</span><br><span class="line">0 A</span><br><span class="line">2 B</span><br><span class="line">4 C</span><br><span class="line">0 A</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ABCCBA</span><br><span class="line">AABCCBA</span><br><span class="line">AABBCCBA</span><br><span class="line">-</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$100 \%$的数据满足$1 \leqslant n \leqslant 10^3,1 \leqslant m \leqslant 2 \times 10^3$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>太TMD坑了，初始的珠子序列居然可以是<strong>空串！空串！空串！</strong><br>考试使用<code>scanf</code>的我差点气死，本来可以第一名的……<br>这道题其实很简单，插入的时候使用<code>strcpy</code>直接插入，再判断一下插入后是否有连续的$3$个相同的字母<br>因为每次插入以后只改变插入的位置的字母，所以只需要判断插入的位置旁边是否有连续的$3$个的相同字母<br>因为有可能有连锁反应，所以修改后将当前的位置设为插入的位置前和插入的位置的颜色相同的位置<del>我自己都被绕晕了</del><br>然后使用<code>while</code>即可<br>具体的实现看代码吧<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,ns,x;</span><br><span class="line"><span class="keyword">char</span> c,s[<span class="number">2010</span>],temp[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xc</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f=p,l=p;</span><br><span class="line">    <span class="keyword">while</span>(s[f]==s[p]&amp;&amp;f) f--;</span><br><span class="line">    <span class="keyword">if</span>(f||s[f]!=s[p]) f++;</span><br><span class="line">    <span class="keyword">while</span>(s[l]==s[p]&amp;&amp;l&lt;ns) l++;</span><br><span class="line">    <span class="keyword">if</span>(l-f&gt;<span class="number">2</span>)&#123;<span class="built_in">strcpy</span>(temp,s+l),<span class="built_in">strcpy</span>(s+f,temp),ns=ns+f-l,x=f;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gets(s);</span><br><span class="line">    ns=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>,&amp;x,&amp;c);</span><br><span class="line">        <span class="built_in">strcpy</span>(temp,s+x),<span class="built_in">strcpy</span>(s+x+<span class="number">1</span>,temp),s[x]=c,ns++;</span><br><span class="line">        <span class="keyword">while</span>(xc(x)&amp;&amp;ns);</span><br><span class="line">        <span class="keyword">if</span>(ns) <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,s);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3373 约会</title>
    <url>/2020/04/20/DTOJ3373-%E7%BA%A6%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Vincent</code>和他的大学<code>GF</code>不在同一个院系中，但他们每天都要约在校园中的同一个地方见面<br><code>THU</code>的地图可以抽象为一个$n$个结点的一棵树，即有$n$个地点，$n-1$条无向边，每条边的长度为$1$，任意两个地点之间是连通的<del>树还能不连通！？</del><br>由于每天的课程不同，他们每天所在的位置也不同，第$i$天，<code>Vincent</code>在地点$x_i$，他的<code>GF</code>在地点$y_i$<br>由于不能让某一方走的路程过多，所以他们约会的地点有个要求，必须与两人的位置之间的距离相等，距离指在树上的最短路径<br>请你帮<code>Vincent</code>算算每天他们有多少种可选的约会地点</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$<br>接下来$n-1$行，每行两个整数$u$和$v$，表示树上有一条$u$和$v$之间的边<br>接下来一行一个整数$m$，表示他们有$m$天要约会见面<br>接下来$m$行，每行两个整数$x_i,y_i$，表示第$i$天，他们各自的位置</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一天，输出一行一个整数，表示第$i$天可行的约会地点有多少个</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>约会地点$1$是可行的</p>
<h3 id="数据范围及约定"><a href="#数据范围及约定" class="headerlink" title="数据范围及约定"></a>数据范围及约定</h3><p>对于$25 \%$的数据，$n,m \leqslant 100$<br>对于$50 \%$的数据，$n,m \leqslant 10^3$<br>另外存在$20 \%$的数据，树是一条链<br>另外存在$15 \%$的数据，树是随机生成的<br>对于$100 \%$的数据，$n,m \leqslant 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，以编号为$1$的点为根<br>对于一组询问$x,y$，如果$x$的深度小于$y$，那就交换他们的顺序<br>接着，求出它们的LCA，就可以求出链的长度<br>如果链的长度是偶数，那就没有中点，答案是$0$<br>如果链的长度是奇数，就求出链的中点<br>如果中点是它们的LCA，那么深度比LCA小的节点和不包含$x$和$y$的LCA的子树是可行的约会地点<br>若中点不是LCA，那么深度小于中点的点都不是可行的约会地点，深度大于中点的节点用类似于上面的求法求出来就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,head[<span class="number">100010</span>],nxt[<span class="number">200010</span>],to[<span class="number">200010</span>],dep[<span class="number">100010</span>],Fa[<span class="number">100010</span>][<span class="number">25</span>],size[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[a],head[a]=tot,to[tot]=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=dep[fa]+<span class="number">1</span>,size[x]=<span class="number">1</span>,Fa[x][<span class="number">0</span>]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) Fa[x][i]=Fa[Fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]^fa) dfs(to[i],x),size[x]+=size[to[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;~i;i--) <span class="keyword">if</span>(dep[Fa[x][i]]&gt;=dep[y]) x=Fa[x][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;~i;i--) <span class="keyword">if</span>(Fa[x][i]^Fa[y][i]) x=Fa[x][i],y=Fa[y][i];</span><br><span class="line">    <span class="keyword">if</span>(x^y) <span class="keyword">return</span> Fa[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;~i;i--) <span class="keyword">if</span>(y&gt;&gt;i&amp;<span class="number">1</span>) x=Fa[x][i];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,add(x,y),add(y,x);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>),<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,len,LCA;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">        LCA=lca(x,y),len=dep[x]+dep[y]<span class="number">-2</span>*dep[LCA];</span><br><span class="line">        <span class="keyword">if</span>(len&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> mid=find(x,len);</span><br><span class="line">            <span class="keyword">if</span>(mid==x) <span class="built_in">cout</span>&lt;&lt;n;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid==LCA) <span class="built_in">cout</span>&lt;&lt;size[<span class="number">1</span>]-size[find(x,len<span class="number">-1</span>)]-size[find(y,len<span class="number">-1</span>)];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;size[mid]-size[find(x,len<span class="number">-1</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3311 寻找</title>
    <url>/2020/04/20/DTOJ3311-%E5%AF%BB%E6%89%BE/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>“我有个愿望，我希望穿越一切找到你”<br>这是个二维平面世界，平面上有$n$个特殊的果实，我从$(0,0)$点出发，希望得到尽量多的果实，但是出于某种特殊的原因，我的运动方式只有三种（假设当前我在$(x,y)$）：</p>
<ol>
<li>我可以走到$(x+1,y)$</li>
<li>我可以走到$(x,y+1)$</li>
<li>我可以走到$(x+1,y+1)$</li>
</ol>
<p>现在我需要你的帮助，帮我找出我最多能够得到多少个果实</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$表示有多少个被标记的点<br>接下来$n$行每行两个整数$x,y$表示一个点的坐标</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数表示答案，表示我最多能够得到多少个果实</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">-2 -1</span><br><span class="line">-2 -3</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 2</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>样例输入的点如图所示：<br><img src="https://img-blog.csdnimg.cn/20200420101030935.png" alt="在这里插入图片描述"></p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$70 \%$的数据$1 \leqslant n \leqslant 10^3$<br>对于$100 \%$的数据$1 \leqslant n \leqslant 10^5,-10^9 \leqslant x,y \leqslant 10^9$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然，只有在第一象限、$x$轴和$y$轴的正半轴或者原点上的点可以到达<br>所以去掉不是第一象限、$x$轴和$y$轴的正半轴或者原点上的点，把剩下的点按照$x$坐标排序，求$y$坐标的最长上升子序列即可<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;a[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n,len,ans,lcs[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        a[++len].x=x,a[len].y=y;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+len,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].x&gt;=lcs[ans]) lcs[++ans]=a[i].x;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=lower_bound(lcs+<span class="number">1</span>,lcs+<span class="number">1</span>+ans,a[i].x)-lcs;</span><br><span class="line">            lcs[temp]=a[i].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3302 星座</title>
    <url>/2020/04/20/DTOJ3302-%E6%98%9F%E5%BA%A7/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>为了探索我们头顶那美丽的星空，伟大的<code>C</code>学给了我们一张星图，这张星图可以看做一个平面，其中包含了$n$颗星星，每颗星星可以用平面上的一个点来表示，<code>C</code>学告诉我们这张星图中包含着多种神奇的$\alpha - \beta - \gamma$星座，这些星座在平面内构成了很多平行四边形，它们的都有一组边长为$\gamma$的对边平行于$x$轴，且另一组对边平行于一斜率为$\frac{\beta}{\alpha}$的直线，现在<code>C</code>学给了我们若干组询问，每组询问包含$3$个整数$\alpha,\beta,\gamma$，对于每组询问请你求出$x$轴上方和下方中$\alpha - \beta - \gamma$星座的个数 (平行四边形不能与$x$轴有相交的部分)</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第$1$行$2$个正整数$n,m$表示星星的个数和询问的个数$(4 \leqslant n \leqslant 100,000,1 \leqslant m \leqslant 10)$<br>第$2 \sim n+1$行每行$2$个整数$x,y$表示每颗星星的横纵坐标$(-1,000 \leqslant x,y \leqslant 1,000)$(数据保证不会有两颗星星在同一个位置)<br>第$n+2 \sim n+m+1$行每行$3$个整数$\alpha,\beta,\gamma(1 \leqslant \alpha \leqslant 2,000,-2,000 \leqslant \beta \leqslant 2,000,1 \leqslant \gamma \leqslant 2,000)$(当$\beta=0$时，表示一条平行于 y轴的直线)</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$m$行<br>每行两个整数，表示$x$轴上方满足条件星座个数和$x$轴下方满足条件星座个数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 1</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">1 -1</span><br><span class="line">2 -1</span><br><span class="line">1 -2</span><br><span class="line">2 -2</span><br><span class="line">1 0 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看看这个坐标这么小，它不香吗？<br>我们用$v_{x,y}$表示$(x,y)$有没有点<br>算出有几条边平行$x$轴，然后每条边选择左边那个点<br>算出斜率投影到$x$轴上得到一个坐标，这个坐标相同的两条边可以组合成一个平行四边形（就是横截距相同而且斜率相同的直线只有一条）<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,len1,len2,ans1,ans2,x[<span class="number">100010</span>],y[<span class="number">100010</span>],v[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">double</span> eps=<span class="number">1e-7</span>,d1[<span class="number">100010</span>],d2[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x[i],&amp;y[i]),v[x[i]+<span class="number">1000</span>][y[i]+<span class="number">1000</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,c,s;i&lt;=m;i++)&#123;</span><br><span class="line">        ans1=ans2=len1=len2=s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(x[i]+c&lt;=<span class="number">1000</span>&amp;&amp;v[x[i]+<span class="number">1000</span>+c][y[i]+<span class="number">1000</span>])&#123;</span><br><span class="line">    		<span class="keyword">if</span>(y[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                d1[++len1]=x[i];</span><br><span class="line">                <span class="keyword">if</span>(b) d1[len1]-=<span class="number">1.0</span>*a*y[i]/b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                d2[++len2]=x[i];</span><br><span class="line">                <span class="keyword">if</span>(b) d2[len2]-=<span class="number">1.0</span>*a*y[i]/b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(d1+<span class="number">1</span>,d1+<span class="number">1</span>+len1),sort(d2+<span class="number">1</span>,d2+<span class="number">1</span>+len2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len1;++i)</span><br><span class="line">            <span class="keyword">if</span>(d1[i]-d1[i<span class="number">-1</span>]&lt;=eps) ++s;</span><br><span class="line">            <span class="keyword">else</span> ans1+=s*(s+<span class="number">1</span>)/<span class="number">2</span>,s=<span class="number">0</span>;</span><br><span class="line">        ans1+=s*(s+<span class="number">1</span>)/<span class="number">2</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len2;++i)</span><br><span class="line">            <span class="keyword">if</span>(d2[i]-d2[i<span class="number">-1</span>]&lt;=eps) ++s;</span><br><span class="line">            <span class="keyword">else</span> ans2+=s*(s+<span class="number">1</span>)/<span class="number">2</span>,s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ans1,ans2+s*(s+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3308 从今以后</title>
    <url>/2020/04/16/DTOJ3308-%E4%BB%8E%E4%BB%8A%E4%BB%A5%E5%90%8E/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小果有一个数列<br>定义这个数列是合法的，指对于这个数列的每个子序列，都存在一个元素在在这个子序列中，只出现了一次<br>请帮小果判断这个数列是否合法</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$T$，表示数据组数<br>接下来$T$组数据，每组数据第一行有一个整数$n$，表示该组数据的序列长度，之后一行有$n$个非负整数$a_i$，表示该序列中每个元素的值</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$T$行，每行为<code>yes</code>或者<code>no</code>，表示这个序列合法或不合法</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5</span><br><span class="line">1 1 1 1 1</span><br><span class="line">5</span><br><span class="line">1 2 3 2 1</span><br><span class="line">5</span><br><span class="line">1 1 2 1 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yes</span><br><span class="line">no</span><br><span class="line">yes</span><br><span class="line">no</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据$\sum n \leqslant 5000$<br>对于$100\%$的数据$\sum n \leqslant 2 \times 10^6,n \leqslant 2 \times 10^5$<br>所有的$a_i$满足$0 \leqslant a_i \leqslant 10^9$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我的方法比较奇怪，如果你想看常规方法，可以看看<a href="https://blog.csdn.net/CSDNzhanghongyu/article/details/105522023" target="_blank" rel="noopener">这个神犇的博客</a><br>首先，先离散化，没啥好说的吧<br>接着，我们计算出$pre_i$和$nxt_i$分别表示前一个值为$a_i$的位置的下标和后一个值为$a_i$的位置的下标（也就是$a_{pre_i}=a_i$且$\forall j\in(pre_i,i),a_j\neq a_i$，$a_{nxt_i}=a_i$且$\forall j\in(i,nxt_i),a_j\neq a_i$）<br>所以，$\forall l\in (pre_i,i],r\in[i,nxt_i)$，区间$[l,r]$是合法的<br>所以，我们只需要找到这个区域内只出现一次的数，然后分别把数列从这个数劈成两半，分别考虑两个数列，如果都是合法的，那么这个数列就是合法的，进行递归即可<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a[<span class="number">200010</span>],A[<span class="number">200010</span>],pre[<span class="number">200010</span>],nxt[<span class="number">200010</span>],q[<span class="number">200010</span>],h[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dg</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(r-l)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=mid;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[l+i]&lt;l&amp;&amp;nxt[l+i]&gt;r) <span class="keyword">return</span> (dg(l,l+i<span class="number">-1</span>)&amp;&amp;dg(l+i+<span class="number">1</span>,r));</span><br><span class="line">        <span class="keyword">if</span>(pre[r-i]&lt;l&amp;&amp;nxt[r-i]&gt;r) <span class="keyword">return</span> (dg(l,r-i<span class="number">-1</span>)&amp;&amp;dg(r-i+<span class="number">1</span>,r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],A[i]=a[i],pre[i]=nxt[i]=<span class="number">0</span>;</span><br><span class="line">        sort(A+<span class="number">1</span>,A+n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len=unique(A+<span class="number">1</span>,A+n+<span class="number">1</span>)-(A+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=lower_bound(A+<span class="number">1</span>,A+len+<span class="number">1</span>,a[i])-A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) q[i]=<span class="number">0</span>,h[i]=n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i]=q[a[i]],q[a[i]]=i,nxt[n-i+<span class="number">1</span>]=h[a[n-i+<span class="number">1</span>]],h[a[n-i+<span class="number">1</span>]]=n-i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(dg(<span class="number">1</span>,n)?<span class="string">"yes"</span>:<span class="string">"no"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3303 W的火星工程</title>
    <url>/2020/04/16/DTOJ3303-W%E7%9A%84%E7%81%AB%E6%98%9F%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>大老板<code>W</code>的伟大工程扩大到了火星，他准备在火星建立一个自己的度假村<br>在他的度假村里，有两个大饭店<code>A</code>,<code>B</code><br>对于<code>W</code>来说，修建度假村必不可少的就是从<code>A</code>饭店向<code>B</code>饭店修路,以保证他可以短时间内享受各种美味<br>火星上有一些中转站，中转站之间以及它们与饭店之间有路径使得能从一个到达另一个（路径为单向）<br>对于每一条路径，工程师<code>ZQ</code>给出了它的两个消费参数$a,b$<br><code>W</code>会从<code>A</code>饭店出发，经过其中的一些路径，最终到达<code>B</code>饭店<br><code>W</code>希望他走过的所有道路的$\frac{\sum{a}}{\sum{b}}$最小，也就是那些道路的$a$值之和除以他们的$b$值之和最小<br>可是路径实在太多了，<code>W</code>不知道该如何选择<br>聪明的你需要帮助他计算出这个最小值<br>至于路径的选取方法你就不需要告诉他了</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个整数$n,m$，表示中转站的数量和边的数量<br>随后$m$行，每行四个整数$x,y,a,b$，分别表示路径的两端，路径的$a,b$消费参数<br>其中$0$号点与$n+1$号点分别表示<code>W</code>的两个饭店<code>A</code>，<code>B</code><br>注意你并不需要把所有中转站都连入路中，只要保证从<code>A</code>饭店可以到达<code>B</code>饭店就行了</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个小数，表示所求的最小值。误差不超过$10^{-6}$即可</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">0 1 1 2</span><br><span class="line">0 2 2 3</span><br><span class="line">1 3 1 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.400000</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$20 \%$的数据，$n,m \leqslant 100$<br>对于$50 \%$的数据，$n \leqslant 1000$<br>对于$100 \%$的数据， $1 \leqslant n \leqslant 10000,1 \leqslant m \leqslant 100,000,0 \leqslant x,y \leqslant n+1$<br>数据保证$0$号饭店可以到达$n+1$号饭店，任意两个中转站或饭店间最多有一条边，且保证没有路可以构成环</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>0/1分数规划裸题<br>考虑二分答案，记$dis_i$表示从0到i的路径$\sum a_i-b_i\times mid$的最小值，用类似最短路的方法更新，判断一下$dis_{n+1}$的值是否大于$0$，更改二分的范围<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,tot,nxt[<span class="number">100010</span>],head[<span class="number">10010</span>],to[<span class="number">100010</span>],a[<span class="number">100010</span>],b[<span class="number">100010</span>],v[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">double</span> L,R=<span class="number">1e9</span>,w[<span class="number">100010</span>],dis[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">2</span>;i++) dis[i]=<span class="number">1e9</span>,v[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) w[i]=(<span class="keyword">double</span>)a[i]-(<span class="keyword">double</span>)b[i]*x;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>,q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q.front();</span><br><span class="line">        q.pop(),v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(dis[to[i]]&gt;dis[x]+w[i])&#123;</span><br><span class="line">            dis[to[i]]=dis[x]+w[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[to[i]]) q.push(to[i]);</span><br><span class="line">            v[to[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[n+<span class="number">1</span>]&gt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;u,&amp;v,&amp;a[i],&amp;b[i]),add(u,v);</span><br><span class="line">    <span class="keyword">while</span>(L+<span class="number">0.000000001</span>&lt;R)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(L+R)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(pd(mid)) L=mid;</span><br><span class="line">        <span class="keyword">else</span> R=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>数学</tag>
        <tag>最短路</tag>
        <tag>01分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3026 geronimo</title>
    <url>/2020/04/16/DTOJ3026-geronimo/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>“Geronimo∼”<br>时间还很多，让我们慢慢来。<br>不如听首开心的歌再看题？……算了，直接看题吧<br>给定一个整数$n$，以及一个$n$阶的排列$p_1,p_2,…,p_n$<br>我们定义重组过程如下：如果当前的排列是$a_1,a_2,…,a_n$，经过一次重组，就会变成$p_{a_1},p_{a_2},…,p_{a_n}$<br>问一个排列至少要经过多少次重组才会恢复成重组前的状态<br>由于答案可能很大，输出其对一个给定的正整数$q$取模的值即可</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数$n,q$<br>第二行一共$n$个整数，依次表示$p_1,p_2,…,p_n$<br>同一行相邻的数间用一个空格隔开</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示答案对$q$取模的值</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 1000000207</span><br><span class="line">2 6 5 1 3 4 7</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于全部的数据，$q\leqslant 2\times 10^9$<br>对于$10\%$的数据，$q=1$<br>对于另外$20\%$的数据，$n\leqslant 9$<br>对于另外$40\%$的数据，$n\leqslant 10^3$<br>对于剩下$30\%$的数据，$n\leqslant 5\times 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>先求出每一个点要循环几次才能回到原位，然后直接去一个LCM就好了<br><strong>不能用传统的GCD，因为需要取模！必须用唯一分解定理</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,MOD,s,maxs,a[<span class="number">500010</span>],f[<span class="number">500010</span>],sum[<span class="number">500010</span>],p[<span class="number">500010</span>],v[<span class="number">500010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>,P[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]) <span class="keyword">continue</span>;</span><br><span class="line">        x=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[x]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(!f[x]) f[x]=j;</span><br><span class="line">            <span class="keyword">else</span> sum[x]=j-f[x];</span><br><span class="line">            x=a[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) maxs=max(maxs,sum[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxs;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        p[++s]=i,P[s]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=maxs;j+=i) v[j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sum+<span class="number">1</span>,sum+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[i]==sum[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;j++)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ppa=<span class="number">1</span>,Sum=sum[i];</span><br><span class="line">            <span class="keyword">while</span>(Sum%p[j]==<span class="number">0</span>) Sum/=p[j],ppa=ppa*p[j]%MOD;</span><br><span class="line">            P[j]=max(P[j],ppa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;i++) ans*=P[i],ans%=MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2281 圈地为王</title>
    <url>/2020/04/11/DTOJ2281-%E5%9C%88%E5%9C%B0%E4%B8%BA%E7%8E%8B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>在$n$行$m$列的网格中，你要圈一些地<br>你从左上角出发，最后返回左上角，路径内部的区域视为被你圈住<br>你不可以进入网格内部，只能在边上行走<br>你的路径不能在左上角以外自交，但是边足够宽，你可以重复经过而不自交<br>网格中有一些格子对你很重要，你要尽量圈住它；而另一些格子对你有坏处，你不能圈住它<br>求圈住$i$个重要的格子的最小路径长度</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>$n$行，每行$m$个字符<br><code>I</code>表示重要的格子，<code>X</code>表示有坏处的格子，<code>.</code>表示其他格子</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出重要的格子数行，第i行表示圈住i个重要的格子的最小路径长度</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X.I</span><br><span class="line">.I.</span><br><span class="line">I..</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">10</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p><img src="https://img-blog.csdnimg.cn/20200411090009782.png" alt="在这里插入图片描述"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看到这个非<code>.</code>的格子这么少，让我想到了压缩最短路算法的状态<br>如何判断一个点是否在多边形内？很简单，只需要使用射线法<br>即从这个点随便引出一条射线，如果这条射线与多边形有奇数个交点，那么这个点就在多边形内<br>所以，我们用状态$s$表示路径下方某个重要格（或坏格）上方被该路径覆盖的次数的奇偶，$f_{x,y,s}$表示圈住这些点并且现在在$(x,y)$上的路径最短长度<br>然后直接跑最短路，对于左（或右）移操作，就查看一遍移动经过的这一段下方的重要格和坏格，更新$s$<br>统计答案的时候就遍历所有状态，取最小值即可<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;ppap&gt; q;</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sp[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,cnt,sum,dx[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,k[<span class="number">20</span>],f[<span class="number">60</span>][<span class="number">60</span>][<span class="number">2100</span>],v[<span class="number">60</span>][<span class="number">60</span>][<span class="number">2100</span>],ans[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) <span class="keyword">if</span>(y==sp[i].second&amp;&amp;x&lt;=sp[i].first) s^=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%s"</span>,<span class="built_in">map</span>[n++]));</span><br><span class="line">    m=<span class="built_in">strlen</span>(<span class="built_in">map</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'X'</span>) k[++cnt]=<span class="number">0</span>,sp[cnt]=make_pair(i,j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'I'</span>) k[++cnt]=<span class="number">1</span>,sp[cnt]=make_pair(i,j),sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(f)),<span class="built_in">memset</span>(ans,<span class="number">0x7f</span>,<span class="keyword">sizeof</span>(ans)),q.push((ppap)&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;),f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ppap u=q.front();</span><br><span class="line">        q.pop(),v[u.x][u.y][u.s]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x=u.x+dx[i],y=u.y+dy[i],s;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;n||y&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||i==<span class="number">1</span>) s=get(u.s,u.x,min(y,u.y));</span><br><span class="line">            <span class="keyword">else</span> s=u.s;</span><br><span class="line">            <span class="keyword">if</span>(f[x][y][s]&gt;f[u.x][u.y][u.s]+<span class="number">1</span>)&#123;</span><br><span class="line">                f[x][y][s]=f[u.x][u.y][u.s]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!v[x][y][s]) v[x][y][s]=<span class="number">1</span>,q.push((ppap)&#123;x,y,s&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s;i&lt;(<span class="number">1</span>&lt;&lt;cnt);i++)&#123;</span><br><span class="line">        s=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++) <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!k[j])&#123;s=<span class="number">-1</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> s++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s!=<span class="number">-1</span>) ans[s]=min(ans[s],f[<span class="number">0</span>][<span class="number">0</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4284 DTOJ1862 BZOJ3566 [SHOI2014]概率充电器</title>
    <url>/2020/04/11/%E6%B4%9B%E8%B0%B7P4284-DTOJ1862-BZOJ3566-SHOI2014-%E6%A6%82%E7%8E%87%E5%85%85%E7%94%B5%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P4284" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br>著名的电子产品品牌<code>SHOI</code>刚刚发布了引领世界潮流的下一代电子产品——概率充电器：<br>“采用全新纳米级加工技术，实现元件与导线能否通电完全由真随机数决定！SHOI概率充电器，您生活不可或缺的必需品！能充上电吗？现在就试试看吧！”<br><code>SHOI</code>概率充电器由$n-1$条导线连通了$n$个充电元件。进行充电时，每条导线是否可以导电以概率决定，每一个充电元件自身是否直接进行充电也由概率决定<br>随后电能可以从直接充电的元件经过通电的导线使得其他充电元件进行间接充电<br>作为<code>SHOI</code>公司的忠实客户，你无法抑制自己购买<code>SHOI</code>产品的冲动。在排了一个星期的长队之后终于入手了最新型号的<code>SHOI</code>概率充电器<br>你迫不及待地将<code>SHOI</code>概率充电器插入电源——这时你突然想知道，进入充电状态的元件个数的期望是多少呢？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数：$n$，概率充电器的充电元件个数，充电元件由$1,2,\cdots \cdots ,n$编号<br>之后的$n-1$行每行三个整数$a,b,p$，描述了一根导线连接了编号为$a$和$b$的充电元件，通电概率为$p\%$<br>第$n+2$行$n$个整数：$q_i$，表示$i$号元件直接充电的概率为$q_i\%$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个实数，为能进入充电状态的元件个数的期望，四舍五入到小数点后$6$位小数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 50</span><br><span class="line">1 3 50</span><br><span class="line">50 0 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.000000</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据， $n\leqslant 5000$<br>对于$100\%$的数据，$n\leqslant 500000,0\leqslant p,q_i\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>一个概率DP<br>首先，我们需要用到两个概率的公式：</p>
<ol>
<li>$P(A+B)=P(A)+P(B)-P(A\times B)=P(A)+P(B)-P(A)\times P(B)$</li>
<li>$P(A)=\frac{P(A+B)-P(B)}{1-P(B)}$（这个公式可以由第一个公式推导出来）</li>
</ol>
<p>接着，我们假设根是编号为$1$的节点，那么每一个点的充电方法有三种：</p>
<ol>
<li>自己给自己充</li>
<li>子节点给它充</li>
<li>父节点给他充</li>
</ol>
<p>所以，我们分别进行两次DFS：</p>
<ol>
<li>统计前两种充电方法的总和，使用第一个公式</li>
<li>由于第一个DFS在计算$fa_x$（当前遍历到的节点$x$的父节点）时已经包含了$x$给$fa_x$充电的情况了，所以我们需要先利用公式二减掉这一部分的概率，再利用公式一计算出$x$的概率</li>
</ol>
<p>附上代码：<br>```cpp</p>
<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<cstdio></h1><p>using namespace std;<br>int n,tot,head[1000010],nxt[1000010],to[1000010];<br>double ans,ver[1000010],p[1000010],q[1000010];<br>void add(int x,int y,double z)<br>{<br>    nxt[++tot]=head[x],head[x]=tot,to[tot]=y,ver[tot]=z;<br>}<br>void dfs1(int x,int fa)<br>{<br>    for(int i=head[x];i;i=nxt[i]) if(to[i]!=fa) dfs1(to[i],x),p[x]=p[x]+p[to[i]]<em>ver[i]-p[x]</em>p[to[i]]<em>ver[i];<br>}<br>void dfs2(int x,int fa)<br>{<br>    ans+=q[x];<br>    for(int i=head[x];i;i=nxt[i]) if(to[i]!=fa){<br>        double temp1=1.0-p[to[i]]</em>ver[i];<br>        if(!temp1) q[to[i]]=1.0;<br>        else{<br>            double temp2=(q[x]-p[to[i]]<em>ver[i])/temp1;<br>            q[to[i]]=p[to[i]]+temp2</em>ver[i]-p[to[i]]<em>temp2</em>ver[i];<br>        }<br>        dfs2(to[i],x);<br>    }<br>}<br>int main()<br>{<br>    scanf(“%d”,&amp;n);<br>    for(int i=1,x,y,z;i&lt;n;i++) scanf(“%d%d%d”,&amp;x,&amp;y,&amp;z),add(x,y,z/100.0),add(y,x,z/100.0);<br>    for(int i=1;i&lt;=n;i++) scanf(“%lf”,&amp;p[i]),p[i]/=100.0;<br>    dfs1(1,0),q[1]=p[1],dfs2(1,0);<br>    printf(“%.6lf\n”,ans);<br>}</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>概率DP</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1053 爱博饼的翔霸</title>
    <url>/2020/04/11/DTOJ1053-%E7%88%B1%E5%8D%9A%E9%A5%BC%E7%9A%84%E7%BF%94%E9%9C%B8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>背景：“$10$月$6$日那天，电脑组组织了博饼活动，博饼结束后碗和骰子就放在了机房<br>结果喜感的翔霸整天有事没事地就跑去玩那骰子，搞得叮当叮当响的<br>终于有一天，翔霸再次去玩那些骰子的时候，曾大实在受不了了，就跟翔霸比赛博饼，如果翔霸输了，以后就不能在机房博饼<br>当然了，翔霸那么神，怎么可能输呢？哈哈<br>翔霸在赢得了跟曾大的比赛后，为了庆祝以后能在机房继续玩那些骰子，决定组织大家博饼<br>由于受到涛霸和学霸比赛谁先博到状元这个游戏的启发，翔霸也准备组织一个类似的比赛，他在电脑组里面选出$2\times n$个人，分成$n$组，一组$2$人，比赛谁先博到状元<br>作为每组幸运成为状元王中王那个人的奖励，翔霸将会教他神奇的翔状数组<br>但是平常大家都很忙的，所以只能在周末组织了<br>电脑组里每个神犇的家都很神奇地能用坐标$(x,y)$表示，两两神犇的家的距离定义为两个点之间的直线距离，被分为同一组的两个神犇商量其中一个人到另一个人家里去比赛<br>电脑组里的神犇都希望自己能到离自己家尽量近的人家里去比赛<br>作为组织者的翔霸想知道，如何分组才能让每组里要走到另一个人家里去博饼的人走的路径的和最小（保留两位小数）？<br>因为翔霸比较神，所以可能会组织好多次比赛，但具体组织多少次比赛要看翔霸的心情，因此翔霸决定当他选$0$个人的时候表示他不准备组织比赛了</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包含多组数据，当$n$为$0$时表示输入结束<br>对于每组数据：<br>第一行一个正整数$n$<br>第$i+1$行$2$个正整数，表示每个人的坐标$x_i,y_i$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据：<br>仅一行，表示最优分组方案下的路径和</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">zx 10 10</span><br><span class="line">lx 20 10</span><br><span class="line">xy 5 5</span><br><span class="line">hta 1 1</span><br><span class="line">zkc 120 3</span><br><span class="line">cxy 6 6</span><br><span class="line">fz 50 60</span><br><span class="line">cyx 3 24</span><br><span class="line">lht 6 9</span><br><span class="line">lyq 0 0</span><br><span class="line">1</span><br><span class="line">taoba 9 9</span><br><span class="line">xueba 10 10</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">118.40</span><br><span class="line">1.41</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$n\leqslant 8且n\in \N^*$<br>$0\leqslant x,y\leqslant 1000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><del>这题目背景是真的长</del><br>看一下数据范围：$n\leqslant 8且n\in \N^*$，显然就是状压<br>假设状态$s$表示哪些人参加了博饼，$f_s$表示这些人参加博饼时，最短的距离<br>状态转移时就直接暴力枚举两个人作为一对（记得要是包含在状态$s$中的），答案就是这两个人的距离加上去掉这两个人以后的剩下的人最短距离<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;h[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">65540</span>];</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((<span class="keyword">double</span>)(h[a].x-h[b].x)*(h[a].x-h[b].x)+(<span class="keyword">double</span>)(h[a].y-h[b].y)*(h[a].y-h[b].y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[step]!=<span class="number">1e9</span>) <span class="keyword">return</span> f[step];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">if</span>(step&amp;(<span class="number">1</span>&lt;&lt;i)) <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;m;j++) <span class="keyword">if</span>(step&amp;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">        f[step]=min(f[step],dfs(step-(<span class="number">1</span>&lt;&lt;j)-(<span class="number">1</span>&lt;&lt;i))+dis(i+<span class="number">1</span>,j+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> f[step];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),m=n*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">" %s%d%d"</span>,name,&amp;h[i].x,&amp;h[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);i++) f[i]=<span class="number">1e9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,dfs((<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3410 splay.one</title>
    <url>/2020/04/05/DTOJ3410-splay-one/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>某神犇正在打<code>splay.one</code>，打出了$0-233$的超鬼战绩，并为之愤怒<br>神犇怎么可能超鬼呢？<br>神犇立马黑进了服务器，把<code>if(x≤0) 死亡;（x为生命值）</code>这句话删掉了<br>神犇觉得不太好，就改成了<code>if(x==0) 死亡；</code><br>众所周知神犇沉迷写题不会打游戏，只要$x$有可能为$0$，神犇依然会超鬼<br>现在神犇正处于混战当中，有$n$个塔，分别为炮塔和治疗塔，每秒只会有一个炮塔对神犇造成伤害或者一个治疗塔给神犇加奶<br>神犇只会屠题，所以打游戏时便会眼花缭乱，看不清哪个是炮塔哪个是治疗塔<br>不过因为神犇黑进了服务器，所以他获得了所有塔的伤害量或者奶量<br>神犇想知道他会不会超鬼</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两个正整数$n,q$<br>接下来$n$个整数$A_i$，表示塔的奶量或伤害；<br>接下来$q$个询问，每次格式如下：<br><code>insert x</code>表示加入一个塔，塔的伤害量或奶量；<br><code>delete x</code>表示删除一个塔，塔的伤害量或奶量（保证能删）；<br><code>ask x</code>表示若神犇的初始生命值为$x$，询问神犇会不会超鬼</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问，如果会输出<code>WTF</code>，否则输出<code>Nice</code></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">6 4 2 18</span><br><span class="line">ask 3</span><br><span class="line">insert 9</span><br><span class="line">delete 4</span><br><span class="line">ask 8</span><br><span class="line">delete 2</span><br><span class="line">ask 6</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nice </span><br><span class="line">WTF</span><br><span class="line">WTF</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$n,q\leqslant 200000$<br>$a_i \leqslant 10^9$<br>输入保证任何时候至少有一个塔</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><del>话说这题和Splay有啥关系呢</del><br>在不考虑加减炮塔的情况下，这道题就相当于在问你：给你$n+1$个正整数$a_1,a_2,\cdots\cdots a_n$和$b$，是否存在$n$个整数（因为有不同的两种塔，所以不需要一定为正整数）$x_1,x_2,\cdots\cdots x_n$，使得$\sum\limits_{i=1}^na_ix_i=b$<br>那么，我们由裴蜀定理可以知道：只要$gcd(a_1,a_2,\cdots \cdots,a_n)|b$就有解<br>所以我们就可以直接用线段树维护gcd就可以了<br><strong>记得动态开点！</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls,rs,x,s;</span><br><span class="line">&#125;t[<span class="number">12000000</span>];</span><br><span class="line"><span class="keyword">int</span> n,q,cnt,root,a[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> X,<span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;	</span><br><span class="line">        t[p].s+=f;</span><br><span class="line">        <span class="keyword">if</span>(t[p].s) t[p].x=X;</span><br><span class="line">        <span class="keyword">else</span> t[p].x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(X&lt;=mid) change(t[p].ls,l,mid,X,f);</span><br><span class="line">    <span class="keyword">else</span> change(t[p].rs,mid+<span class="number">1</span>,r,X,f);</span><br><span class="line">    t[p].x=__gcd(t[t[p].ls].x,t[t[p].rs].x);</span><br><span class="line">    t[p].s=t[t[p].ls].s+t[t[p].rs].s;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),change(root,<span class="number">1</span>,<span class="number">1e9</span>,a[i],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s %d"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'a'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x%t[root].x==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"WTF\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Nice\n"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'i'</span>) change(root,<span class="number">1</span>,<span class="number">1e9</span>,x,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> change(root,<span class="number">1</span>,<span class="number">1e9</span>,x,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3493 加帕里图书馆</title>
    <url>/2020/04/05/DTOJ3493-%E5%8A%A0%E5%B8%95%E9%87%8C%E5%9B%BE%E4%B9%A6%E9%A6%86/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>博士经常阅读图书馆里的书籍。有一天，她在书中看到了一个长长的只由小写字母组成的字符串$S$<br>博士发现这个串有很多子序列都是回文串，非常优美，于是便列出了这个串的所有非空回文子序列<br>可是，博士忽然发现，她列出了很多相同的回文串<br>博士想知道，如果她只想把每种重复的串保留一个，一共需要从她的列表中移除多少回文串？<br>子序列$S$的一个子序列可以用一个数组$p$表示，构成的子序列为$S_{p_1}S_{p_2} \cdots \cdots S_{p_m}$，其中$m$为该子序列的长度<br>满足$0 &lt; p_1 &lt; p_2 &lt; \cdots \cdots &lt; p_m \leqslant |S|$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行一个非空字符串$S$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示博士一共需要移除多少重复的回文串。由于答案可能很大，请对$10^9+7$取模</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bccb</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">679266098</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h3><p>对于第一组样例，非空子序列一共有：<br>$\{b,c,c,b,bc,bc,bb,cc,cb,cb,bcc,bcb,bcb,ccb,bccb\}$<br>其中回文子序列有：<br>$\{b,c,c,b,bb,cc,bcb,bcb,bccb\}$<br>需要删去$3$个重复的回文子序列</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$30 \%$的数据，$|S| \leqslant 20$<br>对于$60 \%$的数据，$|S| \leqslant 100$<br>对于$100 \%$的数据， $1 \leqslant |S| \leqslant 2000$，$S$只会包含小写字母</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>毒瘤区间DP……<br>我们用$f_{i,j}$表示$S_iS_{i+1}\cdots \cdots S_j$中回文串的总个数，$g_{i,j}$表示不重复回文串的个数，$to_i$表示$s_{to_i}=s_i$且$to_i$为最小的满足$s_j=s_i$的数，同理有$fr_i$<br>接着，我们可以得到转移方程：<br>$f_{i,j}=\begin{cases}1                                          i=j\\f_{i,j-1}+f_{i+1,j}+1              s_i=s_j\\f_{i,j-1}+f_{i+1,j}-f_{i+1,j-1}   \,s_i\neq s_j\end{cases}$<br>$g_{i,j}=\begin{cases}1                                          i=j\\g_{i,j-1}+g_{i+1,j}-g_{i+1,j-1}    s_i\neq s_j\\2\times g_{i+1,j-1}+2                 \,s_i=s_j且to_i=j\\2\times g_{i+1,j-1}+1                 \,s_i=s_j且to_i=fr_j\\2\times g_{i+1,j-1}-g_{to_i+1,fr_j-1} \,\,s_i=s_j且to_i\neq fr_j,to_i\neq j\end{cases}$<br>那么，答案就是$f_{1,n}-f_{1,g}$了！<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,to[<span class="number">2010</span>],fr[<span class="number">2010</span>],pos[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>,f[<span class="number">2010</span>][<span class="number">2010</span>],g[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;(a+<span class="number">1</span>),n=<span class="built_in">strlen</span>(a+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) f[j][j+i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==a[j+i<span class="number">-1</span>]) f[j][j+i<span class="number">-1</span>]=(f[j][j+i<span class="number">-1</span><span class="number">-1</span>]+f[j+<span class="number">1</span>][j+i<span class="number">-1</span>]+<span class="number">1</span>)%MOD;</span><br><span class="line">            <span class="keyword">else</span> f[j][j+i<span class="number">-1</span>]=(f[j][j+i<span class="number">-1</span><span class="number">-1</span>]+f[j+<span class="number">1</span>][j+i<span class="number">-1</span>]-f[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>])%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fr[i]=pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>],pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++) pos[i]=n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) to[i]=pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>],pos[a[i]-<span class="string">'a'</span>+<span class="number">1</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n-i+<span class="number">1</span>;j++)</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>) g[j][j+i<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]!=a[j+i<span class="number">-1</span>]) g[j][j+i<span class="number">-1</span>]=(g[j][j+i<span class="number">-1</span><span class="number">-1</span>]+g[j+<span class="number">1</span>][j+i<span class="number">-1</span>]-g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>])%MOD;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="keyword">if</span>(to[j]==j+i<span class="number">-1</span>) g[j][j+i<span class="number">-1</span>]=(<span class="number">2</span>*g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>]+<span class="number">2</span>)%MOD;</span><br><span class="line">            	<span class="keyword">if</span>(to[j]==fr[j+i<span class="number">-1</span>]) g[j][j+i<span class="number">-1</span>]=(<span class="number">2</span>*g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>]+<span class="number">1</span>)%MOD;</span><br><span class="line">            	<span class="keyword">if</span>(to[j]!=j+i<span class="number">-1</span>&amp;&amp;to[j]!=fr[j+i<span class="number">-1</span>]) g[j][j+i<span class="number">-1</span>]=(<span class="number">2</span>*g[j+<span class="number">1</span>][j+i<span class="number">-1</span><span class="number">-1</span>]-g[to[j]+<span class="number">1</span>][fr[j+i<span class="number">-1</span>]<span class="number">-1</span>])%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(f[<span class="number">1</span>][n]-g[<span class="number">1</span>][n]+MOD)%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1039 吃蛋糕</title>
    <url>/2020/04/05/DTOJ1039-%E5%90%83%E8%9B%8B%E7%B3%95/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小明是个蛋糕爱好者，连做梦都想着吃蛋糕——然后，他真的作了这样一个梦：<br>现在他在一个长为$L$的管道里，坐标从$0\sim L$，开始时，他在$0$这个位置<br>一些事件依次发生，比如说，小明想吃蛋糕，或者是蛋糕出现了<br>如果小明想吃蛋糕，那么他会挑选最近的那个蛋糕吃掉<br>如果左右两个蛋糕的距离是一样的，那么他就选择跟吃上一个蛋糕同样移动方向上的<br>否则，他就选那个距离较近的蛋糕<br>要是一个蛋糕都没出现，那么他就呆在原地不动<br>蛋糕会随机出现在管道的任何位置<br>请你统计一下，小明一共走了多少距离</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行是两个整数$L,N$<br>$L$是管道的长度，$N$是事件的数量$(1\leqslant L,N\leqslant 100000)$<br>接下来$N$行，首先是一个整数，表示事件的种类：如果是$1$，表示小明要吃蛋糕，后面什么也没有；如果是$0$，表示有个蛋糕出现了，后面跟一个整数，表示蛋糕出现的位置$(0\leqslant x\leqslant L)$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示小明一共走了多少距离</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 8</span><br><span class="line">0 1</span><br><span class="line">0 5</span><br><span class="line">1</span><br><span class="line">0 2</span><br><span class="line">0 0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 7</span><br><span class="line">0 1</span><br><span class="line">0 5</span><br><span class="line">1</span><br><span class="line">0 2</span><br><span class="line">0 0</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2-1"><a href="#样例输出2-1" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$50\%$的数据， $L,N\leqslant 5000$<br>对于$100\%$的数据， $L,N\leqslant 100000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接两个优先队列，分别存小明左边和右边的蛋糕的位置（一个从小到大，一个从大到小），吃蛋糕时就直接弹出，并且把小明的位置换到蛋糕的位置，更新答案；加蛋糕时就看蛋糕在小明的那一边，直接加就好了<br>当然，你也可以用一些平衡树什么之类的，但是那样比较麻烦<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; qx;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; qd;</span><br><span class="line"><span class="keyword">int</span> l,n,a,ans,flag;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,op,x;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;a) qx.push(x);</span><br><span class="line">            <span class="keyword">else</span> qd.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!qd.empty()&amp;&amp;!qx.empty())&#123;</span><br><span class="line">                <span class="keyword">if</span>(a-qx.top()==qd.top()-a)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!flag) ans+=a-qx.top(),flag=<span class="number">0</span>,a=qx.top(),qx.pop();</span><br><span class="line">                    <span class="keyword">else</span> ans+=qd.top()-a,flag=<span class="number">1</span>,a=qd.top(),qd.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(a-qx.top()&lt;qd.top()-a) ans+=a-qx.top(),flag=<span class="number">0</span>,a=qx.top(),qx.pop();</span><br><span class="line">                <span class="keyword">else</span> ans+=qd.top()-a,flag=<span class="number">1</span>,a=qd.top(),qd.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(qd.empty()&amp;&amp;!qx.empty())&#123;ans+=a-qx.top(),flag=<span class="number">0</span>,a=qx.top(),qx.pop();<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!qd.empty()&amp;&amp;qx.empty())&#123;ans+=qd.top()-a,flag=<span class="number">1</span>,a=qd.top(),qd.pop();<span class="keyword">continue</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4155 BZOJ4444 DTOJ2347 [SCOI2015]国旗计划</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P4155-BZOJ4444-DTOJ2347-SCOI2015-%E5%9B%BD%E6%97%97%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>A国</code>正在开展一项伟大的计划——国旗计划<br>这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈<br>这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了$n$名优秀的边防战士作为这项计划的候选人<br><code>A国</code>幅员辽阔，边境线上设有$m$个边防站，顺时针编号$1$至$m$<br>每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这两个边防战士的奔袭区间<br>$N$名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含<br>现在，国土安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划<br>不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利完成国旗计划</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第$1$行，包含$2$个正整数$n$、$m$，分别表示边防战士数量和边防站数量。<br>随后$n$行，每行包含$2$个正整数<br>其中，第i行包含的两个正整数$C_i$、$D_i$分别表示i号边防战士常驻的两个边防站编号，$C_i$号边防站沿顺时针方向至$D_i$号边防站为他的奔袭区间<br>数据保证整个边境线都是可被覆盖的</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出数据仅$1$行，需要包含$n$个正整数<br>其中，第$i$个正整数表示$i$号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">2 5</span><br><span class="line">4 7</span><br><span class="line">6 1</span><br><span class="line">7 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3 4 3</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>若$1$号边防战士必须参加，$1$、$2$、$4$号边防战士可覆盖整个边境线，因此至少需要$3$名边防战士完成国旗计划<br>同理，若$2$号边防战士或$4$号边防战士必须参加，也需要$3$名边防战士完成国旗计划<br>若3号边防战士必须参加，则需要$1$、$2$、$3$、$4$号边防战士才能完成国旗计划，因此至少需要$4$名边防战士</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$40\%$的数据，$n\leqslant 2000,m\leqslant 5000$<br>另有$30\%$的数据，保证所有答案不超过$100$<br>对于$100\%$的数据，$n\leqslant 2×10^5,m\leqslant 109,1\leqslant C_i,D_i\leqslant m$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为区间互相不包含，所以可以把区间按照左端点排序，这样右端点一定也是单调的<br>然后将环拆成一条链，也就是将所以区间在复制一遍<br>贪心求出每个区间可以走到的下个区间的最远右端点<br>用$f[x][i]$表示从第$x$个区间出发，走$2^i$个区间到达的区间<br>用倍增思想，只要右端点$\geqslant$出发的左端点$+m$就可以了<br>注意要<strong>预先保存第</strong>$\textbf{i}$<strong>个区间的原始下标</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,h;</span><br><span class="line">&#125;a[<span class="number">500010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;t[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len,tot,head[<span class="number">500010</span>],ans[<span class="number">500010</span>],f[<span class="number">500010</span>][<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap1 &amp;a,<span class="keyword">const</span> ppap1 &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l&lt;b.l||(a.l==b.l&amp;&amp;a.r&lt;b.r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[++tot].nxt=head[u],head[u]=tot,t[tot].to=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">js</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,temp=a[x].l+m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(f[x][i]&amp;&amp;a[f[x][i]].r&lt;temp) x=f[x][i],ans+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    <span class="keyword">return</span> ans+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),len=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].l,&amp;a[i].r),a[i].h=i;</span><br><span class="line">        <span class="keyword">if</span>(a[i].l&gt;a[i].r) a[i].r+=m;</span><br><span class="line">        <span class="keyword">else</span> a[++len]=(ppap1)&#123;a[i].l+m,a[i].r+m,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+len+<span class="number">1</span>,cmp),a[len+<span class="number">1</span>].r=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,z=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(z&lt;=len&amp;&amp;a[z+<span class="number">1</span>].l&lt;=a[i].r) z++;</span><br><span class="line">        f[i][<span class="number">0</span>]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">20</span>;j++)  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) f[i][j]=f[f[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="keyword">if</span>(a[i].l&lt;=m) ans[a[i].h]=js(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3258 BZOJ3631 DTOJ2250 [JLOI2014]松鼠的新家</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P3258-BZOJ3631-DTOJ2250-JLOI2014-%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>松鼠的新家是一棵树，前几天刚刚装修了新家，新家有$n$个房间，并且有$n-1$根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的<br>天哪，他居然真的住在“树”上<br>松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去$a_1$，再去$a_2$，……，最后到$a_n$，去参观新家<br>可是这样会导致维尼重复走很多房间，懒惰的维尼不听地推辞<br>可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃<br>维尼是个馋家伙，立马就答应了<br>现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果<br>因为松鼠参观指南上的最后一个房间$a_n$是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$n$，表示房间个数<br>第二行$n$个整数，依次描述$a_1-a_n$<br>接下来$n-1$行，每行两个整数$x$，$y$，表示标号$x$和$y$的两个房间之间有树枝相连</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一共$n$行，第$i$行输出标号为$i$的房间至少需要放多少个糖果，才能让维尼有糖果吃</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 4 5 3 2</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$30\%$的数据，$n\leqslant 4000$<br>$80\%$的数据，$n\leqslant 50000$<br>100%的数据，$2\leqslant n\leqslant 300000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>其实这题是可以直接树剖的，但是我太懒(làn)<del>主要是板子背不下来</del><br>从$a_i$走到$a_{i+1}$时，在$a_i$和$a_{i+1}$上面打上$+1$标记，在它们的LCA和LCA的父亲节点上面打上$-1$标记，这样从下往上传标记即可得出每个点需要经过次数<br>但是要注意每次经过的点会重复算，因此最后要把$a_2\sim a_n$计算得到的值<strong>减一</strong>才是答案<br>其实这个做法的本质就是差分<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,a[<span class="number">300010</span>],head[<span class="number">300010</span>],dep[<span class="number">300010</span>],fa[<span class="number">300010</span>][<span class="number">20</span>],ans[<span class="number">300010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[<span class="number">600010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].to=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(dep[x]&gt;=(<span class="number">1</span>&lt;&lt;i)) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa[x][<span class="number">0</span>]) dep[e[i].to]=dep[x]+<span class="number">1</span>,fa[e[i].to][<span class="number">0</span>]=x,dfs1(e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&lt;dep[y]) swap(x,y);</span><br><span class="line">    <span class="keyword">int</span> t=dep[x]-dep[y];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">18</span>;i++) <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&amp;t)x=fa[x][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa[x][<span class="number">0</span>]) dfs2(e[i].to),ans[x]+=ans[e[i].to];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),add(u,v),add(v,u);</span><br><span class="line">    dfs1(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,LCA;i&lt;n;i++) LCA=lca(a[i],a[i+<span class="number">1</span>]),ans[a[i]]++,ans[a[i+<span class="number">1</span>]]++,ans[LCA]--,ans[fa[LCA][<span class="number">0</span>]]--;</span><br><span class="line">    dfs2(a[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) ans[a[i]]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4582 BZOJ4015 DTOJ1748 [FJOI2014]树的重心</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P4582-BZOJ4015-DTOJ1748-FJOI2014-%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>给定一个$n$个点的树，每个点的编号从$1$至$n$，问这个树有多少不同的连通子树，和这个树有相同的重心<br>其中$n$个点的树指的是$n$个点的最小连通图，显然$n$个点的树有$n-1$条边，去掉这$n-1$条边中的任何一条，原图都不再联通，任意两个点之间由唯一一条路径相连<br>对于一个树，树的重心定义为：删掉某点$i$后，若剩余$k$个连通分量，那么定义$d(i)$为这些连通分量中点的个数的最大值，所谓重心，就是使得$d(i)$最小的点$i$<br>基于以上定义，一个树的重心可能会有一个或者两个，题中所要求的联通子树，其重心编号和个数必须和原树的完全一样<br>编程任务：找出给定的树中有多少连通的子树和这个树有相同的重心</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行：正整数$Q$，表示该组数据中有多少组测试样例<br>每组样例首先输入一个整数$n (0 &lt; n \leqslant 200)$，表示该组样例中输入的树包含$n$个点<br>之后$n-1$行，每行输入两整数数$x, y(1 \leqslant x , y \leqslant n )$，表示编号为$x$的点和编号为$y$的点之间存在一条边，所有点的编号从$1$到$n$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>首先输出样例编号，之后输出满足条件的子树的个数，由于这个数字较大，你只需要输出这个数字对$10007$取模后的结果，即$mod 10007$<br>详见输出示例，请严格按照输出实例中的格式输出</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">1 3 </span><br><span class="line">2 3</span><br><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 2</span><br><span class="line">Case 3: 6</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>$20\%$的数据满足$n\leqslant 10$<br>$10\%$的数据满足给定的树中任意一个节点最多只有两个相邻节点<br>$100\%$的数据满足$Q\leqslant 50, n\leqslant 200$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>我们可以分别讨论1个和2个两个中心的情况：</p>
<ol>
<li>1个：考虑用树形dp来求最终的答案，直接以重心为根，枚举节点数，用$f_{i,j}$表示以$i$为根，选$j$个节点的答案数，dp的状态转移和<a href="http://jrjacky.github.io/2020/04/05/%E6%B4%9B%E8%B0%B7P4322-BZOJ4753-DTOJ3156-JSOI2016-%E6%9C%80%E4%BD%B3%E5%9B%A2%E4%BD%93/#more">洛谷P4322&amp;&amp;BZOJ4753&amp;&amp;DTOJ3156 最佳团体</a>有点像</li>
<li>2个：直接对两个重心分别求出答案，利用乘法原理求出最终的答案</li>
</ol>
<p>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,tot,root,ans,MOD=<span class="number">10007</span>,head[<span class="number">210</span>],big[<span class="number">210</span>],size[<span class="number">210</span>],f[<span class="number">210</span>][<span class="number">210</span>],temp[<span class="number">210</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[<span class="number">410</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],e[tot].to=v,head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>,big[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa)</span><br><span class="line">        getroot(e[i].to,x),size[x]+=size[e[i].to],big[x]=max(big[x],size[e[i].to]);</span><br><span class="line">    big[x]=max(big[x],n-size[x]);</span><br><span class="line">    <span class="keyword">if</span>(big[x]&lt;=big[root]||(!root)) root=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=f[x][<span class="number">0</span>]=f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt) <span class="keyword">if</span>(e[i].to!=fa)&#123; </span><br><span class="line">        dfs(e[i].to,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x]+size[e[i].to];j++) temp[j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x];j++) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=size[e[i].to];k++)</span><br><span class="line">            temp[j+k]=(temp[j+k]+f[x][j]*f[e[i].to][k]%MOD)%MOD;</span><br><span class="line">        size[x]+=size[e[i].to];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x];j++) f[x][j]=temp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    dfs(x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f[x],<span class="number">0</span>,<span class="keyword">sizeof</span>(f[x])),size[x]=f[x][<span class="number">0</span>]=f[x][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[x];j;j=e[j].nxt)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=size[x]+size[e[j].to];k++) temp[k]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=size[x];k++) <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=size[e[j].to];l++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l*<span class="number">2</span>&gt;=i) <span class="keyword">break</span>;</span><br><span class="line">                temp[k+l]=(temp[k+l]+f[x][k]*f[e[j].to][l]%MOD)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            size[x]+=size[e[j].to];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=size[x];k++) f[x][k]=temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=(ans+f[x][i])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    dfs(x,y),dfs(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans=(ans+f[x][i]*f[y][i]%MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test=<span class="number">0</span>,T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        test++,<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head)),tot=ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">        root=<span class="number">0</span>,getroot(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(big[root]*<span class="number">2</span>&lt;n) solve1(root);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> y;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=head[root];i&gt;<span class="number">0</span>;i=e[i].nxt)&#123;</span><br><span class="line">                y=e[i].to;</span><br><span class="line">                <span class="keyword">if</span>(big[root]==size[y]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            solve2(root,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,test,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4322 BZOJ4753 DTOJ3156 [JSOI2016]最佳团体</title>
    <url>/2020/04/05/%E6%B4%9B%E8%B0%B7P4322-BZOJ4753-DTOJ3156-JSOI2016-%E6%9C%80%E4%BD%B3%E5%9B%A2%E4%BD%93/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P4322" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br><code>JSOI</code>信息学代表队一共有$N$名候选人，这些候选人从$1$到$N$编号<br>方便起见，<code>JYY</code>的编号是$0$号<br>每个候选人都由一位编号比他小的候选人$R_i$推荐。如果$R_i=0$则说明这个候选人是<code>JYY</code>自己看上的<br>为了保证团队的和谐，<code>JYY</code>需要保证，如果招募了候选人$i$，那么候选人$R_i$也一定需要在团队中<br>当然了，<code>JYY</code>自己总是在团队里的。每一个候选人都有一个战斗值$P_i$，也有一个招募费用$S_i$<br><code>JYY</code>希望招募$K$个候选人（<code>JYY</code>自己不算），组成一个性价比最高的团队<br>也就是，这$K$个被<code>JYY</code>选择的候选人的总战斗值与总招募总费用的比值最大</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 输入一行包含两个正整数$K$和$N$<br>接下来$N$行，其中第$i$行包含$3$个整数$S_i,P_i,R_i$表示候选人i的招募费用，战斗值和推荐人编号</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个实数，表示最佳比值，答案保留三位小数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">1000 1 0</span><br><span class="line">1 1000 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.001</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$100\%$的数据满足$1\leqslant K\leqslant N\leqslant 2500,0&lt;S_i,P_i\leqslant 10^4,0\leqslant R_i&lt;i$ </p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>题意就是选一个大小为$k$的连通块，使得这个连通块的总战斗值与总招募费用的比值最大<br>因为要求的是最大值，所以可以采用二分答案（<strong>实数二分！实数二分！实数二分！</strong>），所以只需要考虑如何检验这个性价比是否可达到<br>这个检验就是一个树形DP，我们用$f_{i,j}$表示根为i的子树中选$j$个人的相当于最高性价比减去二分的性价比的量（因为为了避免精度差，计算的不是两个数真正的差，而是01分数规划后的结果），递推的部分就是一个常规的树形DP的递推了<br>值得注意的是，最后的答案是$f_{0,k+1}$，不是$f_{0,k}$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,k,tot,s[<span class="number">2510</span>],p[<span class="number">2510</span>],r[<span class="number">2510</span>],head[<span class="number">2510</span>],nxt[<span class="number">2510</span>],to[<span class="number">2510</span>],size[<span class="number">2510</span>];</span><br><span class="line"><span class="keyword">double</span> L,R=<span class="number">1e4</span>,mid,eps=<span class="number">1e-5</span>,f[<span class="number">2510</span>][<span class="number">2510</span>],F[<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[r[x]],head[r[x]]=tot,to[tot]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>,f[x][<span class="number">1</span>]=p[x]-s[x]*mid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        dfs(to[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x]+size[to[i]];j++) F[j]=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x];j++) <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=size[to[i]];k++) F[j+k]=max(F[j+k],f[x][j]+f[to[i]][k]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=size[x]+size[to[i]];j++) f[x][j]=F[j];</span><br><span class="line">        size[x]+=size[to[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[i][j]=<span class="number">-1e9</span>;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][k+<span class="number">1</span>]&lt;=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;k,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s[i],&amp;p[i],&amp;r[i]),add(i);</span><br><span class="line">    <span class="keyword">while</span>(L+eps&lt;R)&#123;</span><br><span class="line">        mid=(L+R)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pd()) R=mid;</span><br><span class="line">        <span class="keyword">else</span> L=mid+eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>,L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>01分数规划</tag>
        <tag>洛谷</tag>
        <tag>省选</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3043 沉没林地</title>
    <url>/2020/04/05/DTOJ3043-%E6%B2%89%E6%B2%A1%E6%9E%97%E5%9C%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Ori</code>复活了<br>沉没林地，这是他旅途的起点<br>沉没林地可以用一条长度为$n$序列表示，存在两种东西，一个是树木，一个是小山丘，这些分别有一个高度<br>有$m$天，每一天，沉没林地从左至右有水涌入，每次水涌入都由一个参数$t_i$表示，从左至右高度第一个$\geqslant t_i$的山丘挡住（树木不会挡住水），否则，林地将会被淹没直到水的高度到达$t_i$为止。在第二天开始时，第一天的水又会瞬间消失<br><code>Ori</code>想要知道每天没有被淹没的树的个数是多少</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：$n,m$<br>第二行：$n$个整数，每个$h_i$表示这个林地，假如$h_i&gt;0$，那么此地为树木，如果$h_i&lt;0$，那么此地为山丘<br>高度为$|h_i|$<br>第三行：$m$个整数，分别表示一天水涌入的参数$t_i$<br>此外此题强制在线，输入的真实的$t_i$为$t_i\land lastans$，$lastans$表示上次询问的答案，一开始$lastans=0$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>有$m$行，对于每一个$t_i$输出答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">-2 4 -4 3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>真实的$t_i$分别为$2$、$3$、$5$<br>第一天：水越不过第一个山丘，树木没有被淹没，答案为$2$<br>第二天：水越过第一个小山丘，没有把树木淹没，答案为$2$<br>第三天：水越过第二个小山丘，把所有树木淹没，答案为$0$<br>对于$30\%$的数据，$n,m\leqslant 3000$<br>对于另外$20\%$的数据，$h_i&gt;0$<br>对于前$80\%$的数据，内存限制为128MB<br>对于$100\%$的数据，$n,m\leq 5*10^5 ,h_i\leq 10^9$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>对于每个$h_i$有两种情况：</p>
<ol>
<li>山丘：更新前面所有山丘的高度的最大值$maxs$</li>
<li>树：更新$t_{++len}$，表示这棵树的前面的所有山丘的高度的最大值（就是上面记录的$maxs$）和$h_i$这两个数中的最大值</li>
</ol>
<p>将$t$数组排序，二分查找（可以手写，也可以直接<code>upper_bound</code>）出每次水被淹没的树是排序后的第几棵树，用总数减一下就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,ans,maxs,a[<span class="number">500010</span>],t[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;<span class="number">0</span>)&#123;maxs=max(maxs,-a[i]+<span class="number">1</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        t[++s]=max(maxs,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(t+<span class="number">1</span>,t+s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),x^=ans,ans=upper_bound(t+<span class="number">1</span>,t+s+<span class="number">1</span>,x)-t,ans=s-ans+<span class="number">1</span>,<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2873 挑战K神</title>
    <url>/2020/04/05/DTOJ2873-%E6%8C%91%E6%88%98K%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>小Y</code>在<code>OIER</code>中是个菜鸟，作为一名菜鸟，如果能挑战K神是个有荣誉感的事<br><code>小Y</code>怎么会放过呢？于是<code>小Y</code>来到了<code>OIER</code>们的活动场所——<code>Playground</code>开始了挑战赛<br><code>小Y</code>看了看，<code>Playground</code>的地图是一个$N*M$的矩形($N，M\leqslant 100$)，里面遍布了障碍和一些传送带<br>例如，<code>1</code>表示该位置有障碍，<code>0</code>表示无障碍，大写字母表示传送带<br>传送带：例如，走到<code>B</code>传送带，将传送到另一个<code>B</code>传送带（次数无限，但每次进入传送带只会传送过去，不会再传送回来）<br>| 入口 | 0 | 0 | 0 |<br>|—|—|—|—|<br>| 0 | 0 | A | 0 |<br>| A | 0 | 0 | <code>K神</code> |</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行$2$个数据$n,m$<br>下面$n$行，每行$m$个数（入口点、<code>K神</code>、障碍、无障碍的空地和传送带），表示<code>Playground</code>的地图。地图数据之间无空格<br>每步只能走一格，方向为上下左右，左上角为入口点，右下角为出口点(<code>K神</code>）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示<code>小Y</code>最少需要走多少步<br>如果<code>小Y</code>不能走到目标，则输出<code>No Solution.</code> </p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">0000</span><br><span class="line">00A0</span><br><span class="line">A000</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h3><p>路线如图：<br><img src="https://img-blog.csdnimg.cn/20200331213025361.png" alt="在这里插入图片描述"></p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对$60\%$的数据：$n,m\leqslant 20$<br>对$100\%$的数据：$n,m\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>基本的搜索题……<br>就是一个宽搜，记录下所有的传送带的坐标，遇到传送带就直接传送就好了<br>没有什么好说的了，附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,s;</span><br><span class="line">&#125;q[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,l,r,dx[<span class="number">5</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,c1[<span class="number">30</span>][<span class="number">5</span>],c2[<span class="number">30</span>][<span class="number">5</span>],v[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;=<span class="string">'A'</span>&amp;&amp;<span class="built_in">map</span>[i][j]&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!c1[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">1</span>]) c1[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">1</span>]=i,c1[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">2</span>]=j;</span><br><span class="line">            <span class="keyword">else</span> c2[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">1</span>]=i,c2[<span class="built_in">map</span>[i][j]-<span class="string">'A'</span>+<span class="number">1</span>][<span class="number">2</span>]=j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r=q[<span class="number">1</span>].x=q[<span class="number">1</span>].y=v[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=q[++l].x,y=q[l].y;</span><br><span class="line">        <span class="keyword">if</span>(x==n&amp;&amp;y==m)&#123;<span class="built_in">printf</span>(<span class="string">"%d"</span>,q[l].s);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;=<span class="string">'A'</span>&amp;&amp;<span class="built_in">map</span>[x][y]&lt;=<span class="string">'Z'</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=<span class="built_in">map</span>[x][y]-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c1[temp][<span class="number">1</span>]==x&amp;&amp;c1[temp][<span class="number">2</span>]==y) x=c2[temp][<span class="number">1</span>],y=c2[temp][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> x=c1[temp][<span class="number">1</span>],y=c1[temp][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> X=x+dx[i],Y=y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(X&gt;<span class="number">0</span>&amp;&amp;X&lt;=n&amp;&amp;Y&gt;<span class="number">0</span>&amp;&amp;Y&lt;=m&amp;&amp;(!v[X][Y])&amp;&amp;<span class="built_in">map</span>[X][Y]!=<span class="string">'1'</span>) q[++r].x=X,q[r].y=Y,q[r].s=q[l].s+<span class="number">1</span>,v[X][Y]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"No Solution."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2603 不稳定的传送门</title>
    <url>/2020/03/30/DTOJ2603-%E4%B8%8D%E7%A8%B3%E5%AE%9A%E7%9A%84%E4%BC%A0%E9%80%81%E9%97%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>C</code>国里一共有$N$个城镇，编号为$1$到$N$<br>其中第$i$个城镇与第$i+1$个城镇连接着一条收费为$c_i$的从$i$到$i+1$的单向道路$(1\leqslant i&lt;n)$<br>现在，杰杰作为一个旅行者，他的任务就是从第$1$个城镇出发，到达编号为$N$的城镇<br>他觉得这样会很无聊，海克斯科技公司也是这么认为的，所以该公司在若干个城镇里设置了共$M$个单向传送门<br>每个传送门有$4$个参数$s,t,p,w$<br>$s$表示传送门的出发城镇，$t$表示传送门的传送目标城镇，保证$t$大于$s$，$w$表示使用该传送门的花费，$p$为传送成功的概率，若传送失败会自动返回出发的城市而且该传送门会永久损坏；而且无论传送成功与否，只要使用了该传送门就得花费$w$<br>现在，杰杰正在规划他的旅行方案。请你帮他规划一条最优策略，使得旅途期望花费最小</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数$N$和$M$<br>第二行有$N-1$个用空格隔开的整数，第$i$个数为$c_i$，意义如上述所示<br>接下来有$M$行，每行有$4$个数$s,t,p,w$，表示一个传送门的属性，意义如上述所示，其中$s,t,w$为整数</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，表示期望最小花费，小数点后四舍五入保留两位小数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">30 30 30</span><br><span class="line">1 4 0.5 30</span><br><span class="line">2 3 0.9 10</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">66.50</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据，每个城镇出发的传送门不超过$5$, 且$n\leqslant 1000$<br>对于$100\%$的数据，$1\leqslant n\leqslant 10^5,1\leqslant m\leqslant 10^5, 1\leqslant w\leqslant 100, 0\leqslant p\leqslant 1, 1\leqslant ci\leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>从题目中，我们可以看出这是个概率DP，并且是单向行走的<br>因此我们从$N$向$1$进行DP<br>我们可以建一个图，对于每一条边，存储$p$（概率）和$w$（花费）（对于从$i$到$i+1$的边，概率就是$1$）<br>分别写出对于同一个点的任意两条边$x$和$y$不同选择顺序的式子，化简后可以得到得：如果$dp[x.to]+\frac{x.w}{x.p}\leqslant dp[y.to]+\frac{y.w}{y.p}$，那么x比y更优，所以优先选择$x$<br>但是在计算$x$时，要用到$y$的结果，所以虽然优先选择$x$，但是在计算顺序上$y$在$x$之前<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自己写的太难看了，贴的是同学的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> x;<span class="keyword">double</span> p,val;&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; ed[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">double</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[x.x]+x.val/x.p&gt;dp[y.x]+y.val/y.p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"portal.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"portal.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">    node x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a);</span><br><span class="line">        x.x=i+<span class="number">1</span>;</span><br><span class="line">        x.p=<span class="number">1</span>;</span><br><span class="line">        x.val=a;</span><br><span class="line">        ed[i].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %lf %lf"</span>,&amp;st,&amp;x.x,&amp;x.p,&amp;x.val);</span><br><span class="line">        ed[st].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++) dp[i]=<span class="number">999999999</span>;</span><br><span class="line">    dp[N]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(ed[i].begin(),ed[i].end(),cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ed[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            x=ed[i][j];</span><br><span class="line">            dp[i]=min(dp[i],</span><br><span class="line">                       dp[i]*(<span class="number">1</span>-x.p)+dp[x.x]*x.p+x.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2146 DTOJ2409 [NOI2015]软件包管理器</title>
    <url>/2020/03/28/%E6%B4%9B%E8%B0%B7P2146-DTOJ2409-NOI2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><code>Linux</code>用户和<code>OS X</code>用户一定对软件包管理器不会陌生<br>通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置<br><code>Debian/Ubuntu</code>使用的<code>apt-get</code>，<code>Fedora/CentOS</code>使用的<code>yum</code>，以及<code>OS X</code>下可用的<code>homebrew</code>都是优秀的软件包管理器<br>你决定设计你自己的软件包管理器<br>不可避免地，你要解决软件包之间的依赖问题<br>如果软件包<code>A</code>依赖软件包<code>B</code>，那么安装软件包<code>A</code>以前，必须先安装软件包<code>B</code><br>同时，如果想要卸载软件包<code>B</code>，则必须卸载软件包<code>A</code><br>现在你已经获得了所有的软件包之间的依赖关系，而且，由于你之前的工作，除<code>0</code>号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而<code>0</code>号软件包不依赖任何一个软件包<br>依赖关系不存在环（若有$m(m\geqslant 2)$个软件包$A_1,A_2,A_3,\cdots \cdots,A_m$，其中$A_1$依赖$A_2$，$A_2$依赖$A_3$，$A_3$依赖$A_4$，……，$A_{m−1}$依赖$A_m$，而$A_m$依赖$A_1$，则称这$m$个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己<br>现在你要为你的软件包管理器写一个依赖解决程序<br>根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分<br>注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为$0$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第$1$行包含$1$个正整数$n$，表示软件包的总数，软件包从$0$开始编号<br>随后一行包含$n−1$个整数，相邻整数之间用单个空格隔开，分别表示$1,2,3,\cdots \cdots,n−2,n−1$号软件包依赖的软件包的编号<br>接下来一行包含$1$个正整数$q$，表示询问的总数<br>之后$q$行，每行$1$个询问<br>询问分为两种：<br><code>install x</code>：表示安装软件包$x$<br><code>uninstall x</code>：表示卸载软件包$x$<br>你需要维护每个软件包的安装状态，一开始所有的软件包都处于未安装状态<br>对于每个操作，你需要输出这步操作会改变多少个软件包的安装状态，随后应用这个操作（即改变你维护的安装状态）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件包括$q$行<br>输出文件的第$i$行输出$1$个整数，为第$i$步操作中改变安装状态的软件包数</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">0 0 0 1 1 5</span><br><span class="line">5</span><br><span class="line">install 5</span><br><span class="line">install 6</span><br><span class="line">uninstall 1</span><br><span class="line">install 4</span><br><span class="line">uninstall 0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">0 1 2 1 3 0 0 3 2</span><br><span class="line">10</span><br><span class="line">install 0</span><br><span class="line">install 3</span><br><span class="line">uninstall 2</span><br><span class="line">install 7</span><br><span class="line">install 5</span><br><span class="line">install 9</span><br><span class="line">uninstall 9</span><br><span class="line">install 4</span><br><span class="line">install 1</span><br><span class="line">install 9</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例1说明"><a href="#样例1说明" class="headerlink" title="样例1说明"></a>样例1说明</h3><p><img src="https://img-blog.csdnimg.cn/20200328145201656.png" alt="在这里插入图片描述"><br>一开始所有的软件包都处于未安装状态<br>安装$5$号软件包，需要安装$0,1,5$三个软件包<br>之后安装$6$号软件包，只需要安装$6$号软件包<br>此时安装了$0,1,5,6$四个软件包<br>卸载 1 号软件包需要卸载$1,5,6$三个软件包<br>此时只有$0$号软件包还处于安装状态<br>之后安装$4$号软件包，需要安装$1,4$两个软件包<br>此时$0,1,4$处在安装状态<br>最后，卸载$0$号软件包会卸载所有的软件包</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p><img src="https://img-blog.csdnimg.cn/20200328145429836.png" alt="在这里插入图片描述"></p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树剖裸题……<br>建线段树记录相应一段DFS序中安装软件的数量<br>安装软件的时候就直接把这个软件到根节点的路径上的所有点的权值全部修改为$1$<br>卸载软件的时候就直接把这个软件的所有子树上的所有点的权值全部修改为$0$就可以了<br>剩下的细节我就不说了，反正是个很裸的题<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s(x) t[x].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(x) t[x].add</span></span><br><span class="line"><span class="keyword">int</span> n,q,tot,cnt,head[<span class="number">100010</span>],to[<span class="number">100010</span>],nxt[<span class="number">100010</span>],fa[<span class="number">100010</span>],size[<span class="number">100010</span>],dep[<span class="number">100010</span>],big[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> top[<span class="number">100010</span>],dfn[<span class="number">100010</span>],dfn2[<span class="number">100010</span>],sor[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,add;</span><br><span class="line">&#125;t[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> deep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[x]=deep,size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i])&#123;</span><br><span class="line">        dfs1(to[i],deep+<span class="number">1</span>),size[x]+=size[to[i]];</span><br><span class="line">        <span class="keyword">if</span>(size[to[i]]&gt;size[big[x]]) big[x]=to[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[x]=Top,dfn[x]=++cnt,sor[cnt]=x;</span><br><span class="line">    <span class="keyword">if</span>(big[x]==<span class="number">100001</span>)&#123;dfn2[x]=cnt;<span class="keyword">return</span>;&#125;</span><br><span class="line">    dfs2(big[x],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=big[x]) dfs2(to[i],to[i]);</span><br><span class="line">    dfn2[x]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a(p))&#123;</span><br><span class="line">        a(p*<span class="number">2</span>)=a(p*<span class="number">2</span>+<span class="number">1</span>)=a(p);</span><br><span class="line">        <span class="keyword">if</span>(a(p)==<span class="number">1</span>) s(p*<span class="number">2</span>)=r(p*<span class="number">2</span>)-l(p*<span class="number">2</span>)+<span class="number">1</span>,s(p*<span class="number">2</span>+<span class="number">1</span>)=r(p*<span class="number">2</span>+<span class="number">1</span>)-l(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a(p)==<span class="number">2</span>) s(p*<span class="number">2</span>)=s(p*<span class="number">2</span>+<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">        a(p)=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l(p)=l,r(p)=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=l(p)&amp;&amp;r&gt;=r(p)) <span class="keyword">return</span> s(p);</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans+=ask(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans+=ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=l(p)&amp;&amp;r&gt;=r(p))&#123;</span><br><span class="line">        <span class="keyword">if</span>(x) a(p)=<span class="number">1</span>,s(p)=r(p)-l(p)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> a(p)=<span class="number">2</span>,s(p)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) change(p*<span class="number">2</span>,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) change(p*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">    s(p)=s(p*<span class="number">2</span>)+s(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Install</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=dep[x],u=x;</span><br><span class="line">    <span class="keyword">while</span>(top[u]) ans-=ask(<span class="number">1</span>,dfn[top[u]],dfn[u]),change(<span class="number">1</span>,dfn[top[u]],dfn[u],<span class="number">1</span>),u=fa[top[u]];</span><br><span class="line">    ans-=ask(<span class="number">1</span>,dfn[<span class="number">0</span>],dfn[u]),change(<span class="number">1</span>,dfn[<span class="number">0</span>],dfn[u],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Uninstall</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    ans=ask(<span class="number">1</span>,dfn[x],dfn2[x]),change(<span class="number">1</span>,dfn[x],dfn2[x],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"manager.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"manager.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),big[<span class="number">0</span>]=<span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x),add(x,i),fa[i]=x,big[i]=<span class="number">100001</span>;</span><br><span class="line">    dfs1(<span class="number">0</span>,<span class="number">1</span>),dfs2(<span class="number">0</span>,<span class="number">0</span>),build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'i'</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Install(x));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Uninstall(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树剖</tag>
        <tag>洛谷</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3919 DTOJ2308 Portals</title>
    <url>/2020/03/28/BZOJ3919-DTOJ2308-Portals/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h3><a id="more"></a>
<p>There is a cake placed in a labyrinth and you desperately want to eat it. You have a map of the labyrinth, which is a grid of R rows and C columns. Each grid cell contains one of the following characters:</p>
<ul>
<li><h1 id="number-sign-which-denotes-a-wall-block"><a href="#number-sign-which-denotes-a-wall-block" class="headerlink" title="(number sign) which denotes a wall block,"></a>(number sign) which denotes a wall block,</h1></li>
<li>. (dot) which denotes an open square,</li>
<li>S (uppercase letter s) which denotes an open square of your current location,</li>
<li>C (uppercase letter c) which denotes an open square with the cake.</li>
</ul>
<p>You may only walk on the open squares and move from one open square to another if they share a side. Additionally, the rectangular area depicted on the map is completely surrounded by wall blocks.<br>In order to reach the cake faster you have acquired a portal gun from Aperture ScienceTM, which operates as follows. At any time it can fire a portal in one of the four directions up,left, down and right. When a portal is fired in some direction, it will fly in that direction until it reaches the first wall. When this happens, a portal will be spawned on the wall block, on the side that faces you.<br>At most two portals can exist at any given time. If two portals are already placed in the labyrinth, then one of them (selected by you) will be removed immediately upon using the portal gun again. Firing a portal at an existing portal will replace it (there may be at most one portal per side of wall block). Note that there may be two portals placed on different sides of the same wall block.<br>Once two portals are placed in the labyrinth you can use them to teleport yourself. When standing next to one of the portals, you can walk into it and end up at the open square next to the other portal. Doing this takes as much time as moving between two adjacent squares.You may assume that firing portals does not take time and moving between two adjacent squares or teleporting through portals takes one unit of time.<br>Task<br>Given the map of the labyrinth together with your starting location and the location of the cake, calculate the minimum possible time needed for you to reach the cake.</p>
<h3 id="中文翻译"><a href="#中文翻译" class="headerlink" title="中文翻译"></a>中文翻译</h3><p>给出一张四连通的网格图，<code>#</code>代表墙，<code>.</code>代表空地，<code>S</code>代表出发点，<code>C</code>代表目的地，地图四周都是墙,求<code>S</code>到<code>C</code>的最短路<br>走的时候可以向上下左右中的某个方向发射奇怪的东西(<code>portals</code>)，<code>portals</code>会贴在发射方向的墙上<br>地图上只允许同时存在两个<code>portals</code>，如果已经发射了两个再发射第三个，那么你需要在之前的那两个中的选一个使它消失<br>两个<code>portals</code>可以存在于一块墙的两面，但不能存在于一块墙的同面<br>当你身边是墙且那块墙上有面向你的<code>portals</code>时，你可以走进那个<code>portals</code>，从另一个<code>portals</code>出来<br>相邻两点距离为$1$，走<code>portals</code>距离也为$1$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行2个数$R,C$，表示矩形的长和宽<br>接下来$R$行，每行一个长为$C$的字符串，表示这张图</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行表示答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4</span><br><span class="line">.#.C</span><br><span class="line">.#.#</span><br><span class="line">....</span><br><span class="line">S...</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p><img src="https://img-blog.csdnimg.cn/20200328142334334.png" alt="在这里插入图片描述"><br>One quickest sequence of moves is as follows:</p>
<ol>
<li>move right,</li>
<li>move right, shootone portal up, and one portal down,</li>
<li>move through the bottom portal,</li>
<li>moveone square right and reach the cake.<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3>Subtask $1$ ($11$ points): $1 \leqslant R \leqslant 10, 1 \leqslant C \leqslant 10$.<br>Subtask $2$ ($20$ points): $1 \leqslant R \leqslant 50, 1 \leqslant C \leqslant 50$.<br>Subtask $3$ ($20$ points): $1 \leqslant R \leqslant 200, 1 \leqslant C \leqslant 200$. Every open square has at least one wall block adjacent to it.<br>Subtask $4$ ($19$ points): $1 \leqslant R \leqslant 200, 1 \leqslant C \leqslant 200$.<br>Subtask $5$ ($30$ points): $1 \leqslant R \leqslant 1000, 1 \leqslant C \leqslant 1000$.<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>因为所有的传送门都只能放在墙前面的那一格，所以对于每一个点，我们可以预处理出每个点四个方向最远的不是墙的点（就是最近的墙的前面一格）和到这个点的距离的最小值$w_{i,j}$<br>那么，移动的时候就考虑放传送门，就是走到四个方向的最远点，距离就是$w_{i,j}+1$（有点类似于<code>Dijkstra</code>算法）<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">queue</span>&lt;ppap&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,sx,sy,ex,ey,w[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">5</span>],d[<span class="number">1010</span>][<span class="number">1010</span>],flag[<span class="number">1010</span>][<span class="number">1010</span>],dis[<span class="number">1010</span>][<span class="number">1010</span>],v[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %c"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'S'</span>) sx=i,sy=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'C'</span>) ex=i,ey=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        w[i][j][<span class="number">0</span>]=w[i<span class="number">-1</span>][j][<span class="number">0</span>]+<span class="number">1</span>,w[i][j][<span class="number">3</span>]=w[i][j<span class="number">-1</span>][<span class="number">3</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'#'</span>) q.push((ppap)&#123;i,j&#125;),w[i][j][<span class="number">0</span>]=w[i][j][<span class="number">3</span>]=d[i][j]=<span class="number">-1</span>,flag[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>) w[i][j][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>) w[i][j][<span class="number">3</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i;i--) <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j;j--)&#123;</span><br><span class="line">        w[i][j][<span class="number">1</span>]=w[i][j+<span class="number">1</span>][<span class="number">1</span>]+<span class="number">1</span>,w[i][j][<span class="number">2</span>]=w[i+<span class="number">1</span>][j][<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">'#'</span>) q.push((ppap)&#123;i,j&#125;),w[i][j][<span class="number">1</span>]=w[i][j][<span class="number">2</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==n) w[i][j][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==m) w[i][j][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[<span class="number">1</span>][i]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;<span class="number">1</span>,i&#125;),flag[<span class="number">1</span>][i]=<span class="number">1</span>,d[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][<span class="number">1</span>]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;i,<span class="number">1</span>&#125;),flag[i][<span class="number">1</span>]=<span class="number">1</span>,d[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[n][i]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;n,i&#125;),flag[n][i]=<span class="number">1</span>,d[n][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[i][m]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">        q.push((ppap)&#123;i,m&#125;),flag[i][m]=<span class="number">1</span>,d[i][m]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ppap t=q.front();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,X,Y;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            X=t.x+dx[i],Y=t.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(X&lt;<span class="number">1</span>||X&gt;n||Y&lt;<span class="number">1</span>||Y&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[X][Y]!=<span class="string">'#'</span>&amp;&amp;(!flag[X][Y]))&#123;</span><br><span class="line">                d[X][Y]=d[t.x][t.y]+<span class="number">1</span>,q.push((ppap)&#123;X,Y&#125;),flag[X][Y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dis[i][j]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    q.push((ppap)&#123;sx,sy&#125;),dis[sx][sy]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        ppap t=q.front();q.pop();</span><br><span class="line">        v[t.x][t.y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,X,Y;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            X=t.x+dx[i],Y=t.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[X][Y]==<span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[X][Y]&gt;dis[t.x][t.y]+<span class="number">1</span>)&#123;</span><br><span class="line">                dis[X][Y]=dis[t.x][t.y]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!v[X][Y]) q.push((ppap)&#123;X,Y&#125;);</span><br><span class="line">                v[X][Y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,X,Y;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            X=t.x+w[t.x][t.y][i]*dx[i],Y=t.y+w[t.x][t.y][i]*dy[i];</span><br><span class="line">            <span class="keyword">if</span>(w[t.x][t.y][i]&gt;d[t.x][t.y]+<span class="number">1</span>&amp;&amp;dis[X][Y]&gt;dis[t.x][t.y]+d[t.x][t.y]+<span class="number">1</span>)&#123;</span><br><span class="line">                dis[X][Y]=dis[t.x][t.y]+d[t.x][t.y]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!v[X][Y]) q.push((ppap)&#123;X,Y&#125;);</span><br><span class="line">                v[X][Y]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dis[ex][ey]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2384 跃动的串</title>
    <url>/2020/03/27/DTOJ2384-%E8%B7%83%E5%8A%A8%E7%9A%84%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>最近Ori收到了Efi的一个礼物，具体如下:<br>一开始Ori有$n$个$01$串，这些串的总长为$S$，之后Efi会进行$m$次操作，第$i$次操作为$a_i,b_i$，表示将编号为$b_i$的$01$串接在编号为$a_i$的$01$串后面，形成编号为$n+i$个$01$串。Efi为了检验Ori是否有正确进行这些操作，一次操作结束之后Efi会叫Ori找到一个正整数$k$，使得所有长度为$k$的$01$串（一共$2^k$个）都在新增加的第$n+i$个$01$串中。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行：两个整数$n,m$<br>接下来$n$行：每行一个$01$串，分别代表编号从$1 \sim n$的$01$串<br>接下来$m$行：$a_i,b_i$表示一次操作</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一共$m$行：每行输出一个$k$代表答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">101</span><br><span class="line">11111</span><br><span class="line">0</span><br><span class="line">1 2</span><br><span class="line">6 5</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p> 第一次操作之后新产生的$01$串为$0110$，$00$没在串中出现过，因此答案为$1$。<br>第二次操作之后为$01100$，答案为$2$。<br>第三次操作之后为$1111111111$，答案为$0$。</p>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$10 \%$的数据，$n$个$01$串都由$0$组成<br>对于$30 \%$的数据，编号为$a_i$的$01$串长度为$1$<br>对于$30 \%$的数据，$a_i=1$<br>以上部分分不相交<br>对于$100\%$的数据，有$n \leqslant 100,m \leqslant 100,1 \leqslant a_i,b_i \leqslant n+i-1,S \leqslant 100$（注意这里$S$之表示$n$个串的长度和）。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们可以计算得出，答案不大于14（我不知道怎么证明，但是我就是觉得答案小于这个数，事实证明我是对的，而且或许还比我估计的小）<br>因此，我们只需要保存字符串的前14位和后14位就可以了<br>首先，在输入字符串时，我们可以枚举这个字符传中的所有长度小于等于14的子串，把这些子串打上标记，看看对于这个字符串来说，它的$k$是多少<br>接着，对于每次合并字符串的操作，它的前十四位和后十四为就不说了，直接由$a$串和$b$串传递，对于他的所有长度小于等于14的子串的处理，合并前的两个串的长度小于等于14的子串一样还有，主要是中间两段字符串相交的地方，就枚举前面那个字符串的后14位，和后面那个字符串的前14位，并且还必须总长度小于等于14（不然就炸内存了）的所有串，也标记一遍，就可以了<br>具体的实现可以看程序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,len[<span class="number">210</span>],q[<span class="number">210</span>][<span class="number">20</span>],h[<span class="number">210</span>][<span class="number">20</span>],v[<span class="number">210</span>][<span class="number">32770</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,ns;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        ns=<span class="built_in">strlen</span>(s),len[i]=min(ns,<span class="number">14</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len[i];j++) q[i][j]=s[j<span class="number">-1</span>]-<span class="string">'0'</span>,h[i][j]=s[ns-j]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=ns<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) <span class="keyword">for</span>(<span class="keyword">int</span> k=j,sum=<span class="number">0</span>;k&gt;=max(<span class="number">0</span>,j<span class="number">-14</span>);k--)&#123;</span><br><span class="line">            sum+=(<span class="number">1</span>&lt;&lt;(j-k))*(s[k]-<span class="string">'0'</span>);</span><br><span class="line">            v[i][sum+(<span class="number">1</span>&lt;&lt;(j-k+<span class="number">1</span>))]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//标记所有长度小于等于14的子串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,a,b,k,l,flag;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b,n++,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len[a];i++) q[n][i]=q[a][i];<span class="comment">//前14位直接传递</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len[b];i++) h[n][i]=h[b][i];<span class="comment">//后14位直接传递</span></span><br><span class="line">        l=<span class="number">0</span>,k=len[a];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">14</span>&amp;&amp;l&lt;=len[b]) q[n][++k]=q[b][++l];<span class="comment">//前14位直接传递</span></span><br><span class="line">        l=<span class="number">0</span>,k=len[b];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;<span class="number">14</span>&amp;&amp;l&lt;=len[a]) h[n][++k]=h[a][++l];<span class="comment">//后14位直接传递</span></span><br><span class="line">        len[n]=min(len[a]+len[b],<span class="number">14</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;<span class="number">15</span>);i++) v[n][i]=(v[a][i]|v[b][i]);<span class="comment">//标记原来两个串的长度小于等于14子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,s=<span class="number">0</span>;i&lt;=len[a];i++)&#123;</span><br><span class="line">            s+=h[a][i]*(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,sum=<span class="number">0</span>;j&lt;=len[b]&amp;&amp;i+j&lt;=<span class="number">14</span>;j++) sum=(sum&lt;&lt;<span class="number">1</span>)+q[b][j],v[n][s*(<span class="number">1</span>&lt;&lt;j)+(<span class="number">1</span>&lt;&lt;(i+j))+sum]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="comment">//标记中间两段字符串相交的地方的长度小于等于14的子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">14</span>;j;j--)&#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;j);k++) <span class="keyword">if</span>(!v[n][k+(<span class="number">1</span>&lt;&lt;j)])&#123;flag=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;ans=j;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;<span class="comment">//求k</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LOJ2790 DTOJ2809 [CEOI2015 Day2]核能国度(Nuclearia)</title>
    <url>/2020/03/27/LOJ2790-DTOJ2809-CEOI2015-Day2-%E6%A0%B8%E8%83%BD%E5%9B%BD%E5%BA%A6-Nuclearia/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://loj.ac/problem/2790" target="_blank" rel="noopener">原题</a></strong><br><a id="more"></a><br>核能国可以看作一个由$W \times H$的方格组成的矩形。核能国有$N$个核电站，每个核电站占用一个方格。不幸的是，核能国遭遇了百年一遇的特大地震，导致所有的核电站都发生了核泄漏。<br>每个核电站的核泄漏程度可以用两个整数$a, b$来表示。如果位于$P=[x_P,y_P]$的核电站爆炸，方格$C=[x_C,y_C]$会增加$\mathrm{max}(0,a-b\times d(P,C))$贝克的辐射（贝克是单位），其中$d(P,C)$是两个方格的切比雪夫距离，即$d(P,C) =\mathrm{max}(|x_P - x_C|,|y_P - y_C|)$。<br>一个方格可能会受到多处核泄漏的影响。<br>例如，如果一个$a = 7, b = 3$的核电站爆炸了，所在的方格$X$会受到$7$贝克辐射（贝克是单位），满足$d(X,Y) = 1$的$8$个方格$Y$会受到$4$贝克辐射，满足$d(X,Z) = 2$的$16$个方格$Z$会受到$1$贝克辐射。<br>环保部门给了你$Q$组询问，每组询问会划定核能国领土中的一个矩形，请回答：矩形区域内（每个方格）所受的平均辐射量为多少。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个正整数$W$和$H(W × H \leqslant 2.5×10^6)$，分别表示核能国的宽度与高度。<br>第二行，一个正整数$N$，表示核电站的个数$(1 \leq N \leqslant 2×10^5)$。<br>在接下来的$N$行中，每行四个正整数$x_i,y_i,a_i,b_i(1 \leqslant x_i \leqslant W,1 \leqslant y_i \leqslant H,1 \leqslant a_i,b_i \leqslant 10^9)$，表示有一个核电站位于方格$[x_i,y_i]$，它的参数为$a_i$与$b_i​$。每个格子最多有一个核电站。<br>第$N+3$行，一个正整数$Q$，表示询问的次数$(1 \leq Q \leq 2×10^5)$。<br>在接下来的$Q$行中，每行四个 正整数 $x_{1j},y_{1j},x_{2j},y_{2j}(1 \leqslant x_{1j} \leqslant x_{2j} \leqslant W,1 \leqslant y_{1j} \leqslant y_{2j} \leqslant H)$，表示该询问给出的矩形区域的左上角在$[x_{1j},y_{1j}]$且它的右下角在$[x_{2j},y_{2j}]$。<br>你可以假设核能国内的总辐射量少于$2^{63}$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问，输出一行表示给定矩形区域内所有方格的平均辐射量，四舍五入至整数。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">2</span><br><span class="line">1 1 7 3</span><br><span class="line">3 2 4 2</span><br><span class="line">4</span><br><span class="line">1 2 2 3</span><br><span class="line">1 1 4 3</span><br><span class="line">4 2 4 2</span><br><span class="line">1 3 4 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>以下为两次爆炸后对每个方格产生的辐射量：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 6 3 2</span><br><span class="line">4 6 5 2</span><br><span class="line">1 3 3 2</span><br></pre></td></tr></table></figure></p>
<ol>
<li>$2^2$方形区域内的总辐射为$14$，所以平均值为$14\div 4=3.5$，四舍五入至$4$。</li>
<li>整个核能国的总辐射为$44$，所以平均值为$44\div 12 \approx 3.67$，四舍五入至$4$。</li>
<li>单个格子的平均辐射量就是它所受到的辐射量。</li>
<li>最后一行的平均辐射量为$9\div 4=2.25$，四舍五入至$2$。</li>
</ol>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>有$14$组测试数据。奇数的测试组只包含$a$是$b$的倍数的核电站。对每个子任务的进一步限制如下：<br>|   测试组   |   进一步限制   |   分数   |<br>| —— | —— | —— |<br>|   1   |   $H=1,N\cdot W \leqslant 10^8,Q \cdot W \leqslant 10^8$   |   3   |<br>|   2   |   $H=1,N\cdot W \leqslant 10^8,Q \cdot W \leqslant 10^8$   |   2   |<br>|   3   |   $N\cdot W \cdot H \leq 10^8,Q \cdot W \cdot H \leq 10^8$   |   3   |<br>|   4   |   $N\cdot W \cdot H \leq 10^8,Q \cdot W \cdot H \leq 10^8$   |   2   |<br>|   5   |   $H=1,N\cdot W \leq 10^8$   |   6   |<br>|   6   |   $H=1,N\cdot W \leq 10^8$   |   4   |<br>|   7   |   $N\cdot W \cdot H \leq 10^8$   |   6   |<br>|   8   |   $N\cdot W \cdot H \leq 10^8$   |   4   |<br>|   9   |   $H=1$   |   15   |<br>|   10   |   $H=1$   |   10   |<br>|   11   |   没有符合<strong>界限</strong>定义的爆炸事件   |   15   |<br>|   12   |   没有符合<strong>界限</strong>定义的爆炸事件   |   10  |<br>|   13   |   无   |   12   |<br>|   14   |   无   |   8   |<br>如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作<strong>界限</strong>。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="暴力算法1"><a href="#暴力算法1" class="headerlink" title="暴力算法1"></a>暴力算法1</h2><p>最暴力的算法你能想到什么？枚举！<br>对于每个核电站爆炸事件，枚举它周围的方格受到的影响<br>直接枚举整个国度显得太暴力了，我们能不能稍稍优化一下呢？<br>显然是可以的<br>我们发现，每个核电站爆炸事件有一个“势力范围”<br>只有在这个方格和核电站的切比雪夫距离$\leqslant\frac{a}{b}$时，它才会受影响<br>所以，我们只需要枚举这个核电站的势力范围就可以了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXWH 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUCLEARIA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    huge Info[MAXWH];</span><br><span class="line">    <span class="function">huge&amp; <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> Info[(y * w) + x];&#125;<span class="comment">//其实就是个二维数组</span></span><br><span class="line">&#125;</span><br><span class="line">NUCLEARIA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PLANT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">PLANT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUERY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">    <span class="keyword">int</span> y1;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">&#125;</span><br><span class="line">QUERY;</span><br><span class="line"></span><br><span class="line">NUCLEARIA Nuclearia;</span><br><span class="line">PLANT Plant[MAXN];</span><br><span class="line">QUERY Query[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(huge sum, <span class="keyword">int</span> area)</span><span class="comment">//四舍五入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    huge rsl = sum / area;</span><br><span class="line">    <span class="keyword">if</span>((sum % area) * <span class="number">2</span> &gt;= area)</span><br><span class="line">    &#123;</span><br><span class="line">        rsl++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Plant[i].x), &amp;(Plant[i].y), &amp;(Plant[i].a), &amp;(Plant[i].b));</span><br><span class="line">        Plant[i].x--;</span><br><span class="line">        Plant[i].y--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Query[i].x1), &amp;(Query[i].y1), &amp;(Query[i].x2), &amp;(Query[i].y2));</span><br><span class="line">        Query[i].x1--;</span><br><span class="line">        Query[i].y1--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PLANT&amp; P = Plant[i];</span><br><span class="line">        <span class="keyword">int</span> d = (P.a - <span class="number">1</span>) / P.b;</span><br><span class="line">        <span class="keyword">int</span> x1 = max(<span class="number">0</span>, P.x - d);</span><br><span class="line">        <span class="keyword">int</span> y1 = max(<span class="number">0</span>, P.y - d);</span><br><span class="line">        <span class="keyword">int</span> x2 = min(w, P.x + d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> y2 = min(h, P.y + d + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//势力范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(x, y, P.x, P.y);</span><br><span class="line">                Nuclearia(x, y) += P.a - (d * P.b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QUERY&amp; Q = Query[i];</span><br><span class="line">        huge rsl = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = Q.x1; x &lt; Q.x2; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = Q.y1; y &lt; Q.y2; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                rsl += Nuclearia(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="暴力算法2"><a href="#暴力算法2" class="headerlink" title="暴力算法2"></a>暴力算法2</h2><p>我们发现上面的算法在询问次数很多时是很耗时间的，因为每次我们都需要把矩形的辐射量加一遍<br>所以，我们可以在询问前先预处理一下<br>大家应该知道<a href="https://www.luogu.com.cn/problem/P2280" target="_blank" rel="noopener">激光炸弹</a>吧？我们可以借用一下这种矩阵的预处理方法，就是计算出左上角在$[1,1]$且它的右下角在$[x,y]$的矩形的总辐射，假设是$Nuclearia(x,y)$<br>最终的答案就是$Nuclearia(x_{2j},y_{2j})-Nuclearia(x_{1j}-1,y_{2j})-Nuclearia(x_{2j},y_{1j}-1)+Nuclearia(x_{1j}-1,y_{1j}-1)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXWH 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUCLEARIA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    huge Info[MAXWH];</span><br><span class="line">    <span class="function">huge&amp; <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> Info[(y * w) + x];&#125;<span class="comment">//其实就是个二维数组</span></span><br><span class="line">&#125;</span><br><span class="line">NUCLEARIA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PLANT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">PLANT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUERY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">    <span class="keyword">int</span> y1;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">&#125;</span><br><span class="line">QUERY;</span><br><span class="line"></span><br><span class="line">NUCLEARIA Nuclearia;</span><br><span class="line">PLANT Plant[MAXN];</span><br><span class="line">QUERY Query[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &lt; <span class="number">0</span>) ? -a : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Summarize</span><span class="params">()</span><span class="comment">//预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x) Nuclearia(x, y) += Nuclearia(x - <span class="number">1</span>, y);</span><br><span class="line">            <span class="keyword">if</span>(y) Nuclearia(x, y) += Nuclearia(x, y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y)) Nuclearia(x, y) -= Nuclearia(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(huge sum, <span class="keyword">int</span> area)</span><span class="comment">//四舍五入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    huge rsl = sum / area;</span><br><span class="line">    <span class="keyword">if</span>((sum % area) * <span class="number">2</span> &gt;= area)</span><br><span class="line">    &#123;</span><br><span class="line">        rsl++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Plant[i].x), &amp;(Plant[i].y), &amp;(Plant[i].a), &amp;(Plant[i].b));</span><br><span class="line">        Plant[i].x--;</span><br><span class="line">        Plant[i].y--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Query[i].x1), &amp;(Query[i].y1), &amp;(Query[i].x2), &amp;(Query[i].y2));</span><br><span class="line">        Query[i].x1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].y1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].x2--;</span><br><span class="line">        Query[i].y2--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PLANT&amp; P = Plant[i];</span><br><span class="line">        <span class="keyword">int</span> d = (P.a - <span class="number">1</span>) / P.b;</span><br><span class="line">        <span class="keyword">int</span> x1 = max(<span class="number">0</span>, P.x - d);</span><br><span class="line">        <span class="keyword">int</span> y1 = max(<span class="number">0</span>, P.y - d);</span><br><span class="line">        <span class="keyword">int</span> x2 = min(w, P.x + d + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> y2 = min(h, P.y + d + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//势力范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = x1; x &lt; x2; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = y1; y &lt; y2; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> d = dist(x, y, P.x, P.y);</span><br><span class="line">                Nuclearia(x, y) += P.a - (d * P.b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Summarize();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QUERY&amp; Q = Query[i];</span><br><span class="line">        huge rsl = Nuclearia(Q.x2, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.x1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x1, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.y1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x2, Q.y1);</span><br><span class="line">        <span class="keyword">if</span>((Q.x1 &gt;= <span class="number">0</span>) &amp;&amp; (Q.y1 &gt;= <span class="number">0</span>)) rsl += Nuclearia(Q.x1, Q.y1);</span><br><span class="line">        </span><br><span class="line">        Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>接着，我们尝试在进一步的优化<br>回想一下我们在利用树状数组做区间修改时的方法：把区间的前面标记为$+a$，最后面标记为$-a$，这样，就可以进行区间修改了<br>我们可以借用一下这个思路，来标记一次核电站爆炸事件<br>首先，我们先找出这个核电站爆炸事件的“势力范围”，接着，把“势力范围”的左上角和右下角标记为$+a\% b$，把左下角和右上角标记为$-a\% b$<br>然后，我们开两个数组，在这个“势力范围”的对角线上（两条对角线，所以要两个数组）存储$b$的值，为了节省时间，我们可以只在4个角上标记，最后再把对角线上的数全部加出来<br>因为每个核电站爆炸事件的影响相等方格的，都会围成一个正方形（因为取的是切比雪夫距离），也就是说，我们在统计时，只需要先把对角线上的数复制到$Nuclearia$数组中，再把左边的和上面的数相加再减去左上的数就可以了<br>看起来有点抽象，我们可以再总结一下：</p>
<ol>
<li>对于每个核电站爆炸事件，计算出它的“势力范围”，左上角为$(x1,y1)$，右下角为$(x2,y2)$</li>
<li>标记：$Nuclearia(x1,y1) = Nuclearia(x2,y2) = a\% b$，$Nuclearia(x1,y2) = Nuclearia(x2,y1) = a\% b$</li>
<li>修改两条对角线上的值（两条对角线的数组分别为$PosDiag$（主对角线）和$NegDiag$（次对角线））：$PosDiag(x1+1,y1+1)=b,PosDiag(x2,y2)=-b,NegDiag(x1+1,y2-1)=-b,NegDiag(x2,y1)=b$</li>
<li>枚举整个国度的$PosDiag$和$NegDiag$，$PosDiag(x,y)+=PosDiag(x-1,y-1),NegDiag(x,y)+=NegDiag(x-1,y+1)$</li>
<li>枚举整个国度的$Nuclearia$，$Nuclearia(x,y)+=PosDiag(x,y)+NegDiag(x,y)$</li>
<li>重复两次：枚举整个国度的$Nuclearia$，$Nuclearia(x,y)+=Nuclearia(x-1,y)+Nuclearia(x,y-1)-Nuclearia(x-1,y-1)$<br>这就是整个过程了，最后的答案计算方法和上面一样<br>你以为这就完了吗？<br><strong>不！没完！</strong><br>注意题目的最后一句话：<code>如果核电站位于核能国的边境或是在离边境稍近的位置，那么爆炸可能也会影响到核能国之外的方格。影响到核能国外方格的爆炸被称作界限</code><br>也就是说$x1$和$y1$有可能$\leqslant 0$，$x2$也有可能$&gt;W$，$y2$也有可能$&gt;H$！<br>对于这个的处理，我们需要再开两个数组$Col$和$Row$，存储超出边界的部分，具体的实现就看程序吧，这些细节的处理，这里就不再细讲了<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXWH 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXQ 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> huge;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w, h, n, q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUCLEARIA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    huge Info[MAXWH];</span><br><span class="line">    <span class="function">huge&amp; <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> Info[(y * w) + x];&#125;</span><br><span class="line">&#125;</span><br><span class="line">NUCLEARIA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PLANT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br><span class="line">PLANT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QUERY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">    <span class="keyword">int</span> y1;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">&#125;</span><br><span class="line">QUERY;</span><br><span class="line"></span><br><span class="line">NUCLEARIA Nuclearia, PosDiag, NegDiag;</span><br><span class="line">PLANT Plant[MAXN];</span><br><span class="line">QUERY Query[MAXQ];</span><br><span class="line">huge Row[MAXWH];</span><br><span class="line">huge Col[MAXWH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdatePosDiag</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x1 &lt; <span class="number">0</span>) &amp;&amp; (y1 &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -max(x1, y1);</span><br><span class="line">        Nuclearia(<span class="number">0</span>, <span class="number">0</span>) += m * b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -x1;</span><br><span class="line">        Col[y1] += b;</span><br><span class="line">        Col[y1 + m] -= b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -y1;</span><br><span class="line">        Row[x1] += b;</span><br><span class="line">        Row[x1 + m] -= b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    PosDiag(x1, y1) += b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((x2 + <span class="number">1</span> &lt; w) &amp;&amp; (y2 + <span class="number">1</span> &lt; h)) PosDiag(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>) -= b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateNegDiag</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y2 &gt; h - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = y2 - (h - <span class="number">1</span>);</span><br><span class="line">        x1 += m;</span><br><span class="line">        y2 -= m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -x1;</span><br><span class="line">        Col[(y2 - m) + <span class="number">1</span>] -= b;</span><br><span class="line">        <span class="keyword">if</span>(y2 + <span class="number">1</span> &lt; h) Col[y2 + <span class="number">1</span>] += b;</span><br><span class="line">        x1 += m;</span><br><span class="line">        y2 -= m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((x1 &lt; w) &amp;&amp; (y2 &gt;= <span class="number">0</span>)) NegDiag(x1, y2) -= b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x2 &gt; w - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = x2 - (w - <span class="number">1</span>);</span><br><span class="line">        x2 -= m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(y1 &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = -y1;</span><br><span class="line">        Row[(x2 - m) + <span class="number">1</span>] -= b;</span><br><span class="line">        <span class="keyword">if</span>(x2 + <span class="number">1</span> &lt; w) Row[x2 + <span class="number">1</span>] += b;</span><br><span class="line">        x2 -= m;</span><br><span class="line">        y1 += m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((x2 + <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (x2 + <span class="number">1</span> &lt; w) &amp;&amp; (y1 - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (y1 - <span class="number">1</span> &lt; h)) NegDiag(x2 + <span class="number">1</span>, y1 - <span class="number">1</span>) += b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SummarizeDiags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y)) PosDiag(x, y) += PosDiag(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y != h - <span class="number">1</span>)) NegDiag(x, y) += NegDiag(x - <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddDiags</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            Nuclearia(x, y) += PosDiag(x, y);</span><br><span class="line">            Nuclearia(x, y) += NegDiag(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SummarizeLines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">1</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        Row[x] += Row[x - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">1</span>; y &lt; h; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        Col[y] += Col[y - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddLines</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        Nuclearia(x, <span class="number">0</span>) += Row[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        Nuclearia(<span class="number">0</span>, y) += Col[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Summarize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; w; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; h; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x) Nuclearia(x, y) += Nuclearia(x - <span class="number">1</span>, y);</span><br><span class="line">            <span class="keyword">if</span>(y) Nuclearia(x, y) += Nuclearia(x, y - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>((x) &amp;&amp; (y)) Nuclearia(x, y) -= Nuclearia(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(huge sum, <span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    huge rsl = sum / area;</span><br><span class="line">    <span class="keyword">if</span>((sum % area) * <span class="number">2</span> &gt;= area)</span><br><span class="line">    &#123;</span><br><span class="line">        rsl++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, rsl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;w, &amp;h);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Plant[i].x), &amp;(Plant[i].y), &amp;(Plant[i].a), &amp;(Plant[i].b));</span><br><span class="line">        Plant[i].x--;</span><br><span class="line">        Plant[i].y--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;(Query[i].x1), &amp;(Query[i].y1), &amp;(Query[i].x2), &amp;(Query[i].y2));</span><br><span class="line">        Query[i].x1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].y1 -= <span class="number">2</span>;</span><br><span class="line">        Query[i].x2--;</span><br><span class="line">        Query[i].y2--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PLANT&amp; P = Plant[i];</span><br><span class="line">        <span class="keyword">int</span> d = (P.a - <span class="number">1</span>) / P.b;</span><br><span class="line">        <span class="keyword">int</span> x1 = P.x - d;</span><br><span class="line">        <span class="keyword">int</span> y1 = P.y - d;</span><br><span class="line">        <span class="keyword">int</span> x2 = P.x + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y2 = P.y + d + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = P.a % P.b;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r)</span><br><span class="line">        &#123;</span><br><span class="line">            Nuclearia(max(<span class="number">0</span>, x1), max(<span class="number">0</span>, y1)) += r;</span><br><span class="line">            <span class="keyword">if</span>(x2 &lt; w) Nuclearia(x2, max(<span class="number">0</span>, y1)) -= r;</span><br><span class="line">            <span class="keyword">if</span>(y2 &lt; h) Nuclearia(max(<span class="number">0</span>, x1), y2) -= r;</span><br><span class="line">            <span class="keyword">if</span>((x2 &lt; w) &amp;&amp; (y2 &lt; h)) Nuclearia(x2, y2) += r;</span><br><span class="line">            </span><br><span class="line">            x1++;</span><br><span class="line">            y1++;</span><br><span class="line">            x2--;</span><br><span class="line">            y2--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(P.a &gt;= P.b)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdatePosDiag(x1, y1, x2, y2, P.b);</span><br><span class="line">            UpdateNegDiag(x1, y1, x2, y2, P.b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SummarizeDiags();</span><br><span class="line">    AddDiags();</span><br><span class="line">    SummarizeLines();</span><br><span class="line">    AddLines();</span><br><span class="line">    Summarize();</span><br><span class="line">    Summarize();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        QUERY&amp; Q = Query[i];</span><br><span class="line">        huge rsl = Nuclearia(Q.x2, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.x1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x1, Q.y2);</span><br><span class="line">        <span class="keyword">if</span>(Q.y1 &gt;= <span class="number">0</span>) rsl -= Nuclearia(Q.x2, Q.y1);</span><br><span class="line">        <span class="keyword">if</span>((Q.x1 &gt;= <span class="number">0</span>) &amp;&amp; (Q.y1 &gt;= <span class="number">0</span>)) rsl += Nuclearia(Q.x1, Q.y1);</span><br><span class="line">        </span><br><span class="line">        Print(rsl, (Q.x2 - Q.x1) * (Q.y2 - Q.y1));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>LOJ</tag>
        <tag>CEOI</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3320 GotoAndPlay</title>
    <url>/2020/03/27/DTOJ3320-GotoAndPlay/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小松鼠终于吃撑了，她决定逃离这个地方<br>我们用一张连通图来表示整个西湖的范围，每棵容小松鼠逗留的树都用这张图上的一个点来表示。小松鼠能够通过只跳一次互相到达的两棵树用图上的一条无向边来连接<br>吃撑了的小松鼠有些神志不清，每次她连跳两条边之后才会在到达的那个点上休息。她想知道，是否存在一种连续的跳法，使得她有机会在所有的树上都休息至少一次<br>对于这种跳法，你可以任选起点，允许重复经过边，允许重复经过点<br>但是超萌小松鼠是一只有梦想的小松鼠，她有时能够突破自己的极限，使一些原本无法互相到达的两个点能够通过一次跳跃互相到达</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数$n,m$，$n$表示点的个数，$m$表示边的条数<br>接下来$m$行，每行两个数$x_i,y_i$，表示$x_i$和$y_i$之间能够通过一次跳跃互相到达<br>接下来一行一个数$q$，表示询问的个数<br>接下来$q$行，其中的第$i$行每行两个数$a_i,b_i$，表示在原图的基础上加上从$a_i$到$b_i$ 的边。即成为一张$n$个点$m+1$条边的图<br>保证给出的原图是个连通图，$1 \leqslant a_i,b_i,x_i,y_i \leqslant n$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一共$q$行，对于第$i$个询问，当在原图的基础上加上$a_i$与$b_i$间的无向边后，如果小松鼠能够找到一种连续的跳法，使得她有机会在所有的树上至少休息一次，输出一行“Yes”，否则输出一行“No”（不包含引号）</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2</span><br><span class="line">1 1 </span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于前$50\%$，$n,q \leqslant 10^3,m \leqslant 2 \times 10^3$<br>对于$100\%$，$n,q \leqslant 10^5,m \leqslant 2 \times 10^5$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>直接对整个图进行二分图染色，那么松鼠的这种跳法只允许跳过同一种颜色的节点<br>所以接下来就很简单了：只有在发现全图能被染成一种颜色或者添加的边的两端是同一种颜色，这个询问才是对的，否则就是错的<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,q,tot,flag,head[<span class="number">100010</span>],to[<span class="number">400010</span>],nxt[<span class="number">400010</span>],t[<span class="number">400010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[u]=ty;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i])&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[to[i]]&lt;<span class="number">0</span>) dfs(to[i],(ty+<span class="number">1</span>)%<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[to[i]]==ty) flag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y),add(x,y),add(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) t[i]=<span class="number">-1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(flag||t[x]==t[y]) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分图染色</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1678 Tree</title>
    <url>/2020/03/27/DTOJ1678-Tree/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200327164411941.png" alt="在这里插入图片描述"></p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p><img src="https://img-blog.csdnimg.cn/2020032716444363.png" alt="在这里插入图片描述"></p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p><img src="https://img-blog.csdnimg.cn/20200327164459366.png" alt="在这里插入图片描述"></p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">QUERY 1 2</span><br><span class="line">CHANGE 1 3</span><br><span class="line">QUERY 1 2</span><br><span class="line">DONE</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p><a href="https://www.spoj.com/problems/QTREE/" target="_blank" rel="noopener">SP375</a>的变体，树链剖分好题<del>一个lazy标志传递错误让我调了半天……</del><br>先把边权化为点权，建一张新图<br>对这张新图跑树链剖分，建一棵线段树来维护区间最大和最小值（正常是只需要最大值，但是因为要去相反数，所以需要维护最小值）<br>对于$3$个操作：</p>
<ol>
<li>修改单边权：直接单点修改就可以了</li>
<li>路径取反：划分一下重链，直接区间修改，最大值和最小值取反后交换就好了</li>
<li>路径查询：划分重链，直接区间查询最大值</li>
</ol>
<p>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(X) t[X].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(X) t[X].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> d(X) t[X].max</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x(X) t[X].min</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(X) t[X].add</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,max,min,add;</span><br><span class="line">&#125;t[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">int</span> n,tot,U[<span class="number">100010</span>],V[<span class="number">100010</span>],head[<span class="number">100010</span>],to[<span class="number">200010</span>],ver[<span class="number">200010</span>],nxt[<span class="number">200010</span>],big[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> cnt,top[<span class="number">100010</span>],dep[<span class="number">100010</span>],siz[<span class="number">100010</span>],dfn[<span class="number">100010</span>],fa[<span class="number">100010</span>],wei[<span class="number">100010</span>],sor[<span class="number">100010</span>],p[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v,ver[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> Fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u]=Fa,dep[u]=dep[Fa]+<span class="number">1</span>,siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=Fa)&#123;</span><br><span class="line">        wei[to[i]]=ver[i],dfs1(to[i],u),siz[u]+=siz[to[i]],p[(i<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>]=to[i];</span><br><span class="line">        <span class="keyword">if</span>((!big[u])||siz[to[i]]&gt;siz[big[u]]) big[u]=to[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> Top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=++cnt,sor[cnt]=u,top[u]=Top;</span><br><span class="line">    <span class="keyword">if</span>(!big[u]) <span class="keyword">return</span>;</span><br><span class="line">    dfs2(big[u],Top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[u]&amp;&amp;to[i]!=big[u]) dfs2(to[i],to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l(p)=l,r(p)=r,d(p)=<span class="number">0x7fffffff</span>,x(p)=<span class="number">-0x7fffffff</span>,a(p)=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;d(p)=x(p)=wei[sor[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(p*<span class="number">2</span>,l,mid);</span><br><span class="line">    build(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    d(p)=max(d(p*<span class="number">2</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)),x(p)=min(x(p*<span class="number">2</span>),x(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a(p))&#123;</span><br><span class="line">        <span class="keyword">int</span> temp,add=a(p);</span><br><span class="line">        a(p)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(add&amp;<span class="number">1</span>)) <span class="keyword">return</span>;</span><br><span class="line">        temp=d(p*<span class="number">2</span>),d(p*<span class="number">2</span>)=-x(p*<span class="number">2</span>),x(p*<span class="number">2</span>)=-temp,a(p*<span class="number">2</span>)+=add;</span><br><span class="line">        temp=d(p*<span class="number">2</span>+<span class="number">1</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)=-x(p*<span class="number">2</span>+<span class="number">1</span>),x(p*<span class="number">2</span>+<span class="number">1</span>)=-temp,a(p*<span class="number">2</span>+<span class="number">1</span>)+=add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l(p)==r(p))&#123;d(p)=x(p)=d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) change(p*<span class="number">2</span>,x,d);</span><br><span class="line">    <span class="keyword">else</span> change(p*<span class="number">2</span>+<span class="number">1</span>,x,d);</span><br><span class="line">    d(p)=max(d(p*<span class="number">2</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)),x(p)=min(x(p*<span class="number">2</span>),x(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Negate</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r)&#123;<span class="keyword">int</span> temp=d(p);d(p)=-x(p),x(p)=-temp,a(p)++;<span class="keyword">return</span>;&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) Negate(p*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) Negate(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    d(p)=max(d(p*<span class="number">2</span>),d(p*<span class="number">2</span>+<span class="number">1</span>)),x(p)=min(x(p*<span class="number">2</span>),x(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l(p)&gt;=l&amp;&amp;r(p)&lt;=r)&#123;<span class="keyword">return</span> d(p);&#125;</span><br><span class="line">    spread(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l(p)+r(p))/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) ans=max(ans,ask(p*<span class="number">2</span>,l,r));</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) ans=max(ans,ask(p*<span class="number">2</span>+<span class="number">1</span>,l,r));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w),U[i]=u,V[i]=v,add(u,v,w),add(v,u,w);</span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>),dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'D'</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) change(<span class="number">1</span>,dfn[p[a]],b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'N'</span>)&#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> ta=top[a],tb=top[b];ta!=tb;)</span><br><span class="line">    		    <span class="keyword">if</span>(dep[ta]&gt;dep[tb]) Negate(<span class="number">1</span>,dfn[ta],dfn[a]),a=fa[ta],ta=top[a];</span><br><span class="line">    		    <span class="keyword">else</span> Negate(<span class="number">1</span>,dfn[tb],dfn[b]),b=fa[tb],tb=top[b];</span><br><span class="line">    		<span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;</span><br><span class="line">    		<span class="keyword">if</span>(dep[a]&lt;dep[b]) Negate(<span class="number">1</span>,dfn[big[a]],dfn[b]);</span><br><span class="line">    		<span class="keyword">else</span> Negate(<span class="number">1</span>,dfn[big[b]],dfn[a]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123; </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">-0x7fffffff</span>;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="keyword">int</span> ta=top[a],tb=top[b];ta!=tb;)</span><br><span class="line">    		    <span class="keyword">if</span>(dep[ta]&gt;dep[tb]) ans=max(ans,ask(<span class="number">1</span>,dfn[ta],dfn[a])),a=fa[ta],ta=top[a];</span><br><span class="line">                <span class="keyword">else</span> ans=max(ans,ask(<span class="number">1</span>,dfn[tb],dfn[b])),b=fa[tb],tb=top[b];</span><br><span class="line">    		<span class="keyword">if</span>(a==b)&#123;<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);<span class="keyword">continue</span>;&#125;</span><br><span class="line">    		<span class="keyword">if</span>(dep[a]&lt;dep[b]) ans=max(ans,ask(<span class="number">1</span>,dfn[big[a]],dfn[b]));</span><br><span class="line">    		<span class="keyword">else</span> ans=max(ans,ask(<span class="number">1</span>,dfn[big[b]],dfn[a]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1049 欢乐送</title>
    <url>/2020/03/27/DTOJ1049-%E6%AC%A2%E4%B9%90%E9%80%81/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>天下最欢乐的事情就是大家在做题的时候<code>moreD</code>送分给大家。现在就让大家欢乐一下<br>首先大家排排坐，坐成一排<br><code>moreD</code>会给大家送分，他会时而选择区间，从左到右依次用魔法给大家送分，最左边的孩子送$1$分，第二个送$2$分……以此类推<br>有时<code>moreD</code>会询问一个孩子到底已经被送了多少分<br>只要你能每次都迅速而正确地回答出<code>moreD</code>的问题，你就可以得到出题人送的分了，两天总得分最高的孩子可以得到神秘礼物</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数$N,M$，表示有$N$个孩子，出题人有$M$次操作<br>接下来$M$行，每行代表一个操作<br>第一个字符为$c_i$,若$c_i=$<code>C</code>则此次操作为送分操作，接下来会有两个整数$L_i,R_i$，表示此次送分的区间<br>若$c_i=$<code>Q</code>，则此次操作为询问操作，接下来一个整数$x_i$，表示询问第$x_i$个孩子的当前得分数</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组询问输出一行，仅包含一个整数，表示答案对$1000000007$取$mod$的结果</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">C 1 3</span><br><span class="line">Q 2</span><br><span class="line">C 2 3</span><br><span class="line">Q 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据$N,M\leqslant 1000$<br>对于$100\%$的数据$N,M\leqslant 100000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>树状数组好题<br>看到这个形式，很容易让人想起树状数组的区间修改和区间求和（<a href="http://poj.org/problem?id=3468" target="_blank" rel="noopener">POJ3468</a>）<br>但是增加的值是一个等差数列啊<br>那么，我们可以来化简一下这个式子<br>假设我们要查询第$x$个，答案为$ans_x$，那么，我们假设所有修改中，满足$L\leqslant x$且$R\geqslant x$的为$(L_1,R_1),(L_2,R_2),\cdots\cdots (L_{len},R_{len})$<br>那么，$ans_x=\sum\limits_{i=1}^{len}(x-L_i+1)=len\times (x+1)-\sum\limits_{i=1}^{len}L_i$<br>所以，我们只需要知道$len$和$\sum\limits_{i=1}^{len}L_i$就可以了<br>这两个量非常好求，开两个树状数组，对于每个$(L_i,R_i)$，第一个树状数组的$L_i$处$+1$，$R_i+1$处$-1$，第二个树状数组的$L_i$处$+L_i$，$R_i+1$处$-L_i$就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y,MOD=<span class="number">1e9</span>+<span class="number">7</span>,c1[<span class="number">100010</span>],c2[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> X,<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=(x&amp;(-x))) c1[x]+=flag*X,c2[x]+=flag;</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;long long,long long&gt; ask(long long x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=(x&amp;(-x))) s1+=c1[x],s2+=c2[x];</span><br><span class="line">    <span class="keyword">return</span> make_pair(s1,s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" %s%lld"</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>) ans=ask(x),<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(((x+<span class="number">1</span>)*ans.second%MOD-ans.first)%MOD+MOD)%MOD);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;y),add(x,x,<span class="number">1</span>),add(y+<span class="number">1</span>,x,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2460 拜访女神</title>
    <url>/2020/03/27/DTOJ2460-%E6%8B%9C%E8%AE%BF%E5%A5%B3%E7%A5%9E/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>TRT出国后，想找一个好的位置住下来。而他所在的城市，恰好有N栋建筑(从$1\sim n$编号)，他会选择这些建筑的某一个居住<br>而建筑之间，有$M$条双向路相连。每条道路有一个起始点$u$，终止点$v$，以及走过这条道路所需的时间$d$<br>所有建筑都可以借助一些道路相互到达<br><code>TRT</code>每天会从他的住房出发，按任意顺序拜访他的$K$个女神（他想怎么走就怎么走），不过由于<code>TRT</code>精力(???)有限，他的女神个数不会超过$12$个<br>可他的女神们都比较娇气，希望<code>TRT</code>尽快来看她们<del>可她们却不会担心TRT的花心……</del><br>对于第$i$个女神，她住在第p[i]栋建筑物，她每等$x$分钟(从<code>TRT</code>离家的那一时刻开始计算)，她的焦急程度（初始为$0$）就会增加$x$<br><code>TRT</code>当然希望她们高兴越好，而且他也不会让某个女神特别伤心，所以他希望所有女神的焦急程度的最大值越小越好<br>且他也不希望与任何一个女神住在一起,要不然会被众人黑成傻逼的<del>虽然他已经被我们黑成傻逼了</del><br>所以他向你求助，帮他找出他应该住的那栋建筑，以及此时所有女神焦急程度最大值</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：三个正整数$N,M,K$<br>第二行: $K$个正整数 第$i$个正整数即是$p_i$<br>第$3\sim M+2$行：描述这些道路 对于每一行 三个正整数描述这条道路$u,v,d$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p> 一行包含两个数<br>第一个是他所住的建筑物的编号（如果有多种选择，请输出编号最小的那一个）<br>第二个是所有女神的焦急程度的最大值的最小值</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 10 2</span><br><span class="line">2 5</span><br><span class="line">1 5 2</span><br><span class="line">5 6 3</span><br><span class="line">6 2 4</span><br><span class="line">5 3 1</span><br><span class="line">6 3 2</span><br><span class="line">2 3 3</span><br><span class="line">1 2 4</span><br><span class="line">1 4 3</span><br><span class="line">3 4 5</span><br><span class="line">2 4 2</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 5</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p><code>TRT</code>在$3$号建筑安家。他每天的行走路线为$3\rightarrow 5\rightarrow 3\rightarrow 2$<br>到达$5$号建筑的时刻是$1$，那位女神的焦急程度是$1$<br>到达$2$号建筑的时间是$5$，那位女神的焦急程度是$5$，最大是$5$<br>接下来他爱走哪走哪，反正他已经拜访 <del>（∗∗）</del> 了所有女神。 可以证明其它方法不比这更优</p>
<h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于$20\%$的数据$N\leqslant 8,M\leqslant 15$<br>对于另外$20\%$的数据$K=1$<br>对于$60\%$的数据$K\leqslant 5$<br>对于$100\%$的数据$N\leqslant 10^4,M\leqslant 5\times 10^4,K\leqslant 12,N&gt;K,1\leqslant p_i,u,v\leqslant N,d\leqslant 10^4$<br>本题后$80\%$的数据保证随机</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>看看这个$k$，它这么小，难道不香吗？<br>显然是个状压DP<br>首先跑$k$遍SPFA，把图压缩成只包含女神的住处，边为两两的最短路的图<br>设$f_{i,j,s}$表示起点为$i$，当前城市为$j$，遍历状态为$s$的最短时间<br>转移就是直接枚举上一个拜访的女神的房子，最后加上到起点的最近城市的距离就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt,ver;</span><br><span class="line">&#125;e[<span class="number">100010</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n,m,k,tot,h,ans,p[<span class="number">20</span>],w[<span class="number">10010</span>],head[<span class="number">10010</span>],dis[<span class="number">20</span>][<span class="number">10010</span>],v[<span class="number">10010</span>],f[<span class="number">20</span>][<span class="number">20</span>][<span class="number">10010</span>],g[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++tot].nxt=head[u],head[u]=tot,e[tot].to=v,e[tot].ver=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v)),dis[k][x]=<span class="number">0</span>,v[x]=<span class="number">1</span>,q.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt) <span class="keyword">if</span>(dis[k][e[i].to]&gt;dis[k][u]+e[i].ver)&#123;</span><br><span class="line">            dis[k][e[i].to]=dis[k][u]+e[i].ver;</span><br><span class="line">            <span class="keyword">if</span>(!v[e[i].to]) q.push(e[i].to),v[e[i].to]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        v[u]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"godness.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"godness.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]),w[p[i]]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(dis)),<span class="built_in">memset</span>(f,<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(f)),<span class="built_in">memset</span>(g,<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(g)),ans=g[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) spfa(i,p[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        f[i][i][<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));s&lt;(<span class="number">1</span>&lt;&lt;k);s++) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) <span class="keyword">if</span>(s&amp;(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>)))</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=k;t++) <span class="keyword">if</span>(!(s&amp;(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))))</span><br><span class="line">                f[i][t][s|(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))]=min(f[i][t][s|(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>))],f[i][j][s]+dis[j][p[t]]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) g[i]=min(g[i],f[i][j][(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!w[i]) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++) <span class="keyword">if</span>(g[j]+dis[j][i]&lt;ans) ans=g[j]+dis[j][i],h=i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,h,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2431 棋盘路径</title>
    <url>/2020/03/27/DTOJ2431-%E6%A3%8B%E7%9B%98%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>像南京这样的213城市，天气总是不太友好<br>周三下午是模电实验课，<code>xy</code>正打算从宿舍$(0,0)$去实验楼$(n,m)$上课，然而他突然发现，由于暴雨的缘故，有$k$个路口$(x,y)$已经被水淹没（不知所措），根本过不了人<br><code>xy</code>行走的路线很特别，必须满足</p>
<ol>
<li>一定平行于坐标轴</li>
<li>只能在横纵坐标都是整数的点改变方向</li>
<li>行走过程中横坐标和纵坐标始终不减小<br>现在有<code>xy</code>想知道有多少条满足条件的路线可以避开被淹没的路口到达实验楼<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>第$1$行是两个非负整数$n$和$m$，表示实验楼的坐标<br>第$2$行是一个正整数$k$，表示有$k个路口被淹没<br>接下来$k$行，每行有两个非负整数$x$和$y$，表示$(x,y)$这个路口已被淹没<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>仅一行，一个非负整数，为满足条件的路线数对$1000000007$取模的值<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>对于$30\%$的数据，满足$0\leqslant n,m\leqslant 1000,0\leqslant k\leqslant 100$<br>对于$70\%$的数据，满足$0\leqslant n,m\leqslant 100000,0\leqslant k\leqslant 100$<br>对于$100\%$的数据，满足$0\leqslant n,m\leqslant 100000,0\leqslant k\leqslant 3000$<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>又是一道沙雕题……<del>又只有我这个沙雕错了</del><br>先将所有被淹没的路口排序，排序后进行容斥<br>就是用总路径数减掉前面所有的被淹没的路口到这个被淹没的路口的路径数乘以前面那个被淹没的路口的路径数（容斥完的路径数）<br>思路极易理解<br>附上代码：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;q[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> MOD=<span class="number">1e9</span>+<span class="number">7</span>,f[<span class="number">200010</span>],jc[<span class="number">200010</span>],ny[<span class="number">200010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span>||m&gt;n||n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> jc[n]*ny[m]%MOD*ny[n-m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">way</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> C(x2-x1+y2-y1,x2-x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">200005</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%MOD; </span><br><span class="line">    ny[<span class="number">200004</span>]=POW(jc[<span class="number">200004</span>],MOD<span class="number">-2</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">200003</span>;i&gt;=<span class="number">0</span>;i--) ny[i]=ny[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;q[i].x,&amp;q[i].y); </span><br><span class="line">    sort(q+<span class="number">1</span>,q+k+<span class="number">1</span>,cmp);</span><br><span class="line">    q[++k].x=n,q[k].y=m,f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        f[i]=way(<span class="number">0</span>,<span class="number">0</span>,q[i].x,q[i].y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++) f[i]=(f[i]-f[j]*way(q[j].x,q[j].y,q[i].x,q[i].y)%MOD+MOD)%MOD; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>组合</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2229 抢车位</title>
    <url>/2020/03/27/DTOJ2229-%E6%8A%A2%E8%BD%A6%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>很久以前 ，<code>cxm</code>做了一个题，叫“抢车位”，大意是让你调度的汽车 使得每个汽车都有位。<code>AC</code>以后，<code>cxm</code>去实地考察了这个游戏 ，发现最有意思的地方是“以旧换新”：你最多拥有$10$辆汽车， 便宜的汽车换贵只用补差价<br>但是贵的汽车不能换便宜，价格相同的汽车也不能互换 。每个汽车有一个赚钱速度，即每分钟会从这汽车得到多少的钱<br>假定汽车在任何时候都要赚钱 (在原游戏中即为始终能找到位置停车)，<code>cxm</code>发现需要设计一个换车的策略，使得自己以最快的速度拥有$M$的资产 (资产包括现金 + 汽车的价值，这个$M$大于等于最贵车价格的$2$倍的)<br><code>cxm</code>想了一个算法，于是这次简化版：只考虑有$2$辆汽车的情况，规则与游戏中稍不同，收益是随时发放和均摊的 ，即如果收益为$7$金每分钟，你可以在$\frac{3}{14}$分钟的时候得到$1.5$金<br>最开始你的“汽车”为$2$辆价值为$0$， 赚钱速度为$1$金每分钟的$11$路汽车</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个正整数$N$和$M$，表示有$N$种汽车和最终需要达到的资产<br>接下来$N$行，每两个正整数$w_i$和$v_i$，表示第 i种汽车的价值为$w_i$金，赚钱 速度为$v_i$金每分钟</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>包含一行一个浮点数(不限位数)，表示达到$M$的资产最少需要的时间<br>只要你的答案与标准答案差别不超过$0.001$我们就认为你的答案是正确的（正式评测时我们用<code>C++</code>的<code>double</code>类型存储你的答案和标准答案并参与判断）</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入1"><a href="#样例输入1" class="headerlink" title="样例输入1"></a>样例输入1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 200</span><br><span class="line">10 2</span><br><span class="line">15 3</span><br><span class="line">100 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出1"><a href="#样例输出1" class="headerlink" title="样例输出1"></a>样例输出1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36.4762</span><br></pre></td></tr></table></figure>
<h3 id="样例输入2"><a href="#样例输入2" class="headerlink" title="样例输入2"></a>样例输入2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 200</span><br><span class="line">20 2</span><br><span class="line">50 3</span><br><span class="line">51 100</span><br><span class="line">100 99</span><br></pre></td></tr></table></figure>
<h3 id="样例输出2"><a href="#样例输出2" class="headerlink" title="样例输出2"></a>样例输出2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21.2418</span><br></pre></td></tr></table></figure>
<h3 id="样例输入3"><a href="#样例输入3" class="headerlink" title="样例输入3"></a>样例输入3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 200</span><br><span class="line">10 2</span><br><span class="line">20 2</span><br><span class="line">50 3</span><br><span class="line">51 100</span><br></pre></td></tr></table></figure>
<h3 id="样例输出3"><a href="#样例输出3" class="headerlink" title="样例输出3"></a>样例输出3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19.425199</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h3><p>第一步：将第一辆换成第一种车<br>第二步：将第一辆换成第二种车<br>第三步：将第二辆换成第一种车<br>第四步：将第二辆换成第二种车<br>第五步：将第一辆换成第三种车<br>第六步：等待赚够$85$金的现金(也可以认为将第二辆换成了第三种车然后等待赚够$0$金)<br>总共耗时$\frac{10}{2}+\frac{5}{3}+\frac{10}{4}+\frac{5}{5}+\frac{85}{6}+\frac{85}{7}\approx 36.4762$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>有$20\%$的数据$N\leqslant 10$<br>另有$20\%$的数据$N\leqslant 30$且$M\leqslant 2000$<br>有$60\%$的数据$N\leqslant 300$<br>$100\%$的数据$N\leqslant 3000,M&lt;=10^9,2w_i\leqslant M,2\leqslant v_i\leqslant 10^5$</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>BJWC2015</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>不得不说，这真是一个沙雕题……<del>只有我这个沙雕错了……</del><br>首先，那些$w_i$增加，$v_i$减少或者不变的汽车都没有用（显然）<br>假设去掉之后只有$len$种车且从小到大排序好了<br>最优的方法显然是把两辆车都从$(w_1,v_1)$一直换到$(w_{len},v_{len})$（显然）<br>所以，我们只需要计算$f_{i,j}$，表示把第一辆车变成第$i$种车，并把第二辆车变成第$j$种车花的钱<br>由此，我们可以列出递推式：$f_{i,j}=min(f_{i,j-1}+\frac{w_j}{v_i+v_{j-1}},f_{i-1,j}+\frac{w_i}{v_{i-1}+v_j})$<br>直接暴力计算即可，效率$\Theta(len^2)$<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w,v;</span><br><span class="line">&#125;c[<span class="number">3010</span>],q[<span class="number">3010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,len,s;</span><br><span class="line"><span class="keyword">double</span> f[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> ppap &amp;a,<span class="keyword">const</span> ppap &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.w&lt;b.w||(a.w==b.w&amp;&amp;a.v&gt;b.v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),q[<span class="number">0</span>].w=f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>,q[<span class="number">0</span>].v=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c[i].w,&amp;c[i].v);</span><br><span class="line">    sort(c+<span class="number">1</span>,c+n+<span class="number">1</span>,cmp);<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(q[len].w&lt;c[i].w&amp;&amp;q[len].v&lt;c[i].v) q[++len]=c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) f[i][<span class="number">0</span>]=f[i<span class="number">-1</span>][<span class="number">0</span>]+<span class="number">1.0</span>*(q[i].w-q[i<span class="number">-1</span>].w)/(q[i<span class="number">-1</span>].v+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) f[<span class="number">0</span>][i]=f[<span class="number">0</span>][i<span class="number">-1</span>]+<span class="number">1.0</span>*(q[i].w-q[i<span class="number">-1</span>].w)/(q[i<span class="number">-1</span>].v+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len;j++)</span><br><span class="line">        f[i][j]=min(f[i<span class="number">-1</span>][j]+<span class="number">1.0</span>*(q[i].w-q[i<span class="number">-1</span>].w)/(q[i<span class="number">-1</span>].v+q[j].v),f[i][j<span class="number">-1</span>]+<span class="number">1.0</span>*(q[j].w-q[j<span class="number">-1</span>].w)/(q[j<span class="number">-1</span>].v+q[i].v));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>,f[len][len]+<span class="number">1.0</span>*(m-q[len].w*<span class="number">2</span>)/(q[len].v*<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ2450 梦灵苏魅</title>
    <url>/2020/03/27/DTOJ2450-%E6%A2%A6%E7%81%B5%E8%8B%8F%E9%AD%85/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>紫雅拥有七彩的头发，身穿樱花色的七彩裙子，这种梦幻般的外貌自然能够吸引所有男人的目光<br>紫雅为了展示自己的才华，开始在这个国家跳起了芭蕾<br>已知这个国家的城市和道路刚好形成一颗完全二叉树，从位于根节点的城市开始广度优先依次将城市编号为$1\sim N$<br>紫雅在这个国家一共表演$M$天，每天会从某个城市开始，经过若干条道路（不会回头），从而到达某个城市进行芭蕾表演<br>每个城市都有人口数量$A_i$，紫雅希望知道，对于她这一天的行动，她所有可能表演的城市的人口之和为多少</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行$2$个正整数$N,M$<br>接下来$N$行每行$1$个整数$A_i$，为第$i$个城市的人口数量<br>接下来$M$行每行$2$个正整数$B_j, P_j$，表示第j天紫雅的起点城市的编号以及经过的道路的数量</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$M$行，每行$1$个非负整数$C_i$,为第$j$天所有可能表演的城市的人口数量之和<br>如果不存在这种城市，则答案为$0$</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 3</span><br><span class="line">13</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">9</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">18</span><br><span class="line">27</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>第一天：$1$号城市位于该树的根节点。不存在经过$3$条不重复的道路所能到达的城市<br>第二天：$4$号城市位于该树的叶节点，经过$2$条道路可到达$1$号城市和$5$号城市，故答案为$13+5=18$<br>第三天：$3$号城市位于$1$号城市的子节点处，经过$1$条道路可到达$1$号城市，$6$号城市和$7$号城市。故答案为$13+6+8=27$</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>对于$50\%$的数据：$1\leqslant N\leqslant 1023,1\leqslant M\leqslant 1000$<br>对于$100\%$的数据：$1\leqslant N\leqslant 131071,1\leqslant M\leqslant 100000$，且$N=2t-1,t\in \N^+,1\leqslant Ai\leqslant 30000$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>设$f_{i,j}$为从$i$出发，往下走$j$步能到达的点的权值和，$g_{i,j}$为从$i$出发，往上走$j$步能到达的点的权值和<br>所以我们可以直接用DFS求$f$和$g$<br>最后的答案就是$f$、$g$的和了！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//班上某同学的代码，自己的代码太难解释了！</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">131072</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, dep[maxn + <span class="number">5</span>], len, maxlen;</span><br><span class="line">ll f[maxn + <span class="number">5</span>][maxt + <span class="number">5</span>], g[maxn + <span class="number">5</span>][maxt + <span class="number">5</span>], a[maxn + <span class="number">5</span>], ans[maxn + <span class="number">5</span>][maxt + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;&lt; <span class="number">1</span> &lt;= n) f[p][len] = f[p &lt;&lt; <span class="number">1</span>][len - <span class="number">1</span>] + f[p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>][len - <span class="number">1</span>];</span><br><span class="line">    g[p][len] = g[p / <span class="number">2</span>][len - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= <span class="number">2</span>) g[p][len] += f[p ^ <span class="number">1</span>][len - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> ((p &lt;&lt; <span class="number">1</span>) &lt;= n) &#123;</span><br><span class="line">        dfs(p &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        dfs(p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]); f[i][<span class="number">0</span>] = g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">        dep[i] = log2(i) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = log2(n + <span class="number">1</span>); maxlen = t * <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (len = <span class="number">1</span>; len &lt;= maxlen; len++) &#123;</span><br><span class="line">        dfs(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;k);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; maxlen) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[x][k] + g[x][k]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3628 DTOJ1220 [APOI2010]特别行动队</title>
    <url>/2020/03/27/%E6%B4%9B%E8%B0%B7P3628-DTOJ1220-APOI2010-%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P3628" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br>你有一支由$n$名预备役士兵组成的部队，士兵从$1$到$n$编号，要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号应该连续，即为形如$(i, i + 1,\cdots \cdots, i + k)$的序列<br>编号为 i 的士兵的初始战斗力为$x_i$ ，一支特别行动队的初始战斗力$x$为队内士兵初始战斗力之和，即$x = \sum\limits_{j=i}^{i+k}x_j$<br>通过长期的观察，你总结出一支特别行动队的初始战斗力$x$将按如下经验公式修正为$x’：x’ = ax^2 + bx + c$，其中$a, b, c$是已知的系数（$a &lt; 0$）<br>作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队修正后战斗力之和最大，试求出这个最大和</p>
<p>例如， 你有$4$名士兵，$x_1 = 2, x_2 = 2, x_3 = 3, x_4 = 4$，经验公式中的参数为$a = –1, b = 10, c = –20$<br>此时，最佳方案是将士兵组成$3$个特别行动队：第一队包含士兵$1$和士兵$2$，第二队包含士兵$3$，第三队包含士兵$4$<br>特别行动队的初始战斗力分别为$4, 3, 4$，修正后的战斗力分别为$4, 1, 4$，修正后的战斗力和为$9$，没有其它方案能使修正后的战斗力和更大</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数$n$，表示士兵的总数<br>第二行包含三个整数$a, b, c$，经验公式中各项的系数<br>第三行包含n 个用空格分隔的整数$x_1,x_2, \cdots, x_n$，分别表示编号为$1, 2, \cdots, n$的士兵的初始战斗力</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，代表最大的所有特别行动队战斗力之和</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 </span><br><span class="line">-1 10 -20 </span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$20\%$的数据，$n \leqslant 10^3$<br>对于$50\%$的数据，$n \leqslant 10^4$<br>对于$100\%$的数据，$1 \leqslant n \leqslant 10^6，-5 \leqslant a \leqslant -1，-10^7 \leqslant b \leqslant 10^7，-10^7 \leqslant c \leqslant 10^7，1 \leqslant x_i \leqslant 100$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>显然是个DP<br>设$f_i$表示前$i$个人最大的所有特别行动队战斗力之和<br>假设战斗力的前缀和为$sum_i$<br>那么，我们可以得出$f_i=\min\limits_{1\leqslant j<i}\{f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c\}$
显然，这非常的像斜率优化的形式
假设$k$比$l$优
那么，$f_j+a(sum_i-sum_j)^2+b(sum_i-sum_j)+c<f_k+a(sum_i-sum_k)^2+b(sum_i-sum_k)+c$
$f_j-f_k+a(sum_j^2-sum_k^2)-b(sum_j-sum_k)<2asum_i(sum_j-sum_k)$
$\frac{f_j-f_k+a(sum_j^2-sum_k^2)-b(sum_j-sum_k)}{sum_j-sum_k}<2asum_i$
直接进行斜率优化
附上代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a,b,c,l,r,x[<span class="number">1000010</span>],sum[<span class="number">1000010</span>],f[<span class="number">1000010</span>],q[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">K</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>*(f[x]-f[y]+a*(sum[x]*sum[x]-sum[y]*sum[y])-b*(sum[x]-sum[y]))/(sum[x]-sum[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;n,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;x[i]),sum[i]=sum[i<span class="number">-1</span>]+x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[l],q[l+<span class="number">1</span>])&gt;<span class="number">2</span>*a*sum[i]) l++;</span><br><span class="line">        f[i]=f[q[l]]+a*(sum[i]-sum[q[l]])*(sum[i]-sum[q[l]])+b*(sum[i]-sum[q[l]])+c;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[r],q[r<span class="number">-1</span>])&lt;K(q[r],i)) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,f[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>洛谷</tag>
        <tag>斜率优化DP</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ1984 花园</title>
    <url>/2020/03/27/DTOJ1984-%E8%8A%B1%E5%9B%AD/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>奇怪的大学有一座奇怪的花园，花园由N座温室组成，温室依次标号为$1,2,\cdots \cdots ,N$，温室之间由$N-1$条双向道路连接<br>每一座温室都种植这一种花，随着季节的变换，温室里的花的种类也在不断发生着变化<br><code>ShenX</code>平时非常喜欢在花园中漫步，他想知道从温室$x$走到温室$y$的路径中（包括两个端点），第$t$种花出现的次数</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行为两个整数$N,Q$，分别表示温室的数目和操作的数目<br>第二行有N个整数$T_1,T_2,\cdots \cdots,T_n$，其中$T_i$表示温室$i$中的花的种类<br>接下来$N-1$行，每个两个整数$x,y$，表示温室$x$和温室$y$之间有一条双向道路<br>接下来$Q$行，表示$Q$个操作，分别为以下两种形式之一：</p>
<ol>
<li><code>C x t</code> 表示在温室$x$中的花的种类变为$t$</li>
<li><code>Q x y t</code> 表示询问温室$x$走到温室$y$的路径中（包括两个端点），第t种花出现的次数</li>
</ol>
<p>为了体现在线操作，输入数据中的每个操作的参数都进行了加密。记最后一次询问的答案为$anslast$（一开始没有进行过询问时设$anslast$为$0$），读入中的$x,y,t$均需要异或上$anslast$以得到真实值，在c/c++中异或为<code>^</code>运算符，在Pascal中为<code>xor</code>运算符</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问操作，给出答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">10 20 30 40 50 </span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">Q 2 5 10</span><br><span class="line">C 2 21</span><br><span class="line">Q 3 4 21</span><br><span class="line">C 6 22</span><br><span class="line">Q 1 7 28</span><br><span class="line">C 5 20</span><br><span class="line">Q 2 5 20</span><br><span class="line">Q 2 0 9</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>这是加密前的操作：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q 2 5 10</span><br><span class="line">C 3 20</span><br><span class="line">Q 2 5 20</span><br><span class="line">C 4 20</span><br><span class="line">Q 3 5 30</span><br><span class="line">C 5 20</span><br><span class="line">Q 2 5 20</span><br><span class="line">Q 1 3 10</span><br></pre></td></tr></table></figure></p>
<h2 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h2><p>对于30%的数据，有$N\leqslant 1000，Q\leqslant 2000$<br>对于50%的数据，有$N\leqslant 10000，Q\leqslant 20000$<br>对于100%的数据，有$1\leqslant N&lt;100000，1\leqslant Q\leqslant 200000,0\leqslant Ti&lt;2^{31}$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为这是一棵树，所以我们可以假设根是$1$号节点<br>我们设$S(x)$表示$1$号节点到$x$号节点的路径上第$t$种花的数量，$v(x)$表示$x$号节点上是第几种花<br>那么，$x$号节点到$y$号节点的路径上第$t$种花的数量为$S(x)+S(y)-S(lca)+[v(lca)==t]$<br>所以我们就只需要求出$S(x)$就可以了<br>咋求呢？线段树！<br>所以我们可以对每一种花开一棵线段树，由于内存的限制，我们需要使用动态开点<br>问题是如何修改呢？<br>我们可以对于每一个节点，记录下这个节点的DFS序，就可以进行修改了！<br>修改时只需要把这个点DFS序的起始到结束中间的所有数都$+1$就可以了<br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(x) t[x].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(x) t[x].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> a(x) t[x].add</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> v(x) t[x].val</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment_Tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,add,val;</span><br><span class="line">&#125;t[<span class="number">10000010</span>];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; val;</span><br><span class="line"><span class="keyword">int</span> n,q,ans,sum,size,T[<span class="number">100010</span>],root[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">int</span> tot,top,head[<span class="number">100010</span>],to[<span class="number">200010</span>],nxt[<span class="number">200010</span>],dep[<span class="number">100010</span>],fa[<span class="number">100010</span>][<span class="number">20</span>],dfn[<span class="number">200010</span>],b[<span class="number">100010</span>],e[<span class="number">100010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span>&lt;&lt;i)&lt;=dep[x]) fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa[x][<span class="number">0</span>]) fa[to[i]][<span class="number">0</span>]=x,dep[to[i]]=dep[x]+<span class="number">1</span>,dfs(to[i]);</span><br><span class="line">    dfn[++top]=x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> temp=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">16</span>;i++) <span class="keyword">if</span>(temp&amp;(<span class="number">1</span>&lt;&lt;i)) u=fa[u][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">16</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i];</span><br><span class="line">    <span class="keyword">return</span> u==v?u:fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a(p)||l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=a(p);</span><br><span class="line">    <span class="keyword">if</span>(!l(p)) l(p)=++size;</span><br><span class="line">    <span class="keyword">if</span>(!r(p)) r(p)=++size;</span><br><span class="line">    a(p)=<span class="number">0</span>,v(l(p))+=temp,a(l(p))+=temp,v(r(p))+=temp,a(r(p))+=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) p=++size;</span><br><span class="line">    spread(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x==l&amp;&amp;y==r)&#123;v(p)+=d,a(p)+=d;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) change(l(p),l,mid,x,min(y,mid),d);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) change(r(p),mid+<span class="number">1</span>,r,max(x,mid+<span class="number">1</span>),y,d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    spread(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> v(p);</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="keyword">return</span> ask(l(p),l,mid,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ask(r(p),mid+<span class="number">1</span>,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T[i]);</span><br><span class="line">        <span class="keyword">if</span>(!val[T[i]]) val[T[i]]=++sum;</span><br><span class="line">        T[i]=val[T[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v),add(u,v),add(v,u);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=top;i++)</span><br><span class="line">        <span class="keyword">if</span>(!b[dfn[i]]) b[dfn[i]]=i;</span><br><span class="line">        <span class="keyword">else</span> e[dfn[i]]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) change(root[T[i]],<span class="number">1</span>,top,b[i],e[i],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d%d"</span>,op,&amp;x,&amp;y),x^=ans,y^=ans;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'Q'</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;z),z^=ans;</span><br><span class="line">            <span class="keyword">int</span> LCA=lca(x,y);</span><br><span class="line">            <span class="keyword">if</span>(!val[z])&#123;ans=<span class="number">0</span>,<span class="built_in">printf</span>(<span class="string">"0\n"</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">            z=val[z],ans=ask(root[z],<span class="number">1</span>,top,b[x])+ask(root[z],<span class="number">1</span>,top,b[y])<span class="number">-2</span>*ask(root[z],<span class="number">1</span>,top,b[LCA]);</span><br><span class="line">            <span class="keyword">if</span>(T[LCA]==z) ans++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!val[y]) val[y]=++sum;</span><br><span class="line">            y=val[y],change(root[T[x]],<span class="number">1</span>,top,b[x],e[x],<span class="number">-1</span>),change(root[y],<span class="number">1</span>,top,b[x],e[x],<span class="number">1</span>),T[x]=y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ3049 苋</title>
    <url>/2020/03/27/DTOJ3049-%E8%8B%8B/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>众所周知，一株马齿苋是活的，当且仅当它是连通的<br>特别地，一株活马齿苋上有$n$个独立的节点，以及连接这些点的$n-1$条苋边。每条苋边有一个值，定义为苋边的键值<br>对于一株马齿苋，我们定义两点间的简单路径为其相互到达所经过的最短苋路径<br>生物学界对于马齿苋的性质有许多研究，其中生物学家<code>Pauling</code>在其$1995$年的一篇论文中提到过这样一个经典问题：给定一株马齿苋上的一条简单路径，用生物方法判断路径上键值的异或和是否为$k$<br>这里尝试对这个问题进行推广，称之为泛马齿苋问题：给定一株马齿苋，求有多少条简单路径，使得路径上键值的异或和为$k$ </p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p> 第一行，两个整数$n,k$<br>以下$n$行$a,b,c$表示$a\rightarrow b$有边，其键值为$c$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，即答案</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1</span><br><span class="line">1 2 4</span><br><span class="line">1 3 8</span><br><span class="line">3 4 8</span><br><span class="line">4 5 9</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p> 对于$30\%$的数据，$1\leqslant n\leqslant 100,k\leqslant10$<br>对于$50\%$的数据，$1\leqslant n\leqslant 2000,k\leqslant 256$<br>对于$100\%$的数据，$1\leqslant n\leqslant 4\times 10^5,k\leqslant 10^9$</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于这是一棵树，所以简单路径就是没有重复经过一个点的路径<br>设$f(u,v)$为从$u$到$v$的简单路径的异或和<br>由异或的性质：$a\land a=1$可以知道，$f(u,v)=f(1,u)\land f(1,v)$<br>所以，我们可以先预处理出所有的$f(1,u)$<br>又因为$a\land b=c$可以推出$a\land c=b$，所以，我们只需要统计所有$f(1,u)\land k=f(1,v)$的$u$和$v$就可以了<br><strong>注意：用map离散化，答案要除以2</strong><br>附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="keyword">int</span> n,k,tot,sum,head[<span class="number">400010</span>],nxt[<span class="number">800010</span>],to[<span class="number">800010</span>],ver[<span class="number">800010</span>],XOR[<span class="number">400010</span>],s[<span class="number">400010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u],head[u]=tot,to[tot]=v,ver[tot]=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=nxt[i]) <span class="keyword">if</span>(to[i]!=fa) XOR[to[i]]=XOR[x]^ver[i],dfs(to[i],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;u,&amp;v,&amp;w),add(u,v,w),add(v,u,w);</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(!d[XOR[i]]) d[XOR[i]]=++sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[d[XOR[i]]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=s[d[XOR[i]^k]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4072 BZOJ4518 DTOJ2682 [SDOI2016]征途</title>
    <url>/2020/03/27/%E6%B4%9B%E8%B0%B7P4072-BZOJ4518-DTOJ2682-SDOI2016-%E5%BE%81%E9%80%94/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P4072" target="_blank" rel="noopener">原题</a><br><a id="more"></a><br><code>Pine</code>开始了从$S$地到$T$地的征途<br>从$S$地到$T$地的路可以划分成$n$段，相邻两段路的分界点设有休息站<br><code>Pine</code>计划用$m$天到达$T$地。除第$m$天外，每一天晚上<code>Pine</code>都必须在休息站过夜。所以，一段路必须在同一天中走完<br><code>Pine</code>希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小<br>帮助<code>Pine</code>求出最小方差是多少<br>设方差是$v$，可以证明，$v \times m ^ 2$是一个整数。为了避免精度误差，输出结果时输出$v \times m ^ 2$</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数$n$、$m$<br>第二行$n$个数，表示$n$段路的长度</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，最小方差乘以$m ^ 2$后的值</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 2 5 8 6</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><p>对于$30\%$的数据，$1 \leqslant n \leqslant 10$<br>对于$60\%$的数据，$1 \leqslant n \leqslant 100$<br>对于$100\%$的数据，$1 \leqslant n \leqslant 3000$<br>保证从$S$到$T$的总路程不超过$30000$</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>SDOI2016 Round1 Day2</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们先把结果的表达式化简一下<br>假设第$i$天走了$x_i$，总路程为$S$<br>那么$ans=m^2\times \frac{\sum \limits_{i=1}^m(x_i-\frac{S}{m})^2}{m}=\frac{\sum\limits_{i=1}^m(mx_i-S)^2}{m}=\frac{m^2\sum \limits_{i=1}^mx_i^2+S^2m-2Sm\sum \limits_{i=1}^mx_i}{m}=m\sum \limits_{i=1}^{m}x_i^2+S^2-2S^2=m\sum \limits_{i=1}^{m}x_i^2-S^2$<br>所以，我们只需要计算最小的$\sum \limits_{i=1}^mx_i^2$<br>假设$f_{i,j}$表示用$j$天走完前$i$段时，最小的$\sum \limits_{k=1}^jx_k^2$的值<br>为了方便，我们先预处理出$sum_i$表示前$i$段的长度之和<br>所以，我们就可以写出状态转移方程：$f_{i,j}=\min \limits_{1\leqslant k<i}\{f_{k,j-1}+(sum_i-sum_k)^2\}$
显然，这么做的时间复杂度太高了，我们需要进行优化
怎么优化呢？我们考虑$k$比$l$优，那么，我们可以得出：
$f_{k,j-1}+sum_k^2+sum_i^2-2sum_ksum_i<f_{l,j-1}+sum_l^2+sum_i^2-2sum_isum_l$
$f_{k,j-1}-f_{l,j-1}+sum_k^2-sum_k^2<2sum_i(sum_k-sum_l)$
$\frac{f_{k,j-1}-f_{l,j-1}+sum_k^2-sum_k^2}{sum_k-sum_l}<2sum_i$
所以，我们就可以进行斜率优化了！
附上代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n,m,l,r;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">3010</span>],sum[<span class="number">3010</span>],f[<span class="number">3010</span>],fl[<span class="number">3010</span>],q[<span class="number">3010</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">K</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fl[y]-fl[x]+sum[y]*sum[y]-sum[x]*sum[x])/(sum[y]-sum[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]),sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fl[i]=sum[i]*sum[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        l=r=<span class="number">1</span>,q[l]=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[l],q[l+<span class="number">1</span>])&lt;<span class="number">2</span>*sum[j]) l++;</span><br><span class="line">            f[j]=fl[q[l]]+(sum[j]-sum[q[l]])*(sum[j]-sum[q[l]]);</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r&amp;&amp;K(q[r<span class="number">-1</span>],q[r])&gt;K(q[r],j)) r--;</span><br><span class="line">            q[++r]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) fl[j]=f[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,m*f[n]-sum[n]*sum[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>洛谷</tag>
        <tag>斜率优化DP</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ4499 DTOJ2555 线性函数</title>
    <url>/2020/03/27/BZOJ4499-DTOJ2555-%E7%BA%BF%E6%80%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><a id="more"></a>
<p>小<code>C</code>最近在学习线性函数，线性函数可以表示为：$f(x) = kx + b$。现在小<code>C</code>面前有$n$个线性函数$f_i=k_ix+b_i$，他对这$n$个线性函数执行$m$次操作，每次可以：</p>
<ol>
<li><code>M i K B</code>代表把第$i$个线性函数改为$f_i(x)=Kx+B$</li>
<li><code>Q l r x</code>返回$f_r(f_{r-1}(\cdots \cdots f_l(x)))mod(10^9+7)$<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>第一行两个整数$n, m (1 \leqslant n, m \leqslant 200,000)$<br>接下来$n$行，每行两个整数$k_i, b_i$<br>接下来$m$行，每行的格式为<code>M i K B</code>或者<code>Q l r x</code><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2>对于每个<code>Q</code>操作，输出一行答案 <h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 5 5</span><br><span class="line">4 2</span><br><span class="line">3 6</span><br><span class="line">5 7</span><br><span class="line">2 6</span><br><span class="line">7 5</span><br><span class="line">Q 1 5 1</span><br><span class="line">Q 3 3 2</span><br><span class="line">M 3 10 6</span><br><span class="line">Q 1 4 3</span><br><span class="line">Q 3 4 4</span><br></pre></td></tr></table></figure>
<h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1825</span><br><span class="line">17</span><br><span class="line">978</span><br><span class="line">98</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2>$20\%$：$n, m \leqslant 1000$<br>另外$10\%$：$b = 0$<br>另外$10\%$：$k = 1$<br>$100\%$：$1 \leqslant n, m \leqslant 200,000，0 \leqslant k, b, x &lt; 10^9+7$<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2>FJWC2016 day5<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1>这一题一眼看过去就是线段树，问题是要储存什么<br>假设现在有两个函数$f_1(x)=k_1x+b_1,f_2(x)=k_2x+b_2$，那么$f(x)=f_2(f_1(x))$的表达式是什么呢？<br>$f(x)=f_2(f_1(x))=f_2(k_1x+b_1)=k_2(k_1x+b_1)+b_2=k_1k_2x+b_1k_2+b_2$<br>所以，我们令$k_1k_2=K,b_1k_2+b_2=B$，就可以把$f(x)$表示为$Kx+B$了<br>所以，我们只需要在线段树中存储这个函数的$k$和$b$，上传时按照上面的方法操作就可以了<br><strong>注意：线段树要开4倍！！！要记得mod10^9+7！！！</strong><br>附上代码：<br>```cpp<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<algorithm></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<cstdio></h1>using namespace std;<h1 id="define-l-x-t-x-l"><a href="#define-l-x-t-x-l" class="headerlink" title="define l(x) t[x].l"></a>define l(x) t[x].l</h1><h1 id="define-r-x-t-x-r"><a href="#define-r-x-t-x-r" class="headerlink" title="define r(x) t[x].r"></a>define r(x) t[x].r</h1><h1 id="define-k-x-t-x-k"><a href="#define-k-x-t-x-k" class="headerlink" title="define k(x) t[x].k"></a>define k(x) t[x].k</h1><h1 id="define-b-x-t-x-b"><a href="#define-b-x-t-x-b" class="headerlink" title="define b(x) t[x].b"></a>define b(x) t[x].b</h1>struct Segment_Tree<br>{<br> int l,r;<br> long long k,b;<br>}t[800010];<br>int n,m;<br>long long x,y,z,MOD=1e9+7,k[200010],b[200010];<br>void build(int p,int l,int r)<br>{<br> l(p)=l,r(p)=r;<br> if(l==r){k(p)=k[l],b(p)=b[l];return;}<br> int mid=(l+r)&gt;&gt;1;<br> build(2<em>p,l,mid);<br> build(2</em>p+1,mid+1,r);<br> k(p)=k(2<em>p)</em>k(2<em>p+1)%MOD,b(p)=(b(2</em>p)<em>k(2</em>p+1)%MOD+b(2<em>p+1))%MOD;<br>}<br>void change(int p,int x,long long K,long long B)<br>{<br> if(l(p)==r(p)&amp;&amp;l(p)==x){k(p)=K,b(p)=B;return;}<br> int mid=(l(p)+r(p))&gt;&gt;1;<br> if(x&lt;=mid) change(2</em>p,x,K,B);<br> else change(2<em>p+1,x,K,B);<br> k(p)=k(2</em>p)<em>k(2</em>p+1)%MOD,b(p)=(b(2<em>p)</em>k(2<em>p+1)%MOD+b(2</em>p+1))%MOD;<br>}<br>pair<long long,long long> ask(int p,int L,int R)<br>{<br> if(L&lt;=l(p)&amp;&amp;r(p)&lt;=R) return make_pair(k(p),b(p));<br> int mid=(l(p)+r(p))&gt;&gt;1;<br> pair<long long,long long> ansl=make_pair(1,0),ansr=make_pair(1,0);<br> if(L&lt;=mid) ansl=ask(2<em>p,L,R);<br> if(R&gt;mid) ansr=ask(2</em>p+1,L,R);<br> return make_pair(ansl.first<em>ansr.first%MOD,(ansl.second</em>ansr.first%MOD+ansr.second)%MOD);<br>}<br>int main()<br>{<br> scanf(“%d%d”,&amp;n,&amp;m);<br> for(int i=1;i&lt;=n;i++) scanf(“%lld%lld”,&amp;k[i],&amp;b[i]);<br> build(1,1,n);<br> for(int i=1;i&lt;=m;i++){<pre><code> char op[2];
 scanf(&quot;%s %lld%lld%lld&quot;,op,&amp;x,&amp;y,&amp;z);
 if(op[0]==&#39;M&#39;) change(1,x,y,z);
 else{
     pair&lt;long long,long long&gt; ans;
     ans=ask(1,x,y);
     printf(&quot;%lld\n&quot;,(ans.first*z%MOD+ans.second)%MOD);
 }
</code></pre> }<br>}</li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>BZOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>exLucas定理</title>
    <url>/2020/03/13/exLucas%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4720" target="_blank" rel="noopener">模板</a><br>这好像不是个定理……<br>看起来是个算法，但是不知道为什么大家都叫它定理，所以我也跟着写了……<br>还有，这玩意儿好像跟Lucas定理没有半毛钱关系，不知道为什么叫exLucas……<br><a id="more"></a></p>
<h6 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h6><p>为了学会这个“定理”，你需要了解几样东西：</p>
<ol>
<li>质因数分解</li>
<li>CRT（中国剩余定理）</li>
<li>逆元</li>
<li>其他基础的数论</li>
<li>组合数的定义（？？？）</li>
<li>好的视力，或者一个放大镜（因为有的又有分数又有上下标，很容易看不清）</li>
</ol>
<p>这些知识如果不会，可以参考我的<a href="https://jrjacky.github.io/2019/07/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/">另一篇博客</a>（5、6除外）</p>
<h6 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h6><p>下面的讲解有几个规定：</p>
<ol>
<li>$p$为模数</li>
<li>除了$p$以外的所有含$p$的字母默认为质数</li>
<li>所有的数都是非负整数</li>
<li>$i$的范围默认为距离这个$i$最近（上面）的一次定义的$i$的范围（可能在式子中）</li>
<li>与第四条类似，①式默认为距离这个①式最近（上面）的一次定义的①式</li>
</ol>
<h6 id="分解p"><a href="#分解p" class="headerlink" title="分解p"></a>分解p</h6><p>首先，我们要先将$p$进行质因数分解<br>设$p=\prod \limits_{i=1}^{t}p_i^{\alpha_i}$<br>这样，我们就只需要计算$\binom{n}{m}modp_i^{\alpha_i}(*)$，最后再用一下CRT就好了</p>
<h6 id="算-∗-式！"><a href="#算-∗-式！" class="headerlink" title="算(∗)式！"></a>算(∗)式！</h6><p>看到这个式子，有的同学就会说：看！$p_i$是质数！直接用Lucas定理算！<br>……首先，我说过，这玩意儿跟Lucas定理没有半毛钱关系；其次，它还有个次数$\alpha_i$啊！<br>首先，我们由组合数的定义可以知道：$\binom{n}{m}=\frac{n!}{m!(n-m)!}$<br>这时候，又有同学要说了：$\frac{1}{m!(n-m)!}$直接求逆元啊！<br>……求逆元的前提是互质啊！你看$m!(n-m)!$这个阶乘，它能跟$p_i$互质吗？<br>所以，我们得把这玩意儿中的$p_i$提出来……<br>假设$p^{k1}\mid\mid n!,p^{k2}\mid\mid m!,p^{k3}\mid\mid (n-m)!$<br>那么$\binom{n}{m}=\frac{\frac{n!}{p^{k1}}}{\frac{m!}{p^{k2}}\times\frac{(n-m)!}{p^{k3}}}\times p^{k1-k2-k3}$</p>
<h6 id="阶乘中质数的个数"><a href="#阶乘中质数的个数" class="headerlink" title="阶乘中质数的个数"></a>阶乘中质数的个数</h6><p>假设$p^\alpha\mid\mid n!$<br>首先考虑$n!\%p^k$咋算<br>$n!\%{p^k}={p^{n/p}}\times (n/p)!\times (\prod\limits_{i,gcd(i,p)=1}^{p^k}i)^{n/p^k}\times(\prod\limits_{i,gcd(i,p)=1}^{p\%k}i)\%p^k$<br>其中，$\prod\limits_{i,gcd(i,p)=1}^{p^k}i$是循环的，直接暴力枚举，然后快速幂<br>剩下的$\prod\limits_{i,gcd(i,p)=1}^{p\%k}i$是多余的部分，也直接暴力枚举就完了<br>最后递归一下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算n!%p^ppa</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cir=<span class="number">1</span><span class="comment">/*循环节*/</span>,rem=<span class="number">1</span><span class="comment">/*余数*/</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=ppa;i++) <span class="keyword">if</span>(i%p) cir=cir*i%ppa;</span><br><span class="line">    cir=POW(cir,n/ppa,ppa);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=ppa*(n/ppa);i&lt;=n;i++) <span class="keyword">if</span>(i%p) rem=rem*(i%ppa)%ppa;</span><br><span class="line">    <span class="keyword">return</span> fac(n/p,p,ppa)*cir%ppa*rem%ppa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接着，我们需要算出$\alpha$<br>这个就非常简单了，我们假设$p^{\alpha’}\mid\mid \left[\frac{n}{p}\right]!$<br>那么$\alpha=\left[\frac{n}{p}\right]+\alpha’$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum_fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//n!中p的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;p?<span class="number">0</span>:sum_fac(n/p,p)+(n/p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>回到①式，$\binom{n}{m}=\frac{\frac{n!}{p^{k1}}}{\frac{m!}{p^{k2}}\times\frac{(n-m)!}{p^{k3}}}\times p^{k1-k2-k3}$<br>所以我们可以得出整个计算①式的程序<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算n!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cir=<span class="number">1</span><span class="comment">/*循环节*/</span>,rem=<span class="number">1</span><span class="comment">/*余数*/</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=ppa;i++) <span class="keyword">if</span>(i%p) cir=cir*i%ppa;</span><br><span class="line">    cir=POW(cir,n/ppa,ppa);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=ppa*(n/ppa);i&lt;=n;i++) <span class="keyword">if</span>(i%p) rem=rem*(i%ppa)%ppa;</span><br><span class="line">    <span class="keyword">return</span> fac(n/p,p,ppa)*cir%ppa*rem%ppa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum_fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//n!中p的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;p?<span class="number">0</span>:sum_fac(n/p,p)+(n/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算Cnm%pi^ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fz=fac(n,p,ppa),fm1=ny(fac(m,p,ppa),ppa),fm2=ny(fac(n-m,p,ppa),ppa);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi=POW(p,sum_fac(n,p)-sum_fac(m,p)-sum_fac(n-m,p),ppa);</span><br><span class="line">    <span class="keyword">return</span> fz*fm1%ppa*fm2%ppa*mi%ppa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>解决了①式，剩下的部分就迎刃而解了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m,p,cnt<span class="comment">/*个数*/</span>,pr[<span class="number">1010</span>]<span class="comment">/*质数*/</span>,al[<span class="number">1010</span>]<span class="comment">/*指数*/</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> (<span class="keyword">void</span>)(x=<span class="number">1</span>,y=<span class="number">0</span>);</span><br><span class="line">    exgcd(b,a%b,x,y);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tmp=x;x=y;y=tmp-a/b*y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">ny</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x,y;</span><br><span class="line">    exgcd(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t=<span class="number">1</span>;</span><br><span class="line">    a%=p;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) t=t*a%p;</span><br><span class="line">        a=a*a%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算n!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cir=<span class="number">1</span><span class="comment">/*循环节*/</span>,rem=<span class="number">1</span><span class="comment">/*余数*/</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=ppa;i++) <span class="keyword">if</span>(i%p) cir=cir*i%ppa;</span><br><span class="line">    cir=POW(cir,n/ppa,ppa);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=ppa*(n/ppa);i&lt;=n;i++) <span class="keyword">if</span>(i%p) rem=rem*(i%ppa)%ppa;</span><br><span class="line">    <span class="keyword">return</span> fac(n/p,p,ppa)*cir%ppa*rem%ppa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">sum_fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span><span class="comment">//n!中p的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;p?<span class="number">0</span>:sum_fac(n/p,p)+(n/p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> p,<span class="keyword">long</span> <span class="keyword">long</span> ppa)</span><span class="comment">//计算Cnm%pi^ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fz=fac(n,p,ppa),fm1=ny(fac(m,p,ppa),ppa),fm2=ny(fac(n-m,p,ppa),ppa);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mi=POW(p,sum_fac(n,p)-sum_fac(m,p)-sum_fac(n-m,p),ppa);</span><br><span class="line">    <span class="keyword">return</span> fz*fm1%ppa*fm2%ppa*mi%ppa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span><span class="comment">//分解p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> P=p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">2</span>;i*i&lt;=p;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(P%i))&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ppa=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(!(P%i)) ppa*=i,P/=i;</span><br><span class="line">            pr[++cnt]=ppa;</span><br><span class="line">            al[cnt]=C(n,m,i,ppa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(P!=<span class="number">1</span>) pr[++cnt]=P,al[cnt]=C(n,m,P,P);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">crt</span><span class="params">()</span><span class="comment">//中国剩余定理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> M=p/pr[i],T=ny(M,pr[i]);</span><br><span class="line">        ans=(ans+al[i]*M%p*T%p)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exlucas</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> m)</span><span class="comment">//扩展卢卡斯 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pfd(n,m);</span><br><span class="line">    <span class="keyword">return</span> crt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;exlucas(n,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>西安集训日记</title>
    <url>/2020/02/13/%E8%A5%BF%E5%AE%89%E9%9B%86%E8%AE%AD%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<p>这个学期，我被老师叫去跟一群高一的神犇一起去西安集训，从9号到19号<del>其实就是为了逃课</del>，这篇文章就是我这11天的日记<br><a id="more"></a></p>
<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h1><p>8号我找出了出行学习的计划，从洛谷日报里找了一些有用的东西预习了一下</p>
<h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>早上坐飞机到西安，中午在外面乱吃了一些东西之后，去买了一堆生(wéi)活(jìn)物品，跟保安说我们是来训练的，就莫名其妙地进去了……<del>吐槽一句，这里的宿舍是真的脏</del><br>下午原来想去机房，但是听说机房还在维修，所以去篮球场打了好几个小时的篮球，打到我们要去吃饭为止</p>
<p>晚上翻出我电脑里的一堆资料，预习了一番</p>
<h1 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上不知道为什么，精神充沛，6点就醒了，宿舍没开灯，我就准备等到其他人都起来了，再开灯。等其他人醒来了，我才发现一个严重的问题：宿舍灯开不了！所以我摸着黑，干完了早上该干的事情。到了7点，灯才亮……<br>直接在宿舍楼下买了一个面包，就匆匆赶去机房准备考试<br>一进机房，就看到一堆蓝蓝的屏幕（蓝屏了）这就是他们昨天修电脑的结果？7:30，开始考试了。这里考试的规则也是诡异，我们可以开网，但是除了一个叫做<a href="accoders.com">accoders</a>的OJ可以开<del>貌似我们学校的OJ也开得起来</del>。考试的名字叫“NOI 2020 模拟赛Contest 1”，还写了一堆文件名，导致我们有一个傻(shén)逼(bēn)打了freopen，爆零了。<br>第一题是道概率题，不会，乱打了一个表，0分……第二题好像是个二分，可惜我不知道怎么二分，打了一个DFS，50分。第三题又是一个数学题，考集合的子集，不会做，直接暴力枚举子集，40分。总分90分，第34名（一共39个人），接近垫底，最高220分……<br>中午看了一下题解，第一题好像很水，很快就过了。一看第二题的题解，我人都傻了。由于数据是随机的，所以要用随机算法！我发现一堆人尝试了好几十次才过，所以我决定放弃这种牛(shǎ)逼的题目。（ps:现在的情况：提交722，解决:60）第三题的题解又是我看不懂的东西。质因数分解要用$O(\sqrt[3]{n})$的算法，判断质数还要用什么Miller Rabin算法，然后复杂度还是$O(\sqrt[3]{n}+3^{\omega(n)}\omega(n))$……去<del>网上</del>一个神犇那里找了一个Miller Rabin算法，直接复制，又看到了一个诡异的函数：random……这是什么毒瘤考试啊，考了两道随机数算法……<br>下午讲了一堆毒瘤题目，一题都不会，就在机房刷水题，晚上也是</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>早上起来又没有灯……<br>机房的电脑都修好了，体验也比昨天好。今天考试的名字令人疑惑：“NOIP 2019 模拟赛Contest 7”？？？不是只有CSP吗，NOIP不是SPFA了吗？第一题看一眼就知道是要用DP，就是不会做。于是就暴力枚举所有的子串，一个个判断，15分。第二题没有思路，胡乱找了一个规律，后来发现是错的，就准备达35分的表。有一个表打错了，15分。第三题用树状数组求逆序对，考试时就A了。一共130分，第15名。我仔细一看，居然有4个人AK了！我还是太菜了……<br>中午看题解，第一题果然是DP，但是很难理解，我们讨论了半天才做出来。第二题是个二分，一群人被二分的范围坑了，做了半天没A。<br>下午讲数据结构，还行，听的效果挺好的。晚上A了下午讲的题目，感觉还好。</p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>今天的名字总算正常了一点，就叫做模拟赛。我们看到有输入输出文件名，就打了freopen，结果，所有人都爆零……<br>第一题写了正解，但是n忘记减1了，80分……第二题显然是个DP，不会写，乱写了一个贪心，0分……第三题写了一个奇怪的方法，原来20分的，后来多测忘记回车了……共80分，不知道排名，只知道又有一个人AK了……<br>中午，我发现了一个问题：这个题目居然是提高组的模拟赛，而且我们学校的OJ上有！可惜我考试的时候没有开OJ（开了好像也没有什么用）而且这个题解，在网上都找得到……第二题是一个诡异的DP，不会写。第三题也是DP，状态定义有点奇怪，写出来了。<br>下午的数据结构有点恶心，晚上只写了3道题，就是细节太多了，查了好久的错……</p>
<h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>今天的比赛名字是假的，叫小S的欢乐赛，事实告诉我，这个比赛一点都不欢乐。第一题根本不知道是什么鬼，随便写了一个暴力DP，70分。第二题不会，根本没做。第三题写了一个特判，25分。一共95分，第19名。<br>下午有讲毒瘤的图论，又去刷水题了……<br>晚上才看了题解。这题目是真的毒瘤。第一题因为是随机数，最长上升子序列长度期望是$\sqrt{n}$。第二题是一个什么FFT，根本不知道是什么鬼。第三题就更懵逼了，什么数位DP，还是5维的！我把第一题做完就去刷水题了。</p>
<h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>今天上午讲了一大堆DP，没听懂多少，所以去洛谷日报里学了一下。<br>下午和晚上都在刷题。</p>
<h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>今天讲自动机和border，还回答了弱周期定理的证明。中午把模板A了。<br>下午测试的名字极其诡异：“CCF全国信息学奥林匹克联赛（CSP2020）复赛<br>提高组 day2”？？？透题？？？假的吧。第一题不会写，写了一个特判，48分。第二题就更不会了，是个毒瘤计算几何。第三题写了个特判，20分。一共68分，第22名。<br>晚上看了一下题解，第一题要推式子，第二题果然是个毒瘤题，要先证明两个引理，再暴力判断，细节实在是太多了，我调了一个晚上+半个早上。第三题先搞一个线段树，对于每个询问，再二分答案。</p>
<h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><p>今天早上老师安排这几次考试比较好的同学给我们讲题。我就在底下改我的第二题。成为了第一个3题都改对的人。<br>下午和晚上都在刷题。</p>
<h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><p>早上讲数学，挺简单的，还去回答了一个问题，后来我就没在听了。<br>下午考试超级难，一开始很累，导致我第一题用了$90\%$的时间，只有14分。第二题没写完，第三题根本没写。<br>考完试准备看题解，却发现题解是题目……还好旁边有个傻(shén)逼(bēn)（就是上次开了freopen的那个傻(shén)逼(bēn)）知道第二题思路，他写完之后就开心地交了。结果0分！所以这个神犇就把程序发给我，让我对拍<del>其实是我想要他的程序</del>，找到了一个错误的点，他<del>1</del>亿会儿就改完了。他又开心地交上去：80分！我立刻开启两个对拍，CPU利用率达到了$90\%$！拍到了10000也没有用。最后的问题是：没开long long……</p>
<h1 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h1><p>早上讲博弈论和计算几何，好难。但是第一道例题是个超级大水题，我上去凑了个热闹之后，就开始在座位上改题。<br>下午的考试只会第三题。我写了正解，但是有一点点小错误。我只对拍了其中一种情况，然后骄傲的跟我旁边那个人说：“看！我全对！”最后35分……<br>考完后看了看题解，第一题乍一看是个图论，但是其实就是推一个式子！抄下式子，3分钟搞定。第二题是个二分再加容斥，我看了半天没看懂。还好有神犇给我解释，我才会做。第三题改了一下小错误，一下就过了。</p>
<h1 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h1><p>都最后一天了，早上还考试……我也不想说什么了，爆零了……<br>考完试就溜了，去赶飞机了，题解没有看……</p>
<hr>
<p>这就是我去西安10天的学习。这十天，我不但收获了新知识，还大大开阔了我的视野，也结识了许多神犇，这也是我第一次出外进行集训，希望以后能有更多这样的机会。</p>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>去完西安后，我的文化课从40名下降道了66名，也不知道老师会不会再让我出去了……</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分之积分</title>
    <url>/2020/02/13/%E5%BE%AE%E7%A7%AF%E5%88%86%E4%B9%8B%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="一、不定积分"><a href="#一、不定积分" class="headerlink" title="一、不定积分"></a>一、不定积分</h1><p>不定积分本质上就是导数的逆运算<br><strong>注意！许多函数的积分是算不出来的，所以，不要随便问别人一个函数的积分</strong><br><a id="more"></a><br>由于常数的导数为$0$，所以，一个不定积分的结果会是这样的：$\int f(x)dx=g(x)+C$，其中，$C$是一个常数</p>
<h2 id="1、不定积分运算法则"><a href="#1、不定积分运算法则" class="headerlink" title="1、不定积分运算法则"></a>1、不定积分运算法则</h2><h3 id="1-加减法"><a href="#1-加减法" class="headerlink" title="(1)加减法"></a>(1)加减法</h3><p>$\int f(x)dx+\int g(x)dx=\int \left(f(x)+g(x)\right)dx$</p>
<h3 id="2-乘除法"><a href="#2-乘除法" class="headerlink" title="(2)乘除法"></a>(2)乘除法</h3><p>然而并没有这种东西……</p>
<h2 id="2、求不定积分的常见方法"><a href="#2、求不定积分的常见方法" class="headerlink" title="2、求不定积分的常见方法"></a>2、求不定积分的常见方法</h2><h3 id="1-第一类换元法"><a href="#1-第一类换元法" class="headerlink" title="(1)第一类换元法"></a>(1)第一类换元法</h3><p>我之前讲过一个求导的公式——$(f(g(x)))’=f’(g(x))\times g‘(x)$（忘了？不知道？点<a href="https://blog.csdn.net/weixin_43849488/article/details/97966479" target="_blank" rel="noopener">这里</a>），那么我们可以得到$\int f’(g(x))\times g’(x)dx=f(g(x))$，把$g‘(x)$塞到$dx$中变成$dg(x)$，也就是$\int f’(g(x))\times dg(x)=f(g(x))$——这个公式就是第一类换元法<br>第一类换元法的应用很广，接下来我举几个例子供大家参考</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>求$\int sinx\cdot cosxdx$</p>
<hr>
<p>法一：$\int sinx\cdot cosxdx=\int sinx\cdot (sinx)’dx=\int sinxdsinx=\frac{1}{2}(sinx)^2+C$</p>
<hr>
<p>法二：$\int \frac{1}{2}sin2xdx=\int \frac{1}{4}sin2xd2x=-\frac{1}{4}cos2x+C$<br><strong>注意！+C是不可省略的！+C是不可省略的！+C是不可省略的！</strong><br>两种方法做的结果看似不一样，其实是一样的，只是在没有$+C$的情况下常数不同<br>这就是我强调要$+C$的原因</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>求$\int \frac{dx}{1+e^x}$</p>
<hr>
<p>$\int \frac{dx}{1+e^x}=\int \frac{e^xdx}{(1+e^x)e^x}=\int \frac{de^x}{e^x(1+e^x)}=\int \left(\frac{1}{e^x}-\frac{1}{e^x+1}\right)de^x=lne^x-ln\left(1+e^x\right)+C=x-ln\left(1+e^x\right)+C$<br>这一题巧妙地运用了$\left(e^x\right)’=e^x$的特殊性，再用第一类换元法和裂项解决</p>
<h3 id="2-第二类换元法"><a href="#2-第二类换元法" class="headerlink" title="(2)第二类换元法"></a>(2)第二类换元法</h3><p>第二类换元法和第一类换元法很像，就是最后一步的变形：$\int f’(g(x))\times g’(x)dx=\int f’(g(x))\times dg(x)$<br>第二类换元法一般会和三角换元有关，基本上都是那种带根号的式子</p>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>求$\int \frac{dx}{\sqrt{1-x^2}}$</p>
<hr>
<p>设$x=sin\theta$<br>$\int \frac{dx}{\sqrt{1-x^2}}=\int \frac{dsin\theta}{cos\theta}=\int \frac{cos\theta d\theta}{cos\theta}=\int d\theta=\theta+C=arcsinx+C$<br>这就是第二类换元法的应用，将$x$巧妙地进行三角换元，得到最后消掉的局面<br>大家不要小看这种换元方法，第二类换元法的题目可以出得很难</p>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>求$\int \frac{t^2dt}{\sqrt[3]{t-5}}$</p>
<hr>
<p>设$x=\sqrt[3]{t-5}$<br>$\int \frac{t^2dt}{\sqrt[3]{t-5}}=\int \frac{(x^6+10x^3+25)\cdot 3x^2dx}{x}=3\int (x^7+10x^4+25x)dx=3\cdot (\frac{1}{8}x^8+2x^5+\frac{25}{2}x^2)+C$（答案太丑了，不写了）<br>一看到题目，可能很多人就傻眼了——这东西能积分吗？答案是能的，只是很麻烦<br>看到题目的第一反应应该是先把那个恶心的根号换元，接着能不能做再说</p>
<h3 id="3-部分积分法"><a href="#3-部分积分法" class="headerlink" title="(3)部分积分法"></a>(3)部分积分法</h3><p>在求导的时候，我们学过一个公式——$(uv)’=u’v+uv’$，我们把两边同时积分，就可以得到$\int (uv)’dx=\int u’vdx+\int uv’dx+C$，左边的积分和求导抵消掉，变成$uv=\int u’vdx+\int uv’dx+C$<br>这个式子并不是最常用的，常用的是移项并用第二类换元法之后的结果——$\int udv=uv-\int vdu+C$<br>当$\int udv$不好求，但是$\int vdu$好求的时候，这个式子就排上用场啦！</p>
<h4 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h4><p>求$\int xcosxdx$</p>
<hr>
<p>$\int xcosdx=\int x(sinx)’dx=xsinx-\int (x)’sinxdx+C=xsinx-\int sinxdx+C=xsinx+cosx+C$<br>这一个看似奇怪的函数，却被我们几下搞定<br>这题巧用了$(x)’=1$的性质，把$x$消掉，变成$sinx$的积分</p>
<h4 id="例题6"><a href="#例题6" class="headerlink" title="例题6"></a>例题6</h4><p>求$\int arctanxdx$</p>
<hr>
<p>$\int arctanxdx=xarctanx-\int x\frac{dx}{x^2+1}+C=xarctanx-\frac{1}{2}\int \frac{d(x^2+1)}{x^2+1}+C=xarctanx-\frac{1}{2}ln(x^2+1)+C$<br>这题再次巧用$(x)’=1$的性质，无中生有一个$x$，最后又在把$x$丢到$dx$中的时候巧妙地加了一个常数，使得刚好凑成$\frac{1}{x}$的形式</p>
<h4 id="例题7"><a href="#例题7" class="headerlink" title="例题7"></a>例题7</h4><p>求$\int e^xcosxdx$</p>
<hr>
<p>$\int e^xcosxdx=\int e^xdsinx=e^xsinx-\int sinxe^xdx+C=e^xsinx+\int e^xdcosx+C=e^xsinx+e^xcosx-\int e^xcosxdx+C$<br>$\therefore 2\times\int e^xcosxdx=e^x(sinx+cosx)+C$<br>$\therefore \int e^xcosxdx=\frac{e^x(sinx+cosx)}{2}+C$<br>这题巧妙运用$\left((cosx)’\right)’=-cosx$的循环性，制造出一个循环，再除以二</p>
<h3 id="4-一种有理函数求积分的好方法"><a href="#4-一种有理函数求积分的好方法" class="headerlink" title="(4)一种有理函数求积分的好方法"></a>(4)一种有理函数求积分的好方法</h3><p>在计算一个有理函数$\frac{p(x)}{q(x)}$的积分时，我们可以采用接下来介绍的一种方法<br>这种方法很复杂，初学者建议跳过</p>
<h4 id="a、部分分式化"><a href="#a、部分分式化" class="headerlink" title="a、部分分式化"></a>a、部分分式化</h4><p>在求有理函数的积分前，我们先要对这个函数进行一些操作，在我以前学数竞的时候，老师曾经告诉过我们，这是一个求微积分才会用到的知识<br>首先，我们要先将这个函数中的$0$次及以上的系数分离，就是做一次大除法（不要问我大除法是什么，就是多项式除法，因为我没办法写竖式，所以无法展示出计算过程）<br>假设$p(x)\div q(x)=r(x)\cdots\cdots s(x)$，那么我们直接处理$\frac{s(x)}{q(x)}$就可以了<br>第二步，把q(x)分解质因式，假设是$a_1(x)^{b_1}\cdot a_2(x)^{b_2}\cdots\cdots a_k(x)^{b_k}$<br>第三步，把整个式子拆成这样：$\frac{p(x)}{q(x)}=\sum\limits_{i=1}^{k}\sum\limits_{j=1}^{b_i}\frac{\sum\limits_{l=0}^{a_i(x)\text{的次数}-1} \text{一个系数}\times x^l}{(a_i(x))^j}$<br>相信大家看了这个式子后一定是懵逼的，所以我来举个例子<br>比如$q(x)=(x-1)(x+4)^3(x^2+4x+7)(3x^2-x+1)$，我们就把这个式子拆成$\frac{A}{x-1}+\frac{B}{(x+4)^3}+\frac{C}{(x+4)^2}+\frac{D}{x+4}+\frac{Ex+F}{x^2+4x+7}+\frac{Gx+H}{3x^2-x+1}$<br>那这个式子要怎么拆开呢？接下来我就再举一个例子</p>
<h5 id="例题8"><a href="#例题8" class="headerlink" title="例题8"></a>例题8</h5><p>把$\frac{x+2}{x^2-1}$部分分式化</p>
<hr>
<p>首先，这个函数可以拆成$\frac{A}{x-1}+\frac{B}{x+1}$<br>所以，我们可以把$\frac{A}{x-1}+\frac{B}{x+1}$合并起来，得到$\frac{A(x+1)+B(x-1)}{x^2-1}=\frac{x+2}{x^2-1}$<br>把分母消掉并合并同类项：$x+2=(A+B)x+(A-B)$<br>这样，我们就可以得到一个方程组：$\begin{cases}A+B=1\\A-B=2\end{cases}$<br>解得$\begin{cases}A=\frac{3}{2}\\B=-\frac{1}{2}\end{cases}$<br>所以，$\frac{x+2}{x^2-1}$部分分式化的结果就是$\frac{\frac{3}{2}}{x-1}-\frac{\frac{1}{2}}{x+1}$</p>
<h4 id="b、积分！"><a href="#b、积分！" class="headerlink" title="b、积分！"></a>b、积分！</h4><p>做完部分分式化的操作后，我们终于到了积分的环节<br>我们把这个式子部分分式化了之后，我们就可以逐个来积分了<br>首先我们来解决最简单的$q(x)$是一次的形式：$\int \frac{1}{ax+b}dx$<br>设$t=ax+b$<br>$\int \frac{1}{t}dx=\int \frac{1}{t}d(\frac{t-b}{a})=\frac{1}{a}\int \frac{1}{t}dt=\frac{1}{a}lnt+C=\frac{1}{a}ln(ax+b)+C$<br>大家觉得这个结果对吗？<br>答案是：这个结果是<strong>错的！错的！错的！</strong><br>为什么？这看起来没有错啊<br>问题在于当$ax+b&lt;0$时，就不能取对数了，所以正确答案是$\frac{1}{a}ln|ax+b|+C$<br>处理完一次式，我们再来处理一下二次式$\int \frac{Ax+B}{ax^2+bx+c}dx$<br>首先，我们进行配方$ax^2+bx+c=a(x+\frac{b}{2a})^2+\frac{4ac-b^2}{4a}$<br>设$x+\frac{b}{2a}=t$<br>$\int \frac{Ax+B}{ax^2+bx+c}dx=\int \frac{At+B-\frac{b}{2a}}{at^2-\frac{4ac-b^2}{4a}}dt=A\int \frac{t}{at^2+\frac{4ac-b^2}{4a}}dt+(B-\frac{b}{2a})\int \frac{1}{at^2+\frac{4ac-b^2}{4a}}dt$<br>现在的式子<del>有点</del>非常恶心，所以我们分两边处理<br>$\int \frac{t}{at^2-\frac{4ac-b^2}{4a}}dt=\frac{1}{2a}\int \frac{2at}{at^2+\frac{4ac-b^2}{4a}}dt=\frac{1}{2a}\int \frac{1}{at^2+\frac{4ac-b^2}{4a}}d\left(at^2\right)=\frac{1}{2a}ln|at^2+\frac{4ac-b^2}{4a}|+C=\frac{1}{2a}ln|ax^2+bx+c|+C$<br>至于右边，只需要记住一个公式：$\int \frac{1}{x^2+a^2}dt=\frac{1}{a}arctan\left(\frac{x}{a}\right)+C$（这其实就是一份第二类换元法，可以参照例3的做法）<br>问题是，我的式子中的所谓的$a^2$是$\frac{4ac-b^2}{4a}$！它大于0吗？<br>现在，你终于要知道我们为啥要部分分式化了<br>之所以这是一个二次式，是因为它无法因式分解！所以，它的$\Delta=b^2-4ac&lt;0$！所以，$\frac{4ac-b^2}{4a}$大于0<br>所以，$\int \frac{1}{at^2+\frac{4ac-b^2}{4a}}dt=\frac{1}{\sqrt{\frac{4ac-b^2}{4a}}}arctan\left(\frac{\sqrt{a}t}{\sqrt{\frac{4ac-b^2}{4a}}}\right)+C$<br>最后，我们把这两个部分合起来，$\int \frac{Ax+B}{ax^2+bx+c}dx=\frac{A}{2a}ln|ax^2+bx+c|+\frac{B-\frac{b}{2a}}{\sqrt{\frac{4ac-b^2}{4a}}}arctan\left(\frac{\sqrt{a}x+\sqrt{a}\frac{b}{2a}}{\sqrt{\frac{4ac-b^2}{4a}}}\right)+C$<br>又是一个令人无语的式子，这个式子太复杂了，以至于我相信没有人能背下来（包括我）<br>一般这种题目不会出得这么恶心，会出一些凑好的数给你<br>对于更高次的积分，你就只需要像二次一样，把它降次打击，就可以了<br>说着简单，做起来却很难<br>所以我告诫大家：积分千万条，生命第一条，积分用手算，一天写不完</p>
<h4 id="方法总结"><a href="#方法总结" class="headerlink" title="方法总结"></a>方法总结</h4><p>相信大家已经对这种有理函数求积分的好方法有了一定的了解，我给大家总结一下这种方法的步骤</p>
<ol>
<li>先看分子分母最高项的次数，如果有必要请做除法</li>
<li>对分母进行因式分解</li>
<li>分部</li>
<li>计算常数的值（以上为部分分式化内容）</li>
<li>积分<h4 id="例题9"><a href="#例题9" class="headerlink" title="例题9"></a>例题9</h4>求$\int \frac{x^5-7x^4+19x^3-10x^2-19x+18}{x^4-5x^3+9x^2}dx$</li>
</ol>
<hr>
<p>$\int \frac{x^5-7x^4+19x^3-10x^2-19x+18}{x^4-5x^3+9x^2}dx=\int \left(x-2+\frac{8x^2-19x+18}{x^4-5x^3+9x^2}\right)dx=\frac{x^2}{2}-2x+\int \frac{8x^2-19x+18}{x^4-5x^3+9x^2}dx+C=\frac{x^2}{2}-2x+\int \frac{8x^2-19x+18}{x^2(x^2-5x+9)}dx+C=\frac{x^2}{2}-2x+\int \frac{2(x^2-5x+9)-x(x^2-5x+9)+(x+1)x^2}{x^2(x^2-5x+9)}dx+C=\frac{x^2}{2}-2x+\int\left(\frac{2}{x^2}-\frac{1}{x}+\frac{x+1}{x^2-5x+9}\right)dx+C=\frac{x^2}{2}-2x-\frac{2}{x}-ln|x|+\frac{ln(x^2-5x+9)}{2}+\frac{7arctan\left(\frac{2x-5}{\sqrt{11}}\right)}{\sqrt{11}}+C$<br>这就是不定积分的全部内容了，下面给大家几道练习题：</p>
<ol>
<li>$\int tanxdx$</li>
<li>$\int sin(ax+b)dx$</li>
<li>$\int \frac{x}{1+x^4}dx$</li>
<li>$\int \frac{1}{a^2-x^2}dx$</li>
<li>$\int \sqrt{a^2-x^2}dx$</li>
<li>$\int \frac{1}{\sqrt{a^2-x^2}}dx$</li>
<li>$\int \frac{1}{\sqrt{x^2-a^2}}dx$</li>
<li>$\int x^3lnxdx$</li>
<li>$\int x^2e^xdx$</li>
<li>$\int e^xsinxdx$</li>
<li>$\int \frac{x+2}{x^2-1}dx$</li>
<li>$\int \frac{x+8}{x^2+6x+13}dx$<h1 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h1>定积分的定义：$f(x)$在$[a,b]$上的函数图像的面积（这并不是定积分严格的定义，为了让大家好理解，把它写成这样了。原来的定义是：$\int_a^b f(x)dx=\lim \limits_{mesh\to 0} f(c_j)(x_j-x_{j-1})$，其中$a=x_0&lt;x_1&lt;\cdots \cdots&lt;x_n=b$且$\forall j\in [1,n],j\in \Z,c_j\in [x_j-1,x_j]$）<br><img src="https://img-blog.csdnimg.cn/20200126182607488.png" alt="在这里插入图片描述"><br>举个例子，$\int_a^bxdx=(a+b)*(a-b)/2$，直接画出图像，用梯形的面积计算即可<h2 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h2></li>
<li>$\int_a^b f(x)dx=-\int_b^a f(x)dx$</li>
<li>$\int_a^a f(x)dx=0$</li>
<li>$\int_a^b f(x)dx=\int_a^c f(x)dx+\int_c^b f(x)dx$</li>
<li>$\int_a^b Cf(x)dx=C\int_a^b f(x)dx$</li>
<li>$\int_a^b(f(x)+g(x))dx=\int_a^bf(x)dx+\int_a^bg(x)dx$</li>
</ol>
<p>定积分的这些性质都很显然，按照定义来看就知道了</p>
<h2 id="微积分基本定理"><a href="#微积分基本定理" class="headerlink" title="微积分基本定理"></a>微积分基本定理</h2><h3 id="微积分的第一基本定理"><a href="#微积分的第一基本定理" class="headerlink" title="微积分的第一基本定理"></a>微积分的第一基本定理</h3><p>$\frac{d}{dx}\int_a^x f(t)dt=f(x)$<br>这个式子还是很显然，不行的自己画个图<br>我们把形如$\int_a^x f(t)dt$的式子，我们称为变上限积分</p>
<h3 id="微积分的第二基本定理"><a href="#微积分的第二基本定理" class="headerlink" title="微积分的第二基本定理"></a>微积分的第二基本定理</h3><p>$\int_a^b f(x)dx=\int f(b)dx-\int f(a)dx$<br>在知道微积分的第一基本定理后，我们就能很容易地推出微积分的第二基本定理了，现在知道这两个看似无关的东西的关联了吧？<br>定积分的内容比较少，因为它的计算就是通过微积分的第二基本定理，计算出该函数的不定积分，再相减，得出定积分。因此，我也没有给大家练习题了。这就是本篇文章的全部内容了，因为我的能力有限，写得不好的地方请大家多多包容。<br><strong>参考材料：</strong><br><strong>1、《普林斯顿微积分读本》Adrian Banner 著 杨爽 赵晓婷 高璞 译</strong></p>
]]></content>
      <categories>
        <category>物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>DTOJ Begin4028 DTOJ3603 table</title>
    <url>/2019/09/22/DTOJ-Begin4028%20-DTOJ3603-table/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><code>C</code> 酱有一个$m \times n$的数表，行与列的编号都从$1$开始。令$f_{i,j}$表示表格第$i$行第$j$列内的数，那么对于表格的第$i(i&gt;1)$行有</p>
<script type="math/tex; mode=display">\begin{cases}f_{i,1}=a \times f_{i-1,1}\\f_{i,j}=a\times f_{i-1,j}+b\times f_{i-1,j-1}\end{cases}</script><p>然而 <code>C</code> 酱已经把表格中的数忘得差不多了，他现在只记得第$p$行的数。他希望你能够帮忙还原出部分位置的数值。</p>
<a id="more"></a>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行为$6$个整数$m,n,a,b,p,q$，其中$q$表示询问的个数。  </p>
<p>接下来一行共$n$个整数，依次表示$f_{p,1},f_{p,2},\cdots,f_{p,n}$。  </p>
<p>接下来$q$行，每行两个整数$x,y$，表示 <code>C</code> 酱询问你$f_{x,y}$的数值。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共$q$行，依次表示每个询问的答案在模$998244353$意义下的取值。  </p>
<p>即设答案可以表示为分式$\frac{a}{b}$ ，则输出整数$x$使得$b \times x \equiv a \pmod {998244353}$且$0  \leqslant x &lt; 998244353$。可以证明这样的整数$x$是唯一的。</p>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 1"></a>样例输入 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4 1 1 3 5</span><br><span class="line">1 0 0 0</span><br><span class="line">5 2</span><br><span class="line">3 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 1"></a>样例输出 1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">998244351</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 2"></a>样例输入 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 5 233 2333 6 4</span><br><span class="line">9 3 1 0 10</span><br><span class="line">1 5</span><br><span class="line">10 2</span><br><span class="line">5 3</span><br><span class="line">8 1</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 2"></a>样例输出 2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110343631</span><br><span class="line">118211750</span><br><span class="line">770559638</span><br><span class="line">488601</span><br></pre></td></tr></table></figure>
<h2 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">测试点编号</th>
<th style="text-align:center">$n$</th>
<th style="text-align:center">$m$</th>
<th style="text-align:center">$a,b$</th>
<th style="text-align:center">$p$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$1,2$</td>
<td style="text-align:center">$\leqslant 100$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">$p=1$</td>
</tr>
<tr>
<td style="text-align:center">$3,4$</td>
<td style="text-align:center">$\leqslant 100$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$a=b=1$</td>
<td style="text-align:center">−</td>
</tr>
<tr>
<td style="text-align:center">$5,6,7,8$</td>
<td style="text-align:center">$\leqslant 100$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">−</td>
</tr>
<tr>
<td style="text-align:center">$9,10,11,12$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">$p=1$</td>
</tr>
<tr>
<td style="text-align:center">$13,14,15,16$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">$p=m$</td>
</tr>
<tr>
<td style="text-align:center">$17,18,19,20$</td>
<td style="text-align:center">$\leqslant 10^5$</td>
<td style="text-align:center">$\leqslant 10^7$</td>
<td style="text-align:center">−</td>
<td style="text-align:center">−</td>
</tr>
</tbody>
</table>
</div>
<p>对于$100\%$的数据，保证$1 \leqslant q \leqslant 100 , 1 \leqslant x , p \leqslant m , 1 \leqslant y \leqslant n , 1 \leqslant a,b &lt; 998244353,0 \leqslant f_{i,j} &lt; 998244353$。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="40分算法"><a href="#40分算法" class="headerlink" title="40分算法"></a>40分算法</h2><p>暴力把所有格子算出来<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m,n,a,b,p,q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ny,f[<span class="number">100010</span>][<span class="number">110</span>],MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;q;</span><br><span class="line">    ny=POW(a,MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;f[p][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[i][j]=((a*f[i<span class="number">-1</span>][j])%MOD+(b*f[i<span class="number">-1</span>][j<span class="number">-1</span>])%MOD)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=p<span class="number">-1</span>;i&gt;<span class="number">0</span>;i--) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[i][j]=(((f[i+<span class="number">1</span>][j]-(b*f[i][j<span class="number">-1</span>])%MOD)%MOD*ny)%MOD+MOD)%MOD;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=q;i++) <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y,<span class="built_in">cout</span>&lt;&lt;f[x][y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AC算法"><a href="#AC算法" class="headerlink" title="AC算法"></a>AC算法</h1><p>我们先分类讨论，在第$p$行下和在第$p$行上<br>若在第$p$行下，我们可以由上面的两个点得出下面一个点<br><img src="https://img-blog.csdnimg.cn/20190922124118645.png" alt=""><br>由题目可知，$f_{i,j}=a\times f_{i-1,j}+b\times f_{i-1,j-1}$</p>
<p>所以，我们考虑第$p$行中，要求的点$(x,y)$左侧的点$(p,i)$（即$i\leqslant y$），它对$(x,y)$的贡献就是$(p,i)$到$(x,y)$的路径条数（只能向右下或向下走）$\times a^{\cdots}\times b^{\cdots}$</p>
<p>我们只需要求$(p,i)$到$(x,y)$的路径条数和$a$、$b$的次数</p>
<p>假设$n=x-p,m=y-i$，那么，我们可以知道我们一共需要走$n$步，向右下走$m$步，所以路径数就是$C^m_n$</p>
<p>所以最终的结果就是：$C^m_n\times a^{n-m}\times b^{m}$<br><img src="https://img-blog.csdnimg.cn/20190922125117710.png" alt=""><br>所以我们还能得到一个范围：$n\geqslant m$<br>终于，我们解决了$(x,y)$在在$p$行下，即$x&gt;p$的情况，接下来，我们讨论一下$x&lt;p$的情况</p>
<p>同样，我们可以通过下面的和他左边的点得到这个位置的值，$f_{i,j}=\frac{f_{i+1,j}}{a}-\frac{b\times f_{i,j-1}}{a}$，那么，问题就变成考虑第$p$行中，要求的点$(x,y)$左侧的点$(p,i)$（即$i\leqslant y$），它对$(x,y)$的贡献就是$(p,i)$到$(x,y)$的路径条数（只能向上或右走）$\times a^{\cdots}\times \left(-\frac{b}{a}\right)^{\cdots}$</p>
<p>同样假设$n=p-x,m=y-i$，但是，不一样的地方在于第一步必须向上走！所以，我们可以知道去掉先向上走的一步后，一共需要走$n+m-1$步，向右走$m$步，所以路径数就是$C^m_{n+m-1}$</p>
<p>所以最终的结果就是：$C^m_{n+m-1}\times a^{n}\times \left(-\frac{b}{a}\right)^{m}$</p>
<p><img src="https://img-blog.csdnimg.cn/20190922131247325.png" alt=""></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol>
<li>取模</li>
<li>阶乘的逆元可以反着算，$invjc_i=invjc_{i+1}*(i+1)$，这样就避免了多次的$pow$</li>
<li>提前保存$a$的逆元</li>
<li>提前保存$-\frac{b}{a}$的次方，避免计算$-1^{y-i}$</li>
<li>$x&lt;p$的情况中，是$C^m_{n+m-1}$<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,p,q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b,MOD=<span class="number">998244353</span>,f[<span class="number">10100010</span>],jc[<span class="number">10100010</span>],cj[<span class="number">10100010</span>],pa[<span class="number">10100010</span>],pb[<span class="number">10100010</span>],ap[<span class="number">10100010</span>],bp[<span class="number">10100010</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f：第p行的值</span></span><br><span class="line"><span class="comment">jc：阶乘</span></span><br><span class="line"><span class="comment">cj：阶乘的逆元</span></span><br><span class="line"><span class="comment">pa：a的次方</span></span><br><span class="line"><span class="comment">pb：b的次方</span></span><br><span class="line"><span class="comment">ap：pa的逆元</span></span><br><span class="line"><span class="comment">bp：-b/a的次方 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">POW</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span><span class="comment">//快速幂 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=(ans*a)%MOD;</span><br><span class="line">        a=(a*a)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//求组合数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||y&gt;x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> jc[x]*cj[y]%MOD*cj[x-y]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;p&gt;&gt;q;</span><br><span class="line">    jc[<span class="number">0</span>]=pa[<span class="number">0</span>]=pb[<span class="number">0</span>]=ap[<span class="number">0</span>]=bp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10100000</span>;i++) jc[i]=jc[i<span class="number">-1</span>]*i%MOD;<span class="comment">//暴力求阶乘 </span></span><br><span class="line">    cj[<span class="number">10100000</span>]=POW(jc[<span class="number">10100000</span>],MOD<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10099999</span>;i&gt;=<span class="number">0</span>;i--) cj[i]=cj[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;<span class="comment">//反向求阶乘的逆元 </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> na=POW(a,MOD<span class="number">-2</span>),nb=MOD-(b*na%MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10100000</span>;i++) pa[i]=pa[i<span class="number">-1</span>]*a%MOD,pb[i]=pb[i<span class="number">-1</span>]*b%MOD,ap[i]=ap[i<span class="number">-1</span>]*na%MOD,bp[i]=bp[i<span class="number">-1</span>]*nb%MOD; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;f[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,x,y;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x==p)&#123;<span class="built_in">cout</span>&lt;&lt;f[y]&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;p)&#123;<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++) <span class="keyword">if</span>(y-j&lt;=x-p) ans=(ans+f[j]*C(x-p,y-j)%MOD*pa[x-y-p+j]%MOD*pb[y-j]%MOD)%MOD;&#125;</span><br><span class="line">        <span class="comment">//括号很重要！不能删除 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=y;j++) ans=(ans+f[j]*C(y-x+p-j<span class="number">-1</span>,y-j)%MOD*ap[p-x]%MOD*bp[y-j]%MOD)%MOD;</span><br><span class="line">        <span class="comment">//分类讨论 </span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基础之求导</title>
    <url>/2019/08/01/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B1%82%E5%AF%BC/</url>
    <content><![CDATA[<h1 id="1、导数的定义"><a href="#1、导数的定义" class="headerlink" title="1、导数的定义"></a>1、导数的定义</h1><p>导数，又名导函数值，是微积分中的重要基础概念。<a id="more"></a>当函数$y=f(x)$的自变量$x$在一点$x_0$处产生一个增量$\Delta x$时，函数输出值的增量$\Delta y$与自变量增量$\Delta x$的比值在$\Delta x$趋于$0$时的极限$a$如果存在，$a$即为在x0处的导数，记作$f’(x_0)$或$\frac{df(x_0)}{dx}$。导数的几何意义为：$f’(x)$表示函数曲线在点$(x,f(x))$处的切线的斜率。——百度百科（有删改）</p>
<h1 id="2、导数的运算"><a href="#2、导数的运算" class="headerlink" title="2、导数的运算"></a>2、导数的运算</h1><p>从导数的定义我们可以看出$f’(x)=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}$<br>所以我们可以从这个式子出发，得出导数的四则运算</p>
<h2 id="1-加（减）法"><a href="#1-加（减）法" class="headerlink" title="(1)加（减）法"></a>(1)加（减）法</h2><p>$(f(x)\pm g(x))’=\lim \limits_{\Delta x\rightarrow0}\frac{(f(x+\Delta x)\pm g(x+\Delta x))-(f(x)\pm g(x))}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}\pm\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}=f’(x)\pm g’(x)$</p>
<h2 id="2-乘法"><a href="#2-乘法" class="headerlink" title="(2)乘法"></a>(2)乘法</h2><p>$(f(x)\times g(x))’=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)\times g(x+\Delta x)-f(x)\times g(x)}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)\times g(x+\Delta x)-f(x+\Delta x)\times g(x)+f(x+\Delta x)\times g(x)-f(x)\times g(x)}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)\times(g(x+\Delta x)-g(x))+(f(x+\Delta x)-f(x))\times g(x)}{\Delta x}=f(x)\times\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}+g(x)\times\lim \limits_{\Delta x\rightarrow0}\frac{f(x+\Delta x)-f(x)}{\Delta x}=f(x)\times g’(x)+f’(x)\times g(x)$</p>
<h2 id="3-除法"><a href="#3-除法" class="headerlink" title="(3)除法"></a>(3)除法</h2><p>$f’(x)=\left(\left(\frac{f(x)}{g(x)}\right)\times g(x)\right)’=\left(\frac{f(x)}{g(x)}\right)’\times g(x)+\left(\frac{f(x)}{g(x)}\right)\times g’(x)$<br>$\therefore \left(\frac{f(x)}{g(x)}\right)’=\frac{f’(x)-\left(\frac{f(x)\times g’(x)}{g(x)}\right)}{g(x)}=\frac{f’(x)g(x)-f(x)g’(x)}{g^2(x)}$</p>
<hr>
<p>除了四则运算之外，还有一些其他的运算</p>
<h2 id="4-复合函数求导"><a href="#4-复合函数求导" class="headerlink" title="(4)复合函数求导"></a>(4)复合函数求导</h2><p>$(f(g(x)))’=\lim \limits_{\Delta x\rightarrow0}\frac{f(g(x+\Delta x))-f(g(x))}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{f(g(x+\Delta x))-f(g(x))}{g(x+\Delta x)-g(x)}\times\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}=f’(g(x))\times g’(x)$</p>
<h2 id="5-反函数求导"><a href="#5-反函数求导" class="headerlink" title="(5)反函数求导"></a>(5)反函数求导</h2><p>设$f^{-1}(x)=g(x)$<br>$g’(x)=\lim \limits_{\Delta x\rightarrow0}\frac{g(x+\Delta x)-g(x)}{\Delta x}=\lim \limits_{\Delta x\rightarrow0}\frac{1}{\frac{\Delta x}{g(x+\Delta x)-g(x)}}=\lim \limits_{\Delta x\rightarrow0}\frac{1}{\frac{f(g(x+\Delta x))-f(g(x))}{g(x+\Delta x)-g(x)}}=\frac{1}{f’(g(x))}$</p>
<h1 id="3、基本初等函数求导"><a href="#3、基本初等函数求导" class="headerlink" title="3、基本初等函数求导"></a>3、基本初等函数求导</h1><p>这里列出$6$大基本初等函数的导数，证明过程就省略了<del>原因是LaTeX太难打了</del>，幂函数稍微难一点，其他的都是用定义证明，具体的证明过程可以在网上搜索</p>
<h2 id="1-常数函数"><a href="#1-常数函数" class="headerlink" title="(1)常数函数"></a>(1)常数函数</h2><p>$f(x)=C$，$C$为常数<br>$f’(x)=0$</p>
<h2 id="2-幂函数"><a href="#2-幂函数" class="headerlink" title="(2)幂函数"></a>(2)幂函数</h2><p>$f(x)=x^a$<br>$f’(x)=ax^{a-1}$</p>
<h2 id="3-指数函数"><a href="#3-指数函数" class="headerlink" title="(3)指数函数"></a>(3)指数函数</h2><p>$f(x)=a^x(a\in\R^+)$<br>$f’(x)=a^xlna$</p>
<h2 id="4-对数函数"><a href="#4-对数函数" class="headerlink" title="(4)对数函数"></a>(4)对数函数</h2><p>$f(x)=log_ax(a\in\Z^+,a\ne 1)$<br>$f’(x)=\frac{1}{xlna}$</p>
<h2 id="5-三角函数"><a href="#5-三角函数" class="headerlink" title="(5)三角函数"></a>(5)三角函数</h2><p>$f(x)=sinx,g(x)=cosx,h(x)=tanx$<br>$f’(x)=cosx$<br>$g’(x)=-sinx$<br>$h’(x)=\frac{1}{cos^2x}=sec^2x$</p>
<h2 id="6-反三角函数"><a href="#6-反三角函数" class="headerlink" title="(6)反三角函数"></a>(6)反三角函数</h2><p>$f(x)=arcsinx,g(x)=arccosx,h(x)=arctanx$<br>$f’(x)=\frac{1}{\sqrt{1-x^2}}$<br>$g’(x)=-\frac{1}{\sqrt{1-x^2}}$<br>$h’(x)=\frac{1}{1+x^2}$</p>
<h1 id="一个诡异的函数"><a href="#一个诡异的函数" class="headerlink" title="一个诡异的函数"></a>一个诡异的函数</h1><p>$f(x)=x^x$这个函数这么求导呢？<br>我们只需要一步神奇的操作就可以了，看好了，千万不要眨眼<br>$f’(x)=\left(e^{ln\left(x^x\right)}\right)’=\left(e^{xlnx}\right)’=e^{xlnx}\times(xlnx)’=e^{xlnx}\times(1+lnx)$</p>
<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><p>我：在本篇的末尾，我给大家出四个求导的练习题<br>读者：我最擅长微积分了，各种导数我都会求，你出的是什么水题，快拿来看看<br>我：先来个最简单的<br>$(sin(cos(sin(cose^x))))’$<br>我：有没有被吓到？<br>读者：没有，这不是很简单吗，一层层算就好了<br>我：没有？再来一个，保证吓死你<br>$sin(tanx+cosx)\times e^{x^2sinx+\sqrt{x^2+1}}$<br>读者：好了，我输了<br>我：不，我还没写分母呢！<br>$\left(\frac{sin(tanx+cosx)\times e^{x^2sinx+\sqrt{x^2+1}}}{e^xsin(x^2+3)+\sqrt{x^2+1}\times tanx}\right)’$<br>读者：什么！这个玩意儿能求导！？<br>我：能呀，我算过，再来一个<br>$\left(\frac{3x^2+5x^3sin2x+7e^{x^2+6x+sinx}+8ln(e^x+e^{\sqrt{5sinx+1}})}{ln(e^{5x}+sin(cose^x))\times(3x^2cosx+e^xsin(3x+1))}\right)’$<br>我：呀！你怎么了？你不会是晕了吧？<br>读者：突然感觉数学好难，我放弃了<br>我：别急呀，还有一道题呢！<br>$\left(\frac{\left(lnx^3+6xcos(sinx)\right)\left(arctan\left(l(x)e^xsin(tanx)\right)\right)}{e^{sin^2(xcosx)}ln^2(xarctanx)(x^2+1)}\right)’$<br>我：卧槽！你怎么了？同志，醒醒！<br>读者：我是谁？我在哪里？我在干什么？</p>
<hr>
<p>如果有人能做出这道题，可以私信给我，要求要有过程，来证明你不是抄的，你将会获得一些奖励</p>
]]></content>
      <categories>
        <category>数学&amp;物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3696 The Luckiest number题解</title>
    <url>/2019/07/31/POJ3696%20The%20Luckiest%20number%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<h3 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h3><p>Chinese people think of ‘$8$’ as the lucky digit. Bob also likes digit ‘$8$’. Moreover, Bob has his own lucky number $L$. Now he wants to construct his luckiest number which is the minimum among all positive integers that are a multiple of $L$ and consist of only digit ‘$8$’.</p>
<h3 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h3><p>给定一个正整数$L$($L\leqslant 2\times10^9$)<br>问至少有多少个$8$连在一起组成的正整数是$L$的倍数</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每行一个正整数$L$($L\leqslant 2\times10^9$)</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个$L$，输出至少有多少个$8$连在一起组成的正整数是$L$的倍数，格式参照样例。若不存在，输出$0$</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>8<br>11<br>16<br>0</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>Case 1: 1<br>Case 2: 2<br>Case 3: 0</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>$n$个$8$连在一起组成的正整数可以记为$\frac{8}{9}(10^x-1)$<br>所以题目就转化为求最小的$x$使得$L|\frac{8}{9}(10^x-1)$<br>设$d=gcd(L,8)$<br>$L|\frac{8}{9}(10^x-1)\iff9L|8(10^x-1)\iff\frac{9L}{d}|10^x-1\iff10^x\equiv1\pmod{\frac{9L}{d}}$<br>这题的关键在于一个结论：若正整数$a,n$互质，则满足$a^x\equiv1\pmod{n}$的最小整数$x_0$为$\varphi(n)$的约数<br>证明：<br>假设满足$a^x\equiv1\pmod{n}$的最小整数$x_0$不能整除$\varphi(n)$<br>设$\varphi(n)=qx_0+r(0\leqslant r&lt;x_0)$<br>$\because a^{x_0}\equiv1\pmod{n}$<br>$\therefore a^{qx_0}\equiv1\pmod{n}$<br>又$\because a^{\varphi(n)}\equiv1\pmod{n}$（欧拉定理）<br>$\therefore a^{r}\equiv1\pmod{n}$，与$x_0$最小矛盾！<br>$\therefore$假设不成立，原命题成立</p>
<p>所以，我们只需要求出$\varphi(\frac{9L}{d})$，时间复杂度$\Theta(\sqrt{L}lnL)$<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">500000</span>],n,p,ans,i;</span><br><span class="line"><span class="keyword">int</span> t,m;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i,m=n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++) <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">        m=m/i*(i<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) m=m/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a%=n,b%=n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c=(<span class="keyword">long</span> <span class="keyword">double</span>)a*b/n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=a*b-c*n;</span><br><span class="line">    <span class="keyword">if</span> (ans&lt;<span class="number">0</span>) ans+=n;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ans&gt;=n) ans-=n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">power</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;b;b&gt;&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) c=mul(c,a);</span><br><span class="line">        a=mul(a,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)&#123;</span><br><span class="line">        n=<span class="number">9</span>*n/gcd(<span class="number">8</span>,n);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case "</span>&lt;&lt;++t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        <span class="keyword">if</span>(gcd(<span class="number">10</span>,n)==<span class="number">1</span>)&#123;</span><br><span class="line">            p=phi(n);</span><br><span class="line">            m=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i*i&lt;=p;i++) <span class="keyword">if</span>(p%i==<span class="number">0</span>)&#123;</span><br><span class="line">                a[++m]=i;</span><br><span class="line">                <span class="keyword">if</span>(i*i!=p) a[++m]=p/i;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++) <span class="keyword">if</span>(power(<span class="number">10</span>,a[i])==<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数论总结</title>
    <url>/2019/07/31/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、数论中的基本概念与性质"><a href="#一、数论中的基本概念与性质" class="headerlink" title="一、数论中的基本概念与性质"></a>一、数论中的基本概念与性质</h1><h2 id="1、整除"><a href="#1、整除" class="headerlink" title="1、整除"></a>1、整除</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><a id="more"></a>
<p>若整数$b$除以非零整数$a$，商为整数，且余数为零， 我们就说$b$能被$a$整除（或说$a$能整除$b$），表示为$a \mid b$</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="1-反身性"><a href="#1-反身性" class="headerlink" title="(1)反身性"></a>(1)反身性</h4><p>$a \mid a$<br>证明：<br>$\because a \div a=1$<br>$\therefore a \mid a$</p>
<h4 id="2-反对称性"><a href="#2-反对称性" class="headerlink" title="(2)反对称性"></a>(2)反对称性</h4><p>$a \mid b$且$b \mid a$则$\left\vert a \right\vert=\left\vert b \right\vert$<br>证明：<br>$\because a \mid b,b \mid a$<br>$\therefore$设$b \div a=x,a \div b=y \left(x,y \in Z\right)$<br>$\therefore \begin{cases}b=ax\\a=by\end{cases}$<br>$\therefore b=ax=bxy$<br>$\therefore xy=1$<br>$\therefore \begin{cases} x= \pm 1\\y= \pm 1\end{cases}$<br>$\therefore \left\vert a \right\vert=\left\vert b \right\vert$<br>$\left\vert a \right\vert=\left\vert b \right\vert$则$a \mid b$且$b \mid a$<br>证明：<br>$\because \left\vert a \right\vert=\left\vert b \right\vert$<br>$\therefore \begin{cases} a \div b= \pm 1\\b \div a= \pm 1\end{cases}$<br>$\therefore a \mid b$且$b \mid a$</p>
<h4 id="3-传递性"><a href="#3-传递性" class="headerlink" title="(3)传递性"></a>(3)传递性</h4><p>$a \mid b$且$b \mid c$则$a \mid c$<br>证明：<br>$\because a \mid b,b \mid c$<br>$\therefore$设$b \div a=x,c \div b=y \left(x,y \in Z\right)$<br>$\therefore \begin{cases}b=ax\\c=by\end{cases}$<br>$\therefore c=by=axy$<br>$\therefore c \div a=xy$<br>$\therefore a \mid c$</p>
<h4 id="4-其他性质"><a href="#4-其他性质" class="headerlink" title="(4)其他性质"></a>(4)其他性质</h4><p>①$a \mid b$且$a \mid c$且$a \mid d$则$a \mid \left(ka+mb+nc+ld\right)$<br>证明：<br>$\because a \mid b,a \mid c,a \mid d$<br>$\therefore$设$b \div a=x,c \div a=y,d \div a=z \left(x,y,z \in Z\right)$<br>$\therefore \begin{cases}b=ax\\c=ay\\d=az\end{cases}$<br>$\therefore \left(ka+mb+nc+ld\right) \div a=\left(ka+mxa+nya+lza\right) \div a=\left(k +mx+ny+lz\right)$<br>$\therefore a \mid \left(ka+mb+nc+ld\right)$<br>②质数$p \mid ab$则$p \mid a$或$p \mid b$<br>证明：<br>假设$p \nmid a$且$p \nmid b$<br>$\because p \nmid a,p \nmid b$<br>$\therefore a$中不含有质因子$p$，$b$中不含有质因子$p$<br>$\therefore ab$中不含有质因子$p$<br>$\therefore p \nmid ab$，与$p \mid ab$矛盾<br>$\therefore$假设不成立<br>$\therefore p \mid a$或$p \mid b$<br>③连续$n$个整数中恰有一个整数是$n$的倍数<br>证明：<br>设这$n$个数为$a,a+1,\cdots,a+n-1,a \equiv r \pmod{n},1 \leqslant r \leqslant n$<br>$\therefore \left(a+n-r\right) \equiv \left(r+n-r\right) \equiv n \equiv 0 \pmod{n}$<br>又$\because 0 \leqslant n-r &lt; n$<br>$\therefore n \mid \left(a+n-r\right)$<br>$\therefore$连续$n$个整数中恰有一个整数是$n$的倍数<br>④连续$n$个整数的乘积为$n!$的倍数<br>证明：<br>设这$n$个数为$a,a+1,\cdots,a+n-1$<br>$\because C_{a+n-1}^{n}=\frac{\prod \limits_{i=1}^n \left(a+n-i\right)}{n!}$为整数<br>$\therefore n! \mid \prod \limits_{i=1}^n \left(a+n-i\right)$</p>
<h2 id="2、质数与合数"><a href="#2、质数与合数" class="headerlink" title="2、质数与合数"></a>2、质数与合数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><h4 id="1-质数"><a href="#1-质数" class="headerlink" title="(1)质数"></a>(1)质数</h4><p>一个大于1的自然数，除了1和它自身外，不能整除其他自然数的数叫做质数</p>
<h4 id="2-合数"><a href="#2-合数" class="headerlink" title="(2)合数"></a>(2)合数</h4><p>合数指自然数中除了能被1和本身整除外，还能被其他数（0除外）整除的数</p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><h4 id="质数无穷多"><a href="#质数无穷多" class="headerlink" title="质数无穷多"></a>质数无穷多</h4><p>证明（质数无穷多的证明方法有许多，这里只展示1种，<del>其实我知道两种</del>，感兴趣的可以上网查）：<br>假设质数只有$n$个<br>从小到大依次排列为$p_{1},p_{2}, \cdots ,p_{n}$，设$N=\prod \limits_{i=1}^n p_{i}$<br>$\because p_{1} \nmid N$,$p_{2} \nmid N,\cdots,p_{n} \nmid N$<br>$\therefore N$为质数，与质数只有$n$个矛盾<br>$\therefore$假设不成立<br>$\therefore$质数无穷多</p>
<h4 id="算术基本定理"><a href="#算术基本定理" class="headerlink" title="算术基本定理"></a>算术基本定理</h4><p>每一个合数都可以以唯一形式被写成质数的乘积<br>证明：<br>假设合数可以以多种方式写成多个质数的乘积，设最小的是$n$<br>设$n=\prod \limits_{i=1}^{r}(p_{i}^{a_{i}})=\prod \limits_{i=1}^{s}(q_{i}^{b_{i}})$<br>$\because p_{1} \mid \prod \limits_{i=1}^{s}(q_{i}^{b_{i}})$<br>$\therefore q_{1}^{b_{1}},q_{2}^{b_{2}},\cdots,q_{s}^{b_{s}}$中有一个数能被$p_{1}$整除<br>$\therefore$不妨设为$q_{1}$<br>又$\because q_{1}$也是质数，因此$q_{1}=p_{1}$<br>假设$a_{1} &gt; b_{1}$<br>$\therefore p_{1}^{a_{1}-b_{1}} \prod \limits_{i=2}^{r}(p_{i}^{a_{i}})=\prod \limits_{i=2}^{s}(q_{i}^{b_{i}})$<br>$\therefore q_{2}^{b_{2}},q_{3}^{b_{3}},\cdots,q_{s}^{b_{s}}$中有一个数能被$p_{1}$整除<br>又$\because p_{1}=q_{1} \ne q_{i}(i \ne 1)$<br>$\therefore a_{1} \leqslant b_{1}$<br>同理，$\therefore a_{1} \geqslant b_{1}$<br>$\therefore a_{1} = b_{1}$<br>$\therefore$存在小于$n$的整数$m=\prod \limits_{i=2}^{r}(p_{i}^{a_{i}})=\prod \limits_{i=2}^{s}(q_{i}^{b_{i}})$可以用多于一种的方式写成多个质数的乘积，这与$n$的最小性矛盾<br>$\therefore$ 每一个合数都可以以唯一形式被写成质数的乘积</p>
<h2 id="3、最大公约数和最小公倍数"><a href="#3、最大公约数和最小公倍数" class="headerlink" title="3、最大公约数和最小公倍数"></a>3、最大公约数和最小公倍数</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="1-约数与倍数"><a href="#1-约数与倍数" class="headerlink" title="(1)约数与倍数"></a>(1)约数与倍数</h4><p>如果整数$a$能被整数$b$整除，$a$就叫做$b$的倍数，$b$就叫做$a$的约数</p>
<h4 id="2-公约数与公倍数"><a href="#2-公约数与公倍数" class="headerlink" title="(2)公约数与公倍数"></a>(2)公约数与公倍数</h4><p>几个整数中公有的约数，叫做这几个整数的公约数；几个整数中公有的倍数，叫做这几个整数的公倍数</p>
<h4 id="3-最大公约数与最小公倍数"><a href="#3-最大公约数与最小公倍数" class="headerlink" title="(3)最大公约数与最小公倍数"></a>(3)最大公约数与最小公倍数</h4><p>几个整数的公约数中，最大的一个，叫做这几个数的最大公约数；几个整数的公倍数中，最小的一个，叫做这几个数的最小公倍数数</p>
<h4 id="4-互质"><a href="#4-互质" class="headerlink" title="(4)互质"></a>(4)互质</h4><p>$\forall a,b \in N$,若(a,b)=1,则称$a,b$互质</p>
<h4 id="5-欧拉函数"><a href="#5-欧拉函数" class="headerlink" title="(5)欧拉函数"></a>(5)欧拉函数</h4><p>$1$~$N$中与$N$互质的数的个数被称为欧拉函数，记为$\varphi \left(N\right)=N \times \prod \limits_{质数p|N}(1-\frac{1}{p})$</p>
<h4 id="6-积性函数"><a href="#6-积性函数" class="headerlink" title="(6)积性函数"></a>(6)积性函数</h4><p>如果当$a,b$互质，有$f \left(ab\right)=f \left(a\right) \times f \left(b\right)$，那么称函数$f$为积性函数</p>
<h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h3><p>①$\forall a,b \in Z$，$gcd\left(a,b\right) \times lcm\left(a,b\right)=ab$<br>证明：<br>设$gcd\left(a,b\right)=d,a=a_{0}d,b=b_{0}d,(a_{0},b_{0})=1$<br>$lcm\left(a,b\right)=lcm\left(a_{0},b_{0}\right) \times d=a_{0}b_{0}d$<br>$\therefore gcd\left(a,b\right) \times lcm\left(a,b\right)=d \times a_{0}b_{0}d=a_{0}b_{0}d^{2}=\left(a_{0}d\right) \times \left(b_{0}d\right)=ab$<br>②$\forall n &gt; 1,1-n$中与$n$互质的数的和为$\frac{n \times \varphi \left(n\right)}{2}$<br>证明：<br>$\because gcd \left(n,x\right)=gcd \left(n,n-x\right)$<br>$\therefore$与$n$不互质的数$x,n-x$成对出现，平均值为$\frac{n}{2}$<br>$\therefore1-n$中与$n$互质的数的和为$\frac{n \times \varphi \left(n\right)}{2}$<br>③欧拉函数是积性函数<br>若$a,b$互质，则$\varphi \left(ab\right)=\varphi \left(a\right) \times \varphi \left(b\right)$<br>证明：<br>设$a=\prod \limits_{i=1}^{r}(p_{i}^{a_{i}}),b=\prod \limits_{i=1}^{s}(q_{i}^{b_{i}})$<br>$\therefore \varphi \left(a\right)=a \times \prod \limits_{i=1}^{r}(1-\frac{1}{p_{i}}),\varphi \left(b\right)=b \times \prod \limits_{i=1}^{s}(1-\frac{1}{q_{i}})$<br>$\therefore \varphi \left(ab\right)=ab \times \prod \limits_{i=1}^{r}(1-\frac{1}{p_{i}}) \times \prod \limits_{i=1}^{s}(1-\frac{1}{q_{i}})=\varphi \left(a\right) \times \varphi \left(b\right)$</p>
<h2 id="4、同余"><a href="#4、同余" class="headerlink" title="4、同余"></a>4、同余</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><h4 id="1-同余"><a href="#1-同余" class="headerlink" title="(1)同余"></a>(1)同余</h4><p>若整数$a$和整数$b$除以正整数$m$的余数相等，则称$a,b$模$m$同余，记为$a \equiv b \pmod{m}$</p>
<h4 id="2-同余类"><a href="#2-同余类" class="headerlink" title="(2)同余类"></a>(2)同余类</h4><p>对于$\forall a \in \left[0,m-1\right]$，集合$\left\{a+km\right\}(k \in Z)$的所有数模$m$同余，余数都是$a$，该集合称为一个模$m$的同余类，简记为$\overline{a}$</p>
<h4 id="3-完全剩余系"><a href="#3-完全剩余系" class="headerlink" title="(3)完全剩余系"></a>(3)完全剩余系</h4><p>模$m$的同余类一共有m个，分别为$\overline{0} , \overline{1} , \cdots , \overline{m-1}$,它们构成$m$的完全剩余系</p>
<h4 id="4-简化剩余系"><a href="#4-简化剩余系" class="headerlink" title="(4)简化剩余系"></a>(4)简化剩余系</h4><p>$1-m$中与$m$互质的数代表的同余类共有$\varphi \left(m\right)$个，它们构成$m$的简化剩余系</p>
<h4 id="5-数论倒数（乘法逆元）"><a href="#5-数论倒数（乘法逆元）" class="headerlink" title="(5)数论倒数（乘法逆元）"></a>(5)数论倒数（乘法逆元）</h4><p>若整数$a,x$满足$ax \equiv 1 \pmod{b}$，则$x$为$a$对模$m$意义下的数论倒数（乘法逆元）记为$a^{-1} \pmod{m}$</p>
<h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质"></a>性质</h3><h4 id="1-同余的充要条件"><a href="#1-同余的充要条件" class="headerlink" title="(1)同余的充要条件"></a>(1)同余的充要条件</h4><p>$a \equiv b \pmod{m}$的充要条件是$m \mid \left(a-b\right)$<br>证明：<br>$\because m \mid \left(a-b\right)$<br>$\therefore$存在整数$t$使得$a-b=mt$<br>$\therefore a=b+mt$<br>$\therefore a \equiv b \pmod{m}$</p>
<hr>
<p>$\because a \equiv b \pmod{m}$<br>$\therefore$存在整数$t$使得$a=b+mt$<br>$\therefore a-b=mt$<br>$\therefore m \mid \left(a-b\right)$</p>
<h4 id="2-反身性"><a href="#2-反身性" class="headerlink" title="(2)反身性"></a>(2)反身性</h4><p>$a \equiv a \pmod{m}$<br>证明：<br>$\because a-a=0,m \ne 0$<br>$\therefore m \mid a-a$<br>$\therefore a \equiv a \pmod{m}$</p>
<h4 id="3-对称性"><a href="#3-对称性" class="headerlink" title="(3)对称性"></a>(3)对称性</h4><p>$a \equiv b \pmod{m}$则$b \equiv a \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore m \mid \left(b-a\right)$<br>$\therefore b \equiv a \pmod{m}$</p>
<h4 id="4-传递性"><a href="#4-传递性" class="headerlink" title="(4)传递性"></a>(4)传递性</h4><p>$a \equiv b \pmod{m}$且$b \equiv c \pmod{m}$则$a \equiv c \pmod{m}$<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>又$\because b \equiv c \pmod{m}$<br>$\therefore m \mid \left(b-c\right)$<br>$\therefore m \mid \left[\left(a-b\right)+\left(b-c\right)\right]$<br>$\therefore m \mid \left(a-c\right)$<br>$\therefore a \equiv c \pmod{m}$</p>
<h4 id="5-可加性"><a href="#5-可加性" class="headerlink" title="(5)可加性"></a>(5)可加性</h4><p>$a \equiv b \pmod{m}$且$c \equiv d \pmod{m}$则$a+c \equiv b+d \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>又$\because c \equiv d \pmod{m}$<br>$\therefore m \mid \left(c-d\right)$<br>$\therefore m \mid \left[\left(a-b\right)+\left(c-d\right)\right]$<br>$\therefore m \mid \left[\left(a+c\right)-\left(b+d\right)\right]$<br>$\therefore a+c \equiv b+d \pmod{m}$</p>
<h4 id="6-可减性"><a href="#6-可减性" class="headerlink" title="(6)可减性"></a>(6)可减性</h4><p>$a \equiv b \pmod{m},c \equiv d \pmod{m}$则$a-c \equiv b-d \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>又$\because c \equiv d \pmod{m}$<br>$\therefore m \mid \left(c-d\right)$<br>$\therefore m \mid \left[\left(a-b\right)-\left(c-d\right)\right]$<br>$\therefore m \mid \left[\left(a-c\right)-\left(b-d\right)\right]$<br>$\therefore a-c \equiv b-d \pmod{m}$</p>
<h4 id="7-可乘性"><a href="#7-可乘性" class="headerlink" title="(7)可乘性"></a>(7)可乘性</h4><p>①$a \equiv b \pmod{m}$则$ac \equiv bc \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore m \mid \left(a-b\right)c$<br>$\therefore m \mid \left(ac-bc\right)$<br>$\therefore ac \equiv bc \pmod{m}$<br>②$a \equiv b \pmod{m},c \equiv d \pmod{m}$则$ac \equiv bd \pmod{m}$<br>证明：<br>$\because a \equiv b \pmod{m}$<br>$\therefore ac \equiv bc \pmod{m}$<br>又$\because c \equiv d \pmod{m}$<br>$\therefore bc \equiv bd \pmod{m}$<br>$\therefore ac \equiv bd \pmod{m}$</p>
<h4 id="8-有关同余的其他性质"><a href="#8-有关同余的其他性质" class="headerlink" title="(8)有关同余的其他性质"></a>(8)有关同余的其他性质</h4><p>①$ac \equiv bc \pmod{m}$且$\left(m,c\right)=1$则$a \equiv b \pmod{m}$<br>证明：<br>$\because ac \equiv bc \pmod{m}$<br>$\therefore m \mid \left(ac-bc\right)$<br>$\therefore m \mid \left(a-b\right)c$<br>又$\because \left(m,c\right)=1$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore a \equiv b \pmod{m}$<br>②$ac \equiv bc \pmod{mc}$则$a \equiv b \pmod{m}$<br>证明：<br>$\because ac \equiv bc \pmod{mc}$<br>$\therefore mc \mid \left(ac-bc\right)$<br>$\therefore m \mid \left(a-b\right)$<br>$\therefore a \equiv b \pmod{m}$</p>
<h4 id="9-有关完全剩余系的性质"><a href="#9-有关完全剩余系的性质" class="headerlink" title="(9)有关完全剩余系的性质"></a>(9)有关完全剩余系的性质</h4><p>$gcd\left(m,a\right)=1$且$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个完全剩余系，则$\left\{\overline{ab_{i}}\right\}\left(i\in \left[1,m\right]\right)$也是模$m$的一个完全剩余系<br>证明：<br>假设存在两个整数$a \times b_{i} \equiv a \times b_{j} \pmod{m}$<br>$b_{i} \equiv b_{j} \pmod{m}$，与$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个完全剩余系矛盾<br>$\therefore$假设不成立<br>$\therefore \left\{\overline{ab_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个完全剩余系</p>
<h4 id="10-有关简化剩余系的性质"><a href="#10-有关简化剩余系的性质" class="headerlink" title="(10)有关简化剩余系的性质"></a>(10)有关简化剩余系的性质</h4><p>$gcd\left(m,a\right)=1$且$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,\varphi \left(m\right)\right]\right)$是模$m$的一个简化剩余系，则$\left\{\overline{ab_{i}}\right\}\left(i\in \left[1,\varphi \left(m\right)\right]\right)$也是模$m$的一个完全剩余系<br>证明：<br>假设存在两个整数$a \times b_{i} \equiv a \times b_{j} \pmod{m}$<br>$b_{i} \equiv b_{j} \pmod{m}$，与$\left\{\overline{b_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个简化剩余系矛盾<br>$\therefore$假设不成立<br>$\therefore \left\{\overline{ab_{i}}\right\}\left(i\in \left[1,m\right]\right)$是模$m$的一个简化剩余系</p>
<h4 id="11-费马小定理"><a href="#11-费马小定理" class="headerlink" title="(11)费马小定理"></a>(11)费马小定理</h4><p>若$p$是质数，则对任意与$p$互质的整数$a$，有$a^{p-1} \equiv 1 \pmod{p}$<br>证明：<br>设$p$的完全剩余系为$\left\{\overline{i}\right\}\left(i \in\left[1,p-1\right]\right)$<br>$\because gcd\left(a,p\right)=1$<br>$\therefore \{\overline{ai}\}(i\in\left[1,p-1\right])$也是$p$的一个完全剩余系<br>$\therefore$对于每一个$i(i\in\left[1,p-1\right])$，总存在一个$j$使得$i \equiv a \times j \pmod{p}$<br>$\therefore \left(p-1\right)! \equiv \left(p-1\right)! \times a^{p-1} \pmod{p}$<br>又$\because \left(p,\left(p-1\right)!\right)=1$<br>$\therefore a^{p-1} \equiv 1 \pmod{p}$</p>
<h4 id="12-欧拉定理"><a href="#12-欧拉定理" class="headerlink" title="(12)欧拉定理"></a>(12)欧拉定理</h4><p>$gcd\left(a,n\right)=1,a \in Z^{+}$，则$a^{\varphi \left(n\right)} \equiv 1 \pmod{n}$<br>证明：<br>设$n$的简化剩余系为$\left\{\overline{a_{i}}\right\}\left(i \in\left[1,\varphi\left(n\right)\right]\right)$<br>$\because gcd\left(a,n\right)=1$<br>$\therefore \{\overline{aa_{i}}\}(i\in\left[1,\varphi \left(n\right)\right])$也是$p$的一个化简剩余系<br>$\therefore$对于每一个$a_{i}(i\in\left[1,\varphi \left(n\right)\right])$，总存在一个$j$使得$i \equiv a \times a_{j} \pmod{p}$<br>$\therefore \prod \limits_{i=1}^{\varphi \left(n\right)} a_{i} \equiv \prod \limits_{i=1}^{\varphi \left(n\right)}a_{i} \times a^{\varphi \left(n\right)} \pmod{n}$<br>$\therefore a^{\varphi \left(n\right)} \equiv 1 \pmod{n}$</p>
<h4 id="13-欧拉定理推论"><a href="#13-欧拉定理推论" class="headerlink" title="(13)欧拉定理推论"></a>(13)欧拉定理推论</h4><p>$gcd\left(a,n\right)=1,a \in Z^{+}$，则对于任意的正整数$b$，有$a^b \equiv a^{b \% \varphi \left(n\right)} \pmod{n}$<br>证明：<br>设$b=q \times \varphi \left(n\right)+r,0 \leqslant r &lt; \varphi \left(n\right)$<br>$a^{b} \equiv a^{q \times \varphi \left(n\right)+r} \equiv \left(a^{\varphi \left(n\right)}\right)^{q} \times a^{r} \equiv 1^{q} \times a^{r} \equiv a^{r} \equiv a^{b \% \varphi \left(n\right)} \pmod{n}$</p>
<h2 id="5、不定方程（丢番图方程）"><a href="#5、不定方程（丢番图方程）" class="headerlink" title="5、不定方程（丢番图方程）"></a>5、不定方程（丢番图方程）</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>不定方程是指未知数的个数多于方程个数，且未知数受到某些限制（如要求是有理数、整数或正整数等等）的方程或方程组</p>
<h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质"></a>性质</h3><h4 id="1-裴蜀Bezout定理"><a href="#1-裴蜀Bezout定理" class="headerlink" title="(1)裴蜀Bézout定理"></a>(1)裴蜀Bézout定理</h4><p>对于任意正整数$a,b$，存在一对整数$x,y$，满足$ax+by=gcd\left(a,b\right)$<br>证明：<br>设$gcd\left(a,b\right)=d,a=a_{0}d,b=b_{0}d$<br>$aa_{0}+bb_{0}=1$<br>$\therefore \left(a_{0},b_{0}\right)$是方程$ax+by=\left(a,b\right)$的一组解</p>
<h4 id="2-所有解与特解的关系"><a href="#2-所有解与特解的关系" class="headerlink" title="(2)所有解与特解的关系"></a>(2)所有解与特解的关系</h4><p>$\left(x_{0},y_{0}\right)$是方程$ax+by=c$的一组整数解，则方程的所有解为$\begin{cases}x=x_{0}+\frac{b}{gcd\left(a,b\right)}t\\y=y_{0}-\frac{a}{gcd\left(a,b\right)}t\end{cases},t \in Z$<br>证明：<br>设$ax_{1}+by_{1}=c,gcd\left(a,b\right)=c_{0},a=a_{0}c_{0},b=b_{0}c_{0},gcd\left(a_{0},b_{0}\right)=1$<br>$a_{0}x_{0}+b_{0}y_{0}=c_{0},a_{0}x_{1}+b_{0}y_{1}=c_{0}$<br>$\therefore a_{0}x_{0}+b_{0}y_{0}=a_{0}x_{1}+b_{0}y_{1}$<br>$\therefore a_{0}\left(x_{0}-x_{1}\right)=b_{0}\left(y_{1}-y_{0}\right)$<br>$\therefore b_{0} \mid a_{0}(x_{0}-x_{1})$<br>$\therefore b_{0} \mid \left(x_{0}-x_{1}\right)$<br>$\therefore x_{0} \equiv x_{1} \pmod{b_{0}}$<br>同理，$\therefore y_{0} \equiv y_{1} \pmod{b_{0}}$<br>$\therefore \begin{cases}x=x_{0}+b_{0}t\\y=y_{0}-a_{0}t\end{cases}$<br>$\therefore \begin{cases}x=x_{0}+\frac{b}{gcd\left(a,b\right)}t\\y=y_{0}-\frac{a}{gcd\left(a,b\right)}t\end{cases}$</p>
<h4 id="3-其他性质"><a href="#3-其他性质" class="headerlink" title="(3)其他性质"></a>(3)其他性质</h4><p>①$gcd\left(a,b\right)=1,a,b \in Z^{+}$，则方程$ax+by=ab-a-b$没有非负整数解<br>证明：<br>$\because ax+by=ab-a-b$<br>$\therefore a \left(x+1\right)+b \left(y+1\right)=ab$<br>又$\because a \mid ab$<br>$\therefore a \mid \left(a \left(x+1\right)+b \left(y+1\right)\right)$<br>$\therefore a \mid b \left(y+1\right)$<br>又$\because gcd\left(a,b\right)=1$<br>$\therefore a \mid \left(y+1\right)$<br>②$gcd\left(a,b\right)=1,c&gt;ab-a-b,a,b,c \in Z^{+}$，则方程$ax+by=c$有非负整数解<br>证明：<br>$\because gcd\left(a,b\right)=1$<br>$\therefore$设$ax_{0}+by_{0}=c,0 \leqslant x_{0} \leqslant b-1$<br>$\therefore y_{0}=\frac{c-ax_{0}}{b}&gt;\frac{ab-a-b-ax_{0}}{b} \geqslant \frac{ab-a-b-a\left(b-1\right)}{b}=-1$<br>$\therefore y_{0} \geqslant 0$<br>$\therefore x_{0},y_{0}$为非负整数<br>$\therefore$方程$ax+by=c$有非负整数解<br>③$gcd\left(a,b\right)=1,a,b \in Z^{+},0 \leqslant c \leqslant ab-a-b$，则恰有$\frac{\left(a-1\right)\left(b-1\right)}{2}$个整数$c$不能表示成$ax+by$的形式，$x,y \in \N$</p>
<h2 id="6、同余方程"><a href="#6、同余方程" class="headerlink" title="6、同余方程"></a>6、同余方程</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>设$f(x)=\sum \limits_{i=0}^{n}a_{i}x^{i}$是整系数多项式，称$f(x) \equiv 0 \pmod{m}$是$x$模$m$的同余方程</p>
<h2 id="7、高斯函数"><a href="#7、高斯函数" class="headerlink" title="7、高斯函数"></a>7、高斯函数</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><h4 id="1-取整函数"><a href="#1-取整函数" class="headerlink" title="(1)取整函数"></a>(1)取整函数</h4><p>不超过实数$x$的最大整数称为$x$的整数部分，记作$\left[x\right]$<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzAyLzIwL2sybjdmcy5wbmc" alt=""></p>
<h3 id="2-取小函数"><a href="#2-取小函数" class="headerlink" title="(2)取小函数"></a>(2)取小函数</h3><p>实数$x$的非负纯小数部分，记作$\left\{x\right\}$<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zMi5heDF4LmNvbS8yMDE5LzAyLzIwL2sybkw2MC5wbmc" alt=""></p>
<h3 id="性质-5"><a href="#性质-5" class="headerlink" title="性质"></a>性质</h3><p>①$x=\left[x\right]+\left\{x\right\}$<br>②$x-1&lt;\left[x\right] \leqslant x$<br>③$0 \leqslant \left\{x\right\}&lt;1$<br>④若$x \leqslant y$，则$\left[x\right] \leqslant \left[y\right]$<br>证明：<br>$\because \left[x\right] \leqslant x \leqslant y&lt;\left[y\right]+1$<br>$\therefore \left[x\right] \leqslant \left[y\right]$<br>⑤$\forall a \in Z^{*},b \in Z$，则$b=a \left[\frac{b}{a}\right]+a\left\{\frac{b}{a}\right\},a\left\{\frac{b}{a}\right\} \in Z$<br>证明：<br>$\because \frac{b}{a}=\left[\frac{b}{a}\right]+\left\{\frac{b}{a}\right\}$<br>$\therefore b=a \left[\frac{b}{a}\right]+a\left\{\frac{b}{a}\right\}$<br>$\therefore a\left\{\frac{b}{a}\right\}=b-a \left[\frac{b}{a}\right]$<br>$\therefore a\left\{\frac{b}{a}\right\} \in Z$<br>⑥$\left[x\right]+\left[y\right]=\left[x+y\right]$或$\left[x+y\right]=\left[x\right]+\left[y\right]+1$<br>证明：<br>$\because x+y=\left[x\right]+\left[y\right]+\left\{x\right\}+\left\{y\right\}$<br>$\therefore$当$0 \leqslant \left\{x\right\}+\left\{y\right\}&lt;1$时，$\left[x\right]+\left[y\right]=\left[x+y\right]$<br>$  \;$当$1 \leqslant \left\{x\right\}+\left\{y\right\}&lt;2$时，$\left[x\right]+\left[y\right]+1=\left[x+y\right]$</p>
<h1 id="二、数论中相关的数和方程的求法"><a href="#二、数论中相关的数和方程的求法" class="headerlink" title="二、数论中相关的数和方程的求法"></a>二、数论中相关的数和方程的求法</h1><h2 id="1、埃拉托斯特尼筛法（埃氏筛法）"><a href="#1、埃拉托斯特尼筛法（埃氏筛法）" class="headerlink" title="1、埃拉托斯特尼筛法（埃氏筛法）"></a>1、埃拉托斯特尼筛法（埃氏筛法）</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>要得到自然数$n$以内的全部素数，必须把不大于$\sqrt{n}$的所有素数的倍数剔除，剩下的就是素数</p>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n/i;j++) v[i*j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(n \times \log \left(\log \left(n\right)\right)\right)$</p>
<h3 id="时间复杂度证明"><a href="#时间复杂度证明" class="headerlink" title="时间复杂度证明"></a>时间复杂度证明</h3><p>$\Theta \left(\log \left(n\right)\right)=\Theta \left(\ln \left(n\right)\right)=\Theta \left(\int_{1}^{n+1} \frac{dx}{x}\right)=\Theta \left(\sum \limits_{i=1}^{n} \int_{i}^{i+1} \frac{dx}{x}\right) &lt; \Theta \left(\sum \limits_{i=1}^{n} \frac{1}{i}\right) \leqslant \Theta \left(\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right) \times \sum \limits_{k=1}^{n} \frac{1}{k^{2}}\right) &lt; \Theta \left(\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right) \times \left(1+\sum \limits_{k=2}^{n} \left(\frac{1}{k-\frac{1}{2}}-\frac{1}{k+\frac{1}{2}} \right) \right) \right) = \Theta \left(\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right) \times \left(1+\frac{2}{3}+\frac{1}{n+\frac{1}{2}}\right)\right) &lt; \Theta \left(\frac{5}{3}\prod \limits_{质数p \leqslant n} \left(1+\frac{1}{p}\right)\right) &lt; \Theta \left(\frac{5}{3} \prod \limits_{质数p \leqslant n} \exp  \left(\frac{1}{p}\right)\right) = \Theta \left(\frac{5}{3} \exp \left(\sum \limits_{质数p \leqslant n} \frac{1}{p}\right)\right)$<br>$\therefore \Theta \left(n \times \log \left(\log \left(n\right)\right)\right) = \Theta \left(n \times \ln \left(\ln \left(n\right)\right)\right) &lt; \Theta \left(n \times \ln \left(\frac{5}{3} \exp \left(\sum \limits_{质数p \leqslant n} \frac{1}{p}\right)\right)\right) = \Theta \left(n \times \sum \limits_{质数p \leqslant n} \frac{1}{p}\right)$</p>
<h2 id="2、欧拉筛法"><a href="#2、欧拉筛法" class="headerlink" title="2、欧拉筛法"></a>2、欧拉筛法</h2><h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的</p>
<h3 id="程序实现-1"><a href="#程序实现-1" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">primes</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            v[i]=i;</span><br><span class="line">            prime[++m]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prime[j]&gt;v[i]||prime[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">            v[i*prime[j]]=prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cout</span>&lt;&lt;prime[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(n\right)$</p>
<h2 id="3、质因数分解"><a href="#3、质因数分解" class="headerlink" title="3、质因数分解"></a>3、质因数分解</h2><h3 id="内容-2"><a href="#内容-2" class="headerlink" title="内容"></a>内容</h3><p>$\forall N \in Z^{+} \setminus \left\{1\right\}$，把$N$化为$\prod \limits^{m}_{i=1} p^{c_{i}}_{i}$的过程叫质因数分解</p>
<h3 id="程序实现-2"><a href="#程序实现-2" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  m=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=n;i++) <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">    p[++m]=i,c[m]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,c[m]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">1</span>) p[++m]=n,c[m]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cout</span>&lt;&lt;p[i]&lt;&lt;<span class="string">'^'</span>&lt;&lt;c[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(\sqrt N\right)$</p>
<h2 id="4、欧几里得算法（辗转相除法）"><a href="#4、欧几里得算法（辗转相除法）" class="headerlink" title="4、欧几里得算法（辗转相除法）"></a>4、欧几里得算法（辗转相除法）</h2><h3 id="内容-3"><a href="#内容-3" class="headerlink" title="内容"></a>内容</h3><p>$\forall a,b \in N,b \ne 0,gcd(a,b)=gcd(b,a \% b)$</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>若$a&lt;b$，则$gcd(b,a \% b)=gcd(b,a)=gcd(a,b)$，命题成立<br>若$a \geqslant b$，设$a=q \times b+r,0 \leqslant r&lt;b,a,b$的一个公约数为$d$<br>$d \mid a,d \mid qb$<br>$\therefore d \mid \left(a-qb\right)$<br>$\therefore d \mid r$<br>$\therefore d$也是$b,r$的公约数<br>$\therefore a,b$的公约数集合与$b,r$的公约数集合相同<br>$\therefore a,b$和$b,r$的最大公约数相等</p>
<h3 id="程序实现-3"><a href="#程序实现-3" class="headerlink" title="程序实现"></a>程序实现</h3><h4 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(b!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp%a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$\Theta \left(\log \left(a+b\right)\right)$</p>
<h2 id="5、扩展欧几里得算法"><a href="#5、扩展欧几里得算法" class="headerlink" title="5、扩展欧几里得算法"></a>5、扩展欧几里得算法</h2><h3 id="内容-4"><a href="#内容-4" class="headerlink" title="内容"></a>内容</h3><p>求方程$ax+by=gcd\left(a,b\right),a,b,x,y \in Z$的解$x,y$<br>当$b=0$时，$x=1,y=0$为方程的解<br>当$b&gt;0$时，$gcd \left(a,b\right)=gcd \left(b,a\%b\right)$<br>设$bx’+\left(a\%b\right)y’=gcd\left(b,a\%b\right),x’,y’ \in Z$<br>$\therefore bx’+\left(a\%b\right)y’=bx’+\left(a-b \left \lfloor \frac{a}{b} \right \rfloor\right)y’=ay’+b \left(x’-\left \lfloor \frac{a}{b} \right \rfloor y’\right)$<br>$\therefore \begin{cases} x=y’ \\y=x’-\left \lfloor \frac{a}{b} \right \rfloor y \end{cases}$</p>
<h3 id="程序实现-4"><a href="#程序实现-4" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="keyword">int</span> d=exgcd(b,a%b,x,y),z=x;</span><br><span class="line">    x=y,y=z-y*(a/b);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、线性同余方程组的解法"><a href="#6、线性同余方程组的解法" class="headerlink" title="6、线性同余方程组的解法"></a>6、线性同余方程组的解法</h2><h3 id="内容-5"><a href="#内容-5" class="headerlink" title="内容"></a>内容</h3><p>设$m_{1},m_{2},\cdots \cdots,m_{n} \in Z^{+}$，对于任意$n$个整数$a_{1},a_{2},\cdots \cdots,a_{n}$，求方程组$\begin{cases} x \equiv a_{1} \pmod{m_{1}}\\x \equiv a_{2} \pmod{m_{2}}\\             \vdots\\x \equiv a_{n} \pmod{m_{n}} \end{cases}$的解</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>设前$k-1$个方程的解为$x,m= \sum \limits^{t-1}_{i=1}m_{i},tm \equiv a_{k}-x \pmod{m_{k}}$<br>$\therefore x+tm \equiv a^{k} \pmod{m^{k}}$<br>$\therefore x’=x+tm$为前$k$个方程的解</p>
<h3 id="程序实现-5"><a href="#程序实现-5" class="headerlink" title="程序实现"></a>程序实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,m[<span class="number">20</span>],a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> &amp;x,<span class="keyword">long</span> <span class="keyword">long</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!b)&#123;x=<span class="number">1</span>,y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> d=exgcd(b,a%b,x,y),z=x;</span><br><span class="line">  x=y,y=z-y*(a/b);</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">xxtyfcz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> M,A,d,x,y;</span><br><span class="line">  M=m[<span class="number">1</span>];</span><br><span class="line">  A=a[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    d=exgcd(M,m[i],x,y);</span><br><span class="line">    <span class="keyword">if</span>((a[i]-A)%d!=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp=<span class="built_in">abs</span>(m[i]/d);</span><br><span class="line">    x=x*((a[i]-A)/d);</span><br><span class="line">    x=(x%temp+temp)%temp;</span><br><span class="line">    A=M*x+A;</span><br><span class="line">    M=M*m[i]/d;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (A%M+M)%M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h1><h2 id="1、POJ2689-Prime-Distance题解"><a href="#1、POJ2689-Prime-Distance题解" class="headerlink" title="1、POJ2689 Prime Distance题解"></a>1、POJ2689 Prime Distance题解</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong><a href="http://poj.org/problem?id=2689" target="_blank" rel="noopener">原题</a></strong></p>
<h5 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h5><p>The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by $1$ and itself). The first prime numbers are $2,3,5,7$ but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, $2,3$ are the only adjacent primes that are also adjacent numbers.<br>Your program is given $2$ numbers: $L$ and $U$ ($1 \leqslant L&lt; U \leqslant 2,147,483,647$), and you are to find the two adjacent primes $C1$ and $C2$ ($L \leqslant C1&lt; C2 \leqslant U$) that are closest (i.e. $C2-C1$ is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes $D1$ and $D2$ ($L \leqslant D1&lt; D2 \leqslant U$) where $D1$ and $D2$ are as distant from each other as possible (again choosing the first pair if there is a tie).</p>
<h5 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h5><p>给定两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647$)，求闭区间 $\left[L,R\right]$中相邻两个质数的差的最小值和最大值是多少，分别输出这两对质数</p>
<h4 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>每行两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647,R-L \leqslant 10^6$)</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个$L,R$，输出最小值和最大值，格式参照样例<br>若区间内无质数，输出”There are no adjacent primes.”</p>
<h4 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h5><p>2 17<br>14 17</p>
<h5 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h5><p>2,3 are closest, 7,11 are most distant.<br>There are no adjacent primes.</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>由于$L,R$的范围很大，所以埃氏筛法和欧拉筛法都无法生成$\left[1,R\right]$的所有质数<br>但是$R-L$的范围很小且任何一个合数$n$一定包含一个不超过$\sqrt{n}$的质因子，所以我们只需要用筛法求出$2,3,\cdots,\sqrt{n}$的所有质数<br>而对于每一个质数$p$，标记$i \times p \left(\left\lceil\frac{L}{p}\right\rceil \leqslant i \leqslant \left\lceil\frac{R}{p}\right\rceil\right)$为合数<br>标记完后，剩下的所有数就是$\left[L,R\right]$中的质数了<br>再两两比较，找出差最大和最小的就可以了，时间复杂度$\Theta(\sqrt{R}lnln\sqrt{R}+(R-L)lnlnR)$</p>
<h2 id="2、洛谷P1072-Hankson的趣味题"><a href="#2、洛谷P1072-Hankson的趣味题" class="headerlink" title="2、洛谷P1072 Hankson的趣味题"></a>2、洛谷P1072 Hankson的趣味题</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">原题</a></strong><br>Hanks博士是 BT(Bio-Tech，生物技术)领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。<br>今天在课堂上，老师讲解了如何求两个正整数$c_1$和$c_2$的最大公约数和最小公倍数。现在Hankson认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数$a_0,a_1,b_0,b_1$，设某未知正整数$x$满足：<br>1.$x$和 $a_0$的最大公约数是$a_1$​；<br>2.$x$和$b_0$的最小公倍数是$b_1$。<br>Hankson的“逆问题”就是求出满足条件的正整数$x$。但稍加思索之后，他发现这样的$x$并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的$x$的个数。请你帮助他编程求解这个问题。</p>
<h4 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行为一个正整数$n$，表示有$n$组输入数据。接下来的$n$行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$​，每两个整数之间用一个空格隔开。输入数据保证$a_0$能被$a_1$整除，$b_1$能被$b_0$​整除。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>共$n$行。每组输入数据的输出结果占一行，为一个整数。<br>对于每组数据：若不存在这样的$x$，请输出$0$；<br>若存在这样的$x$，请输出满足条件的$x$的个数；</p>
<h4 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h5><p>2<br>41 1 96 288<br>95 1 37 1776 </p>
<h5 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h5><p>6<br>2</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>因为$x$是$b_1$的约数，所以$x$的质因子一定也是$b_1$的质因子，所以我对于$b_1$的每个质因子$p$，我们可以计算$x$中有多少个$p$<br>假设$a_0,a_1,b_0,b_1,x$中分别有$m_{a_0},m_{a_1},m_{b_0},m_{b_1},m_x$个质因子$p$<br>由于$gcd(a_0,x)=b_0$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0}$，则$m_x\geqslant m_{b_0}$</li>
<li>若$m_{a_0}&lt;m_{b_0}$，则$m_x$无解</li>
</ol>
<p>同理，由于$lcm(a_1,x)=b_1$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_1}&lt;m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_1}=m_{b_1}$，则$m_x\leqslant m_{b_1}$</li>
<li>若$m_{a_1}&gt;m_{b_1}$，则$m_x$无解</li>
</ol>
<p>综合以上所有情况，我们可以得出共有$5$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}=m_{b_1}$，则$m_x=m_{b_0}=m_{b_1}$</li>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_{b_0}\leqslant m_x\leqslant m_{b_1}$</li>
<li>若其他情况，则$m_x$均无解</li>
</ol>
<p>我们将$m_x$的取法记为$sum_p$，则$x$的数量为$\prod\limits_{\text{质数}p|d}sum_p$，时间复杂度$\Theta\left(\frac{n\sqrt{d}}{lnd}\right)$</p>
<h2 id="POJ3696-The-Luckiest-number"><a href="#POJ3696-The-Luckiest-number" class="headerlink" title="POJ3696 The Luckiest number"></a>POJ3696 The Luckiest number</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p><strong><a href="http://poj.org/problem?id=3696" target="_blank" rel="noopener">原题</a></strong></p>
<h5 id="英文题目-1"><a href="#英文题目-1" class="headerlink" title="英文题目"></a>英文题目</h5><p>Chinese people think of ‘$8$’ as the lucky digit. Bob also likes digit ‘$8$’. Moreover, Bob has his own lucky number $L$. Now he wants to construct his luckiest number which is the minimum among all positive integers that are a multiple of $L$ and consist of only digit ‘$8$’.</p>
<h5 id="中文题意-1"><a href="#中文题意-1" class="headerlink" title="中文题意"></a>中文题意</h5><p>给定一个正整数$L$($L\leqslant 2\times10^9$)<br>问至少有多少个$8$连在一起组成的正整数是$L$的倍数</p>
<h4 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h4><h5 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h5><p>每行一个正整数$L$($L\leqslant 2\times10^9$)</p>
<h5 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h5><p>对于每个$L$，输出至少有多少个$8$连在一起组成的正整数是$L$的倍数，格式参照样例。若不存在，输出$0$</p>
<h4 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h4><h5 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h5><p>8<br>11<br>16<br>0</p>
<h5 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h5><p>Case 1: 1<br>Case 2: 2<br>Case 3: 0</p>
<h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>$n$个$8$连在一起组成的正整数可以记为$\frac{8}{9}(10^x-1)$<br>所以题目就转化为求最小的$x$使得$L|\frac{8}{9}(10^x-1)$<br>设$d=gcd(L,8)$<br>$L|\frac{8}{9}(10^x-1)\iff9L|8(10^x-1)\iff\frac{9L}{d}|10^x-1\iff10^x\equiv1\pmod{\frac{9L}{d}}$<br>这题的关键在于一个结论：若正整数$a,n$互质，则满足$a^x\equiv1\pmod{n}$的最小整数$x_0$为$\varphi(n)$的约数<br>证明：<br>假设满足$a^x\equiv1\pmod{n}$的最小整数$x_0$不能整除$\varphi(n)$<br>设$\varphi(n)=qx_0+r(0\leqslant r&lt;x_0)$<br>$\because a^{x_0}\equiv1\pmod{n}$<br>$\therefore a^{qx_0}\equiv1\pmod{n}$<br>又$\because a^{\varphi(n)}\equiv1\pmod{n}$（欧拉定理）<br>$\therefore a^{r}\equiv1\pmod{n}$，与$x_0$最小矛盾！<br>$\therefore$假设不成立，原命题成立</p>
<p>所以，我们只需要求出$\varphi(\frac{9L}{d})$，时间复杂度$\Theta(\sqrt{L}lnL)$</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>数论的练习题还有很多，在这里就不一一细细分析了，推荐几道题目供大家练习</p>
<ol>
<li><a href="https://www.luogu.org/problem/P1463" target="_blank" rel="noopener">洛谷P1463反素数</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1053" target="_blank" rel="noopener">双倍经验：BZOJ1053</a></li>
<li><a href="https://www.luogu.org/problem/P2261" target="_blank" rel="noopener">洛谷P2261余数求和</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1257" target="_blank" rel="noopener">双倍经验：BZOJ1257</a></li>
<li><a href="http://poj.org/problem?id=3090" target="_blank" rel="noopener">POJ3090Visible Lattice Points</a>这题洛谷上好像有原题，只是名字改了，有知道题号的可以跟我说</li>
<li><a href="https://www.luogu.org/problem/P1082" target="_blank" rel="noopener">洛谷P1082同余方程</a></li>
<li><a href="http://poj.org/problem?id=3070" target="_blank" rel="noopener">POJ2891Strange Way to Express Integers</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2818" target="_blank" rel="noopener">BZOJ1257Gcd</a></li>
<li><a href="http://poj.org/problem?id=2480" target="_blank" rel="noopener">POJ2480Longge’s problem</a></li>
<li><a href="https://www.luogu.org/problem/P1516" target="_blank" rel="noopener">洛谷P1516青蛙的约会</a> <a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1477" target="_blank" rel="noopener">双倍经验：BZOJ1447</a> <a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">三倍经验！！！POJ1061</a></li>
<li><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2242" target="_blank" rel="noopener">BZOJ2242计算器</a></li>
</ol>
<p><strong>参考材料：</strong><br><strong>1、《算法竞赛进阶指南》李煜东 著</strong><br><strong>2、《数论初步》周春荔 著</strong><br><strong>3、《简明数论》潘承洞、潘承彪 著</strong></p>
<p><strong>ps:写得比较匆忙，有错误请在评论区指出，我将及时更改，谢谢！</strong></p>
]]></content>
      <categories>
        <category>数学&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1072 DTOJ Begin1014Hankson的趣味题</title>
    <url>/2019/07/31/%E6%B4%9B%E8%B0%B7P1072-DTOJ%20Begin1014Hankson%E7%9A%84%E8%B6%A3%E5%91%B3%E9%A2%98/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>Hanks博士是 BT(Bio-Tech，生物技术)领域的知名专家，他的儿子名叫Hankson。现在，刚刚放学回家的Hankson正在思考一个有趣的问题。<br>今天在课堂上，老师讲解了如何求两个正整数$c_1$和$c_2$的最大公约数和最小公倍数。现在Hankson认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数$a_0,a_1,b_0,b_1$，设某未知正整数$x$满足：<br>1.$x$和 $a_0$的最大公约数是$a_1$；<br>2.$x$和$b_0$的最小公倍数是$b_1$。<br>Hankson的“逆问题”就是求出满足条件的正整数$x$。但稍加思索之后，他发现这样的$x$并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的$x$的个数。请你帮助他编程求解这个问题。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行为一个正整数$n$，表示有$n$组输入数据。接下来的$n$行每行一组输入数据，为四个正整数 $a_0,a_1,b_0,b_1$​，每两个整数之间用一个空格隔开。输入数据保证$a_0$能被$a_1$整除，$b_1$能被$b_0$​整除。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>共$n$行。每组输入数据的输出结果占一行，为一个整数。<br>对于每组数据：若不存在这样的$x$，请输出$0$；<br>若存在这样的$x$，请输出满足条件的$x$的个数；</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>2<br>41 1 96 288<br>95 1 37 1776 </p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>6<br>2</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>因为$x$是$b_1$的约数，所以$x$的质因子一定也是$b_1$的质因子，所以我对于$b_1$的每个质因子$p$，我们可以计算$x$中有多少个$p$<br>假设$a_0,a_1,b_0,b_1,x$中分别有$m_{a_0},m_{a_1},m_{b_0},m_{b_1},m_x$个质因子$p$<br>由于$gcd(a_0,x)=b_0$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0}$，则$m_x\geqslant m_{b_0}$</li>
<li>若$m_{a_0}&lt;m_{b_0}$，则$m_x$无解</li>
</ol>
<p>同理，由于$lcm(a_1,x)=b_1$，所以有$3$种情况：</p>
<ol>
<li>若$m_{a_1}&lt;m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_1}=m_{b_1}$，则$m_x\leqslant m_{b_1}$</li>
<li>若$m_{a_1}&gt;m_{b_1}$，则$m_x$无解</li>
</ol>
<p>综合以上所有情况，我们可以得出共有$5$种情况：</p>
<ol>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}=m_{b_1}$，则$m_x=m_{b_0}=m_{b_1}$</li>
<li>若$m_{a_0}&gt;m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_0}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}&lt;m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_x=m_{b_1}$</li>
<li>若$m_{a_0}=m_{b_0},m_{a_1}=m_{b_1},m_{b_0}\leqslant m_{b_1}$，则$m_{b_0}\leqslant m_x\leqslant m_{b_1}$</li>
<li>若其他情况，则$m_x$均无解</li>
</ol>
<p>我们将$m_x$的取法记为$sum_p$，则$x$的数量为$\prod\limits_{\text{质数}p|d}sum_p$<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,a0,a1,b0,b1,ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)a*b/gcd(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a0,&amp;a1,&amp;b0,&amp;b1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(b1);i++)</span><br><span class="line">    <span class="keyword">if</span>(b1%i==<span class="number">0</span>)&#123;</span><br><span class="line">  		<span class="keyword">if</span>(gcd(i,a0)==a1&amp;&amp;lcm(i,b0)==b1) ans++;</span><br><span class="line">      <span class="keyword">if</span>(i*i!=b1) <span class="keyword">if</span>(gcd(b1/i,a0)==a1&amp;&amp;lcm(b1/i,b0)==b1) ans++;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>洛谷</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>矢量（向量）</title>
    <url>/2019/07/30/%E7%9F%A2%E9%87%8F%EF%BC%88%E5%90%91%E9%87%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1、矢量的定义"><a href="#1、矢量的定义" class="headerlink" title="1、矢量的定义"></a>1、矢量的定义</h2><p>矢量是一种既有大小又有方向的量，又称为向量。在计算机中，矢量图可以无限放大永不变形 <del>（反正我没看懂）</del>。——百度百科</p>
<a id="more"></a>
<h2 id="2、矢量的表示及其相关量的表示"><a href="#2、矢量的表示及其相关量的表示" class="headerlink" title="2、矢量的表示及其相关量的表示"></a>2、矢量的表示及其相关量的表示</h2><h3 id="1-矢量的表示"><a href="#1-矢量的表示" class="headerlink" title="(1)矢量的表示"></a>(1)矢量的表示</h3><p>矢量可以表示为一个小写字母$a$上面一个箭头$\vec{a}$（ps:正确的箭头应该是$\rightharpoonup$这样的，而不是$\rightarrow$的，但$L_{A}T^{E}X$上打不出来）或者一个粗体 <strong>A</strong><br>在$n$维空间内，矢量通常被表示为一个$n$元组$(a_{1},a_{2},\cdots \cdots,a_{n})$</p>
<h3 id="2-矢量夹角的表示"><a href="#2-矢量夹角的表示" class="headerlink" title="(2)矢量夹角的表示"></a>(2)矢量夹角的表示</h3><p>两个矢量$\vec{a},\vec{b}$的夹角表示为$\langle\vec{a},\vec{b}\rangle$</p>
<h2 id="3、矢量的运算"><a href="#3、矢量的运算" class="headerlink" title="3、矢量的运算"></a>3、矢量的运算</h2><h2 id="1-矢量的模"><a href="#1-矢量的模" class="headerlink" title="(1)矢量的模"></a>(1)矢量的模</h2><p>即矢量的长度，记为$|\vec{a}|$</p>
<h3 id="2-矢量的加法"><a href="#2-矢量的加法" class="headerlink" title="(2)矢量的加法"></a>(2)矢量的加法</h3><p>满足三角形法则，如图<br><img src="https://img-blog.csdnimg.cn/20190719195643588.png" alt=""></p>
<h3 id="3-矢量的减法"><a href="#3-矢量的减法" class="headerlink" title="(3)矢量的减法"></a>(3)矢量的减法</h3><p>满足平行四边形法则，如图<br><img src="https://img-blog.csdnimg.cn/20190719195730190.png" alt="在这里插入图片描述"></p>
<h3 id="4-矢量的点乘"><a href="#4-矢量的点乘" class="headerlink" title="(4)矢量的点乘"></a>(4)矢量的点乘</h3><p>两个矢量的点乘是标量，$(a_{1},a_{2},\cdots\cdots,a_{n})\cdot(b_{1},b_{2},\cdots\cdots,b_{n})\overset{\underset{def}{}}{=}\sum \limits_{i=1}^{n}a_{i}b_{i},\vec{a}\cdot\vec{b}=|\vec{a}||\vec{b}|cos(\langle\vec{a},\vec{b}\rangle)$<br>这时，我们终于可以给出矢量的模的表达式了$|\vec{a}|\overset{\underset{def}{}}{=}\sqrt{(\vec{a})^2}$<br>点乘满足交换律和分配律</p>
<h3 id="5-矢量的叉乘"><a href="#5-矢量的叉乘" class="headerlink" title="(5)矢量的叉乘"></a>(5)矢量的叉乘</h3><p>有$0.999999994538$的概率我们不考虑矢量的叉乘后的结果，我们只考虑矢量的叉乘后矢量的模<br>$(a_{1},a_{2})\times(b_{1},b_{2})\overset{\underset{def}{}}{=}a_{1}b_{2}-a_{2}b_{1},\vec{a}\times\vec{b}=|\vec{a}||\vec{b}|sin(\langle\vec{a},\vec{b}\rangle)$<br>矢量的叉乘的本质的有向面积，它的方向满足右手螺旋法则：先把手掌除大拇指以外的$4$个指头展开，指向$\vec{a}$的方向，然后把$4$个指头弯起来，弯的方向由$\vec{a}$转向矢量$\vec{b}$（转的角度须小于$\pi$），此时大拇指立起的方向，就是$\vec{a}\times\vec{b}$的方向。<br>矢量的叉乘满足逆交换律，即$\vec{a}\times\vec{b}=-\vec{b}\times\vec{a}$</p>
<h3 id="6-矢量的极角"><a href="#6-矢量的极角" class="headerlink" title="(6)矢量的极角"></a>(6)矢量的极角</h3><p>向量$\vec{a}$的极角$\theta$为$atan2(y,x)$</p>
<h2 id="4、矢量的变换"><a href="#4、矢量的变换" class="headerlink" title="4、矢量的变换"></a>4、矢量的变换</h2><h3 id="1-缩放"><a href="#1-缩放" class="headerlink" title="(1)缩放"></a>(1)缩放</h3><p>$\vec{a}$方向的单位矢量（即长度为1的矢量）为$\frac{\vec{a}}{|a|}$<br>与$\vec{a}$同向但长度为$l$的矢量为</p>
<h3 id="2-平移"><a href="#2-平移" class="headerlink" title="(2)平移"></a>(2)平移</h3><p>平移后的矢量和平移前的矢量是同一个向量</p>
<h3 id="3-旋转"><a href="#3-旋转" class="headerlink" title="(3)旋转"></a>(3)旋转</h3><p>矢量$\vec{a}=(x,y)$逆时针旋转$\theta$，得到的矢量$\vec{a’}=(xcos\theta-ysin\theta,ycos\theta+xsin\theta)$</p>
<h3 id="4-投影"><a href="#4-投影" class="headerlink" title="(4)投影"></a>(4)投影</h3><p>矢量$\vec{b}$在矢量$\vec{a}$上的投影为$\vec{a}\frac{\vec{a}\cdot\vec{b}}{\vec{a}^2}$</p>
<h3 id="5-对称"><a href="#5-对称" class="headerlink" title="(5)对称"></a>(5)对称</h3><p>记矢量$\vec{b}$在矢量$\vec{a}$上的投影为$\vec{c}=\vec{a}\frac{\vec{a}\cdot\vec{b}}{\vec{a}^2}$，则矢量$\vec{b}$关于矢量$\vec{a}$的对称为$\vec{b}-2(\vec{b}-\vec{s})=2\vec{a}\frac{\vec{a}\cdot\vec{b}}{\vec{a}^2}=\vec{b}$</p>
]]></content>
      <categories>
        <category>数学&amp;物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>微积分基础之图形面积（体积）计算</title>
    <url>/2019/07/29/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%88%E4%BD%93%E7%A7%AF%EF%BC%89%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="一、平面图形面积"><a href="#一、平面图形面积" class="headerlink" title="一、平面图形面积"></a>一、平面图形面积</h1><script type="math/tex; mode=display">\boxed{积分的要领1：以长方形为基础来思考}</script><a id="more"></a>
<h2 id="1、简单图形的面积"><a href="#1、简单图形的面积" class="headerlink" title="1、简单图形的面积"></a>1、简单图形的面积</h2><h3 id="1-长方形"><a href="#1-长方形" class="headerlink" title="(1)长方形"></a>(1)长方形</h3><p>长$\times$宽，<del>不会的请离开</del></p>
<h3 id="2-三角形"><a href="#2-三角形" class="headerlink" title="(2)三角形"></a>(2)三角形</h3><p>底$\times$高/2，<del>不会的请离开</del></p>
<h3 id="3-平行四边形"><a href="#3-平行四边形" class="headerlink" title="(3)平行四边形"></a>(3)平行四边形</h3><p>底$\times$高，<del>不会的请离开</del></p>
<h3 id="4-梯形"><a href="#4-梯形" class="headerlink" title="(4)梯形"></a>(4)梯形</h3><p>$($上底$+$下底$)\times$高/2，<del>不会的请离开</del></p>
<h3 id="2、稍微复杂一点的图形面积"><a href="#2、稍微复杂一点的图形面积" class="headerlink" title="2、稍微复杂一点的图形面积"></a>2、稍微复杂一点的图形面积</h3><script type="math/tex; mode=display">\boxed{积分的要领2：把图形看作小长方形的组合}</script><h3 id="1-圆"><a href="#1-圆" class="headerlink" title="(1)圆"></a>(1)圆</h3><h4 id="法1："><a href="#法1：" class="headerlink" title="法1："></a>法1：</h4><p>用圆规在方格纸上画一个圆，接着数一数圆中的方格数<br>我在边长为$1mm$的方格纸上画了一个半径为$2cm$的圆，我算(shǔ)出圆中共有$1189$个格子，所以我们算出的圆周率是$2.9725$<br>虽然这个误差很大，但是，随着格子边长的缩小，我们的准确度就越高</p>
<h4 id="法2："><a href="#法2：" class="headerlink" title="法2："></a>法2：</h4><p>有什么办法可以提高精度吗？有，如图，我们把圆分成细长的小条来求<del>由于我太懒了，所以只画了3条</del><br><img src="https://img-blog.csdnimg.cn/20190728100923496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""><br>每一个小条的宽度是$\Delta x$，表示非常小的数值<br>这样，我们可以得出圆的面积$=\int_{左端}^{右端}短条在x值对应的长度dx$<br>$dx$可以理解为$\lim \limits_{\Delta x \rightarrow 0}\Delta x$<br>我做了一个实验，计算半径为$1cm$的圆，把它分成$N$个小条，制成一张表格<br>|$N$|所有小条的总面积|<br>|—|—|<br>|$10$|$2.637049$|<br>|$20$|$2.904518$|<br>|$40$|$3.028465$|<br>|$200$|$3.120417$|<br>|$2000$|$3.139555$|<br>|$20000$|$3.141391$|<br>可见$N$越来越大时，小条的总面积就会越接近圆的面积$\pi r^{2}$</p>
<h3 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h3><p>椭圆是由圆拉伸来的，所以我们也可以把它分成细长的短条来求，这个小条的面积就是圆的小条面积的$\frac{a}{b}$倍，所以，椭圆的面积就是$\pi ab$</p>
<script type="math/tex; mode=display">\boxed{积分的要领3：把图形分解成长方形然后进行伸缩变换}</script><p><img src="https://img-blog.csdnimg.cn/20190728103006934.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""></p>
<h1 id="立体图形表面积和体积"><a href="#立体图形表面积和体积" class="headerlink" title="立体图形表面积和体积"></a>立体图形表面积和体积</h1><h2 id="祖暅定理"><a href="#祖暅定理" class="headerlink" title="祖暅定理"></a>祖暅定理</h2><script type="math/tex; mode=display">\boxed{积分的要领4：把图形看作被切割后的组合}</script><p>在外国称作卡瓦列利原理<br>截面面积总是相等的两个立体图形，体积也相等</p>
<h2 id="三分之一之谜"><a href="#三分之一之谜" class="headerlink" title="三分之一之谜"></a>三分之一之谜</h2><script type="math/tex; mode=display">\boxed{积分的要领5：灵活应用祖暅定理}</script><p>大家都知道圆锥的体积公式吧？体积$=$底面积$\times$高$\times\frac{1}{3}$<br>话说这个$\frac{1}{3}$是哪来的？<br>首先，我们从四棱锥说起<br>我们先把C点平移到A的正上方，使得$AC\perp$平面$ABD$（祖暅定理）<br><img src="https://img-blog.csdnimg.cn/20190729110729838.png" alt=""><br>$                     \Downarrow$<br><img src="https://img-blog.csdnimg.cn/20190729111056314.png" alt=""><br>这时，我们发现3个这样的椎体可以拼成一个长方形，因此，我们可以得到这个四棱锥的体积就是$\frac{1}{3}\times$底面积$\times$高<br>得到了四棱锥的体积之后，我们就可以计算任意椎体的体积了<br>我们把椎体的底面分成许多很小的长方形，所以每一个小四棱锥的体积相加就是椎体的体积了，也就等于$\frac{1}{3}\times$底面积$\times$高</p>
<h2 id="球的体积"><a href="#球的体积" class="headerlink" title="球的体积"></a>球的体积</h2><p>我们先做出一个立体图形，我把它称为钵体，它是一个圆柱再去掉一个圆锥后的图形<br><img src="https://img-blog.csdnimg.cn/20190729113104741.png" alt=""><br>我们可以发现，它的每一个截面的面积和一个半球上的截面的面积相同，所以，根据祖暅定理，我们可以知道，球的体积$=2\times\frac{2}{3}\pi R^3=\times\frac{4}{3}\pi R^3$</p>
<script type="math/tex; mode=display">\boxed{积分的要领6：寻找“有效的对应、关系条件”}</script><h2 id="球的表面积"><a href="#球的表面积" class="headerlink" title="球的表面积"></a>球的表面积</h2><script type="math/tex; mode=display">\boxed{积分的要领7：相比“纠结于细节”，“如何思考才能顺利计算”更优先}</script><p>我们把球的表面分成许多小的四棱锥，所以，我们可以得到球的体积$=\frac{1}{3}\times R\times$球的表面积<br>所以，我们可以得到球的表面积$=4\pi R^2$</p>
<h1 id="终极问题——甜甜圈的体积"><a href="#终极问题——甜甜圈的体积" class="headerlink" title="终极问题——甜甜圈的体积"></a>终极问题——甜甜圈的体积</h1><p>大家都知道甜甜圈吧？<br><img src="https://img-blog.csdnimg.cn/2019072912252495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""><br>我用软件画了一个甜甜圈，我们假设甜甜圈边上的圆心到中心的距离为$4cm$，半径为$2cm$，我们尝试水平切割，我们就可以得到一个个圆环<br>这些圆环的外圈的半径$=4+\sqrt{4-x^2}$，内圈的半径$=4-\sqrt{4-x^2}$，所以这个截面的面积$=16\pi\sqrt{4-x^2}$（$x$代表到圆心的距离）<br>由此，我们就可以表示出整个甜甜圈的体积就是$\int_{-2}^{2}16\pi\sqrt{4-x^2}dx$这个积分是在不需要我们计算，我们只要画一个图就行了<br><img src="https://img-blog.csdnimg.cn/20190729123434408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0OTQ4OA==,size_16,color_FFFFFF,t_70" alt=""><br>积分相当于计算这个图形的面积，所以也就是$\int_{-2}^{2}16\pi\sqrt{4-x^2}dx=16\pi\times2\pi=32\pi^{2}$</p>
<p><strong>参考材料：</strong><br><strong>《简单微积分》神永正博 著</strong></p>
]]></content>
      <categories>
        <category>物理&amp;信息竞赛</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>微积分</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2894 DTOJ Begin1549[USACO08FEB]酒店Hotel题解</title>
    <url>/2019/07/27/%E6%B4%9B%E8%B0%B7P2894-DTOJ%20Begin1549%5BUSACO08FEB%5D%E9%85%92%E5%BA%97Hotel%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problemnew/show/P2894" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>奶牛们最近的旅游计划，是到苏必利尔湖畔，享受那里的湖光山色，以及明媚的阳光。作为整个旅游的策划者和负责人，贝茜选择在湖边的一家著名的旅馆住宿。这个巨大的旅馆一共有$N (1 \leqslant N \leqslant 50000)$间客房，它们在同一层楼中顺次一字排开，在任何一个房间里，只需要拉开窗帘，就能见到波光粼粼的湖面。<br>贝茜一行，以及其他慕名而来的旅游者，都是一批批地来到旅馆的服务台，希望能订到$D_{i} (1 \leqslant D_{i} \leqslant N)$间连续的房间。<br>服务台的接待工作也很简单：如果存在r满足编号为$r \cdots \cdots r+D_{i}-1$的房间均空着，他就将这一批顾客安排到这些房间入住；如果没有满足条件的r，他会道歉说没有足够的空房间，请顾客们另找一家宾馆。如果有多个满足条件的r，服务员会选择其中最小的一个。 旅馆中的退房服务也是批量进行的。每一个退房请求由$2$个数字$X_{i}、D_{i}$描述，表示编号为$X_{i} \cdots \cdots X_{i}+D_{i}-1 (1 \leqslant X_{i} \leqslant N-D_{i}+1)$房间中的客人全部离开。退房前，请求退掉的房间中的一些，甚至是所有，可能本来就无人入住。<br>而你的工作，就是写一个程序，帮服务员为旅客安排房间。你的程序一共需要处理$M (1 \leqslant M &lt; 50000)$个按输入次序到来的住店或退房的请求。第一个请求到来前，旅店中所有房间都是空闲的。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第$1$行: $2$个用空格隔开的整数$N$和$M$<br>第$2 \cdots \cdots M+1$行:第$i+1$描述了第$i$个请求，如果它是一个订房请求，则用$2$个数字$1$和$D_{i}$描述，数字间用空格隔开；如果它是一个退房请求，用$3$个以空格隔开的数字$2$、$X_{i}$和$D_{i}$描述</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个订房请求，输出$1$个数：如果请求能被满足，输出满足条件的最小的$r$；如果请求无法被满足，输出$0$</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>10 6<br>1 3<br>1 3<br>1 3<br>1 3<br>2 5 5<br>1 6</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>1<br>4<br>7<br>0<br>5</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，我们先将题目简化一下，这道题需要我们实现$2$个操作：<br>1、订房:相当于查询是否有连续$D$个位置是空的，如果有输出最左端点<br>2、退房:相当于将$X$到$X+D-1$这段位置置为空<br>因此，我们很容易看出，这是一道支持区间查询和区间修改的线段树题。<br>要解决这个问题，每个节点都需要维护$4$个变量：<br>1、$lm$从左数最多有多少个连续的$0$<br>2、$rm$从右数最多有多少个连续的$0$<br>3、$m$整个区间最多有多少个连续的$0$<br>4、$sum$区间的长度<br>（读者：什么！？不用延迟标记（俗称$lazy$标志）吗？）<br>（我：…延迟标记还要写在这里吗？区间修改不是肯定需要吗?）<br> 一开始，因为整个区间都是空的，所以我们将这些的值都赋为区间的长度。<br>当遇到一个查询的时候，就从根节点开始查询，为了保证最后得到的答案一定是靠左的，所以我们都先判断左边的连续$0$的个数是否大于我们需要的$D$，如果是就直接返回左端点，然后，用同样的方法判断判断中间和右边的部分。<br>当遇到修改的时候，就正常修改，只是在最后上传标志的时候会稍微复杂一点点，有几种情况需要判断。<br>最后，因为我们涉及了区间修改，所以每做一步操作都要下放标志<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> l(i) t[i].l</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> r(i) t[i].r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> m(i) t[i].m</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lm(i) t[i].lm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rm(i) t[i].rm</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sum(i) t[i].sum</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> add(i) t[i].add</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ppap</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> l,r,m,lm,rm,sum,add;</span><br><span class="line">&#125;t[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//上传标志</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(sum(<span class="number">2</span>*p)==m(<span class="number">2</span>*p)) lm(p)=sum(<span class="number">2</span>*p)+lm(<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> lm(p)=lm(<span class="number">2</span>*p);</span><br><span class="line">  <span class="keyword">if</span>(sum(<span class="number">2</span>*p+<span class="number">1</span>)==m(<span class="number">2</span>*p+<span class="number">1</span>)) rm(p)=sum(<span class="number">2</span>*p+<span class="number">1</span>)+rm(<span class="number">2</span>*p);</span><br><span class="line">  <span class="keyword">else</span> rm(p)=rm(<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">  m(p)=max(m(<span class="number">2</span>*p),m(<span class="number">2</span>*p+<span class="number">1</span>));</span><br><span class="line">  m(p)=max(m(p),rm(<span class="number">2</span>*p)+lm(<span class="number">2</span>*p+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span><span class="comment">//下放标志</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> add=add(p);</span><br><span class="line">  add(p)=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l(p)==r(p)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(add==<span class="number">1</span>)&#123;</span><br><span class="line">    lm(<span class="number">2</span>*p)=rm(<span class="number">2</span>*p)=m(<span class="number">2</span>*p)=sum(<span class="number">2</span>*p);</span><br><span class="line">    lm(<span class="number">2</span>*p+<span class="number">1</span>)=rm(<span class="number">2</span>*p+<span class="number">1</span>)=m(<span class="number">2</span>*p+<span class="number">1</span>)=sum(<span class="number">2</span>*p+<span class="number">1</span>);</span><br><span class="line">    add(<span class="number">2</span>*p)=add(<span class="number">2</span>*p+<span class="number">1</span>)=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(add==<span class="number">2</span>)&#123;</span><br><span class="line">    lm(<span class="number">2</span>*p)=rm(<span class="number">2</span>*p)=m(<span class="number">2</span>*p)=<span class="number">0</span>;</span><br><span class="line">    lm(<span class="number">2</span>*p+<span class="number">1</span>)=rm(<span class="number">2</span>*p+<span class="number">1</span>)=m(<span class="number">2</span>*p+<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line">    add(<span class="number">2</span>*p)=add(<span class="number">2</span>*p+<span class="number">1</span>)=<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//建树 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  l(p)=l;</span><br><span class="line">  r(p)=r;</span><br><span class="line">  lm(p)=rm(p)=m(p)=sum(p)=r-l+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  build(<span class="number">2</span>*p,l,mid);</span><br><span class="line">  build(<span class="number">2</span>*p+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> f)</span><span class="comment">//区间修改 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pushdown(p);</span><br><span class="line">  <span class="keyword">int</span> l=l(p),r=r(p);</span><br><span class="line">  <span class="keyword">if</span>(l==x&amp;&amp;y==r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>) lm(p)=rm(p)=m(p)=sum(p);</span><br><span class="line">    <span class="keyword">else</span> lm(p)=rm(p)=m(p)=<span class="number">0</span>;</span><br><span class="line">    add(p)=f;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(mid&gt;=y) change(<span class="number">2</span>*p,x,y,f);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;x) change(<span class="number">2</span>*p+<span class="number">1</span>,x,y,f);</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    change(<span class="number">2</span>*p,x,mid,f);</span><br><span class="line">    change(<span class="number">2</span>*p+<span class="number">1</span>,mid+<span class="number">1</span>,y,f);</span><br><span class="line">  &#125;</span><br><span class="line">  pushup(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> x)</span><span class="comment">//区间查询 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pushdown(p);</span><br><span class="line">  <span class="keyword">int</span> l=l(p),r=r(p),mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">  <span class="keyword">if</span>(m(<span class="number">2</span>*p)&gt;=x) <span class="keyword">return</span> ask(<span class="number">2</span>*p,x);</span><br><span class="line">  <span class="keyword">if</span>(rm(<span class="number">2</span>*p)+lm(<span class="number">2</span>*p+<span class="number">1</span>)&gt;=x) <span class="keyword">return</span> mid-rm(<span class="number">2</span>*p)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ask(<span class="number">2</span>*p+<span class="number">1</span>,x);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">  build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> f,x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f);</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">      <span class="keyword">if</span>(t[<span class="number">1</span>].m&lt;x) <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p=ask(<span class="number">1</span>,x);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        change(<span class="number">1</span>,p,p+x<span class="number">-1</span>,<span class="number">2</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">      change(<span class="number">1</span>,x,x+y<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2120 DTOJ1099仓库建设题解</title>
    <url>/2019/07/27/%E6%B4%9B%E8%B0%B7P2120-DTOJ1099%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problemnew/show/P2120" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>$L$公司有$N$个工厂，由高到底分布在一座山上。<br>工厂$1$在山顶，工厂$N$在山脚。 由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。<br>突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。<br>由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_{i}$件，在第$i$个工厂位置建立仓库的费用是$C_{i}$。<br>对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。<br>假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p>
<ul>
<li>工厂$i$距离工厂$1$的距离$X_{i}$（其中$X_{1}=0$）;</li>
<li>工厂$i$目前已有成品数量$P_{i}$;</li>
<li>在工厂$i$建立仓库的费用$C_{i}$;</li>
</ul>
<p>请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_{i},P_{i},C_{i}$, 意义如题中所述。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>仅包含一个整数，为可以找到最优方案的费用。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>3<br>0 5 10<br>5 3 100<br>9 6 10</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>32</p>
<h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>在工厂$1$和工厂$3$建立仓库，建立费用为$10+10=20$，运输费用为$(9-5)*3=12$，总费用$32$。<br>如果仅在工厂$3$建立仓库，建立费用为$10$，运输费用为$(9-0)5+(9-5)3=57$，总费用$67$，不如前者优。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于20%的数据， $N \leqslant 500$；<br>对于40%的数据， $N \leqslant 10000$；<br>对于100%的数据， $N \leqslant 1000000$。 所有的$X_{i},P_{i},C_{i}$均在$32$位带符号整数以内，保证中间计算结果不超过$64$位带符号整数。</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先，这一道题是一道$DP$题，所以，我们先用普通的$DP$做一下这题。<br>假设$f_{i}$表示工厂$1$到$i$的最小总费用<br>令$sp_{i}=\sum \limits_{j=1}^{i} p_{j}$，$s_{i}=\sum \limits_{j=1}^{i} s_{j}p_{j}$<br>由于产品只能往山下运（即只能运往编号更大的工厂的仓库），所以当编号在区间$\left[l,r\right]$中的工厂只有一个仓库（即只有一个仓库在工厂$r$）时，这段区间的费用为$c_{r}+\sum \limits_{i=l}^{r} p_{i} \times \left(x_{r}-x_{i}\right)=c_{r}+x_{r} \times \left(sp_{r}-sp_{l-1}\right)-s_{r}+s_{l-1}$<br>所以，状态转移方程就是$f_{i}=\min \limits_{0 \leqslant j &lt; i} \left\{f_{j}+x_{i} \times \left(sp_{i}-sp_{j}\right)-s_{i}+s_{j}\right\}+c_{i}$<br>最终的结果是$f_{n}$<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,x[<span class="number">1000010</span>],c[<span class="number">1000010</span>],p[<span class="number">1000010</span>],sp[<span class="number">1000010</span>],s[<span class="number">1000010</span>],f[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  sp[<span class="number">0</span>]=s[<span class="number">0</span>]=f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">    sp[i]=sp[i<span class="number">-1</span>]+p[i],s[i]=s[i<span class="number">-1</span>]+x[i]*p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> minf=<span class="number">9223372036854775807</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++) minf=min(minf,f[j]+x[i]*(sp[i]-sp[j])-s[i]+s[j]);</span><br><span class="line">    f[i]=minf+c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这种普通的$DP$的复杂度是$\Theta \left(n^{2}\right)$，只能得到55分，所以，我们需要优化一下程序。<br>假设我们在计算$f_{i}$，此时有两个决策$a,b$满足$a&gt;b$且$a$比$b$优，即$f_{a}+x_{i} \times \left(sp_{i}-sp_{a}\right)-s_{i}+s_{a}<f_{b}+x_{i} \times \left(sp_{i}-sp_{b}\right)-s_{i}+s_{b}$化简得：
$f_{a}+s_{a}-f_{b}-s_{b}<x_{i} \times \left(sp_{a}+sp_{b}\right)$
$\frac{f_{a}+s_{a}-f_{b}-s_{b}}{sp_{a}+sp_{b}}<x_{i}$
所以我们可以维护一个单调队列，使得从队尾到队首，$\frac{f_{a+1}+s_{a+1}-f_{a}-s_{a}}{sp_{a+1}+sp_{a}}$递减，保证队首决策最优，并每次决策从队首转移即可
代码如下：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,l,r,x[<span class="number">1000010</span>],c[<span class="number">1000010</span>],p[<span class="number">1000010</span>],sp[<span class="number">1000010</span>],s[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[<span class="number">1000010</span>],q[<span class="number">1000010</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;p[i]&gt;&gt;c[i];</span><br><span class="line">    s[i]=s[i<span class="number">-1</span>]+x[i]*p[i],sp[i]=sp[i<span class="number">-1</span>]+p[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r&amp;&amp;f[q[l+<span class="number">1</span>]]+s[q[l+<span class="number">1</span>]]-f[q[l]]-s[q[l]]&lt;x[i]*(sp[q[l+<span class="number">1</span>]]-sp[q[l]])) l++;</span><br><span class="line">    f[i]=f[q[l]]+c[i]+x[i]*(sp[i]-sp[q[l]])-s[i]+s[q[l]];</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r&amp;&amp;(f[q[r]]+s[q[r]]-f[q[r<span class="number">-1</span>]]-s[q[r<span class="number">-1</span>]])*(sp[i]-sp[q[r]])&gt;(f[i]+s[i]-f[q[r]]-s[q[r]])*(sp[q[r]]-sp[q[r<span class="number">-1</span>]])) r--;</span><br><span class="line">    q[++r]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>因为每个元素入队出队次数都是$\Theta \left(1\right)$的，且转移复杂度也是$\Theta \left(1\right)$，所以总复杂度为$\Theta \left(n\right)$。</p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>几何</tag>
        <tag>洛谷</tag>
        <tag>斜率优化DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2689 Prime Distance题解</title>
    <url>/2019/07/27/POJ2689%20Prime%20Distance%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="http://poj.org/problem?id=2689" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<h3 id="英文题目"><a href="#英文题目" class="headerlink" title="英文题目"></a>英文题目</h3><p>The branch of mathematics called number theory is about properties of numbers. One of the areas that has captured the interest of number theoreticians for thousands of years is the question of primality. A prime number is a number that is has no proper factors (it is only evenly divisible by $1$ and itself). The first prime numbers are $2,3,5,7$ but they quickly become less frequent. One of the interesting questions is how dense they are in various ranges. Adjacent primes are two numbers that are both primes, but there are no other prime numbers between the adjacent primes. For example, $2,3$ are the only adjacent primes that are also adjacent numbers.<br>Your program is given $2$ numbers: $L$ and $U$ ($1 \leqslant L&lt; U \leqslant 2,147,483,647$), and you are to find the two adjacent primes $C1$ and $C2$ ($L \leqslant C1&lt; C2 \leqslant U$) that are closest (i.e. $C2-C1$ is the minimum). If there are other pairs that are the same distance apart, use the first pair. You are also to find the two adjacent primes $D1$ and $D2$ ($L \leqslant D1&lt; D2 \leqslant U$) where $D1$ and $D2$ are as distant from each other as possible (again choosing the first pair if there is a tie).</p>
<h3 id="中文题意"><a href="#中文题意" class="headerlink" title="中文题意"></a>中文题意</h3><p>给定两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647$)，求闭区间 $\left[L,R\right]$中相邻两个质数的差的最小值和最大值是多少，分别输出这两对质数。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每行两个整数$L,R$($1 \leqslant L&lt; R \leqslant 2,147,483,647,R-L \leqslant 10^6$)。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个$L,R$，输出最小值和最大值，格式参照样例。若区间内无质数，输出”There are no adjacent primes.”。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>2 17<br>14 17</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>2,3 are closest, 7,11 are most distant.<br>There are no adjacent primes.</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>由于$L,R$的范围很大，所以埃氏筛法和欧拉筛法都无法生成$\left[1,R\right]$的所有质数。但是$R-L$的范围很小且任何一个合数$n$一定包含一个不超过$\sqrt{n}$的质因子，所以我们只需要用筛法求出$2,3,\cdots,\sqrt{n}$的所有质数。而对于每一个质数$p$，标记$i \times p \left(\left\lceil\frac{L}{p}\right\rceil \leqslant i \leqslant \left\lceil\frac{R}{p}\right\rceil\right)$为合数。标记完后，剩下的所有数就是$\left[L,R\right]$中的质数了。再两两比较，找出差最大和最小的就可以了。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,t1,t2,x1,x2,y1,y2,l,r,a[<span class="number">100001</span>], b[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">bool</span> v[<span class="number">1000001</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span><span class="comment">//筛出2~46340之间的质数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(v,<span class="number">1</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">46340</span>;i++) <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">    a[++n]=i;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=<span class="number">46340</span>/i;j++) v[i*j]=<span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  prime();</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">1</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">if</span>(l==<span class="number">1</span>) v[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(j=l/a[i];j&lt;=r/a[i];j++) <span class="keyword">if</span>(j&gt;<span class="number">1</span>) v[a[i]*j-l]=<span class="literal">false</span>;<span class="comment">//去除L~R中的合数</span></span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=l;i&lt;=r;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(v[i-l]) b[++m]=i;<span class="comment">//存储L~R中的质数</span></span><br><span class="line">      <span class="keyword">if</span>(i==r) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t1=<span class="number">2147483647</span>;</span><br><span class="line">    t2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">      j=b[i+<span class="number">1</span>]-b[i];</span><br><span class="line">      <span class="keyword">if</span>(j&lt;t1)&#123;</span><br><span class="line">        t1=j;</span><br><span class="line">        x1=b[i];</span><br><span class="line">        y1=b[i+<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j&gt;t2)&#123;</span><br><span class="line">        t2=j;</span><br><span class="line">        x2=b[i];</span><br><span class="line">        y2=b[i+<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="comment">//比较差的大小</span></span><br><span class="line">    <span class="keyword">if</span>(!t2) <span class="built_in">cout</span>&lt;&lt;<span class="string">"There are no adjacent primes."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;x1&lt;&lt;<span class="string">","</span>&lt;&lt;y1&lt;&lt;<span class="string">" are closest, "</span>&lt;&lt;x2&lt;&lt;<span class="string">","</span>&lt;&lt;y2&lt;&lt;<span class="string">" are most distant."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1172 DTOJ Begin1777安全逃离题解</title>
    <url>/2019/07/27/%E6%B4%9B%E8%B0%B7P1172-DTOJ%20Begin1777%E5%AE%89%E5%85%A8%E9%80%83%E7%A6%BB%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><strong><a href="https://www.luogu.org/problemnew/show/P1172" target="_blank" rel="noopener">原题</a></strong></p>
<a id="more"></a>
<p>农夫john最近在研究如果发生重大事故，如何让农场里的奶牛逃离问题。他想要确信在紧急情况下，所有的奶牛都有一个安全逃离方案。因为在紧急情况下，奶牛们都会失去观察和判断能力，所以最近john一直在教奶牛们逃离的方法，他的方法很简单，就是任何时候都只向北方或东方逃离，北方是行坐标减1的方向，东方是列坐标加1的方向。奶牛们虽笨，不过这一点事关自己的生命，所以他们牢记在心，而且也一定会这么做。</p>
<p>当然也会出问题，奶牛们在逃离的方向上会横冲直撞，为了阻止奶牛之间互相冲撞造成伤害，john要求任何一个奶牛的逃离路线不能经过其它奶牛的初始位置。一个逃离方案是安全的如果它能够满足上面的要求，反之它就是不安全的。</p>
<p>奶牛们所在的土地（农场）被划分成了rr行和cc列的一个矩形地图。奶牛们都待在这个矩形中的某一个位置。</p>
<p>请帮助john确定给定的一个地图上是否存在一个安全的逃离方案。</p>
<p>比如，下面的两个图：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3Uub3JnL3VwbG9hZC9waWMvNzI0MC5wbmc" alt=""></p>
<p>左边的例子表示了一个能够安全逃离的地图，因为没有任何一个奶牛的逃离路线上包括其他奶牛。右边的例子表示了一个不安全的地图，因为位于(4,1)(4,1)的奶牛不论是向东逃离还是向北逃离，它的路线上都会有别的奶牛，从这个图中拿掉任意一头奶牛，这个地图都会变成安全的。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第$1$行：两个整数$r,c$，用1个空格隔开，表示矩形的行数和列数（均 $\le 50$）。<br>第$2$行：一个整数$n$，表示奶牛的个数（$\le 100$）。<br>第$3$到$n+2$行：共$n$行，每行有$2$个整数，之间用$1$个空格隔开，分别表示这头奶牛所在的行和列。<br><strong>每输入完一行后，会输入多余的字符！！！</strong></p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如果这块土地是安全的，输出$0$。<br>如果移走任意一头奶牛这块土地还是不安全，输出$-1$。<strong>否则输出移走的那头奶牛的编号，如果有多个奶牛满足要求，输出所有的数</strong>。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><p>5 5<br>5<br>1 1<br>2 4<br>3 1<br>2 2<br>2 1</p>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><p>1<br>5</p>
<h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>这一题的题目有问题（我在百度上查了，所有题目都是错的。多亏了洛谷的在线测评，把题解复制在上面执行，就可以知道题目错误了）。我整整研究了一天才研究出来。最后，我是在另一个人提交的AC程序上找出了我的错误。这个错误你根本是不可能想到的（虽然我不知道以前的人是怎么发现的），这个错误是就是<strong>我在题目中加粗的字</strong>其实这个问题我在一个OJ上也有注意到（那个OJ可以下载不完整的数据），但是我并不知道这是一个漏洞。<br>这道题的思路就是模拟，首先遍历所有的奶牛，若全部安全，则输出0，结束。如果不是全部安全的，则每次将一只奶牛删除，再遍历全部，看看是否全是安全的，如果是，则输出该奶牛编号，直到所有情况都遍历完了，再讨论-1的情况。<br>代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> m[<span class="number">51</span>][<span class="number">51</span>],h,l,n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cow</span>&#123;</span>     <span class="comment">//结构体，也可以用x[101]和y[101] </span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">cow a[<span class="number">101</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anquan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;     <span class="comment">//每头奶牛安全的条件 </span></span><br><span class="line">  <span class="keyword">int</span> t1=<span class="number">1</span>,t2=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;x;i++) <span class="keyword">if</span>(m[i][y]) &#123;t1=<span class="number">0</span>;<span class="keyword">break</span>;&#125;     <span class="comment">//如果北面有奶牛，那么t1=0 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=y+<span class="number">1</span>;i&lt;=l;i++) <span class="keyword">if</span>(m[x][i]) &#123;t2=<span class="number">0</span>;<span class="keyword">break</span>;&#125;     <span class="comment">//如果东面有奶牛，那么t2=0 </span></span><br><span class="line">  <span class="keyword">if</span>(t1==<span class="number">0</span>&amp;&amp;t2==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//如果两边都有奶牛，则不安全，反之安全 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qaq</span><span class="params">()</span></span>&#123;     <span class="comment">//所有奶牛都安全 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++) <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=l;j++) <span class="keyword">if</span>(m[i][j]) <span class="keyword">if</span>(!(anquan(i,j))) <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">//遍历整个农场，如果有奶牛不安全，那么返回0 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;     <span class="comment">//否则返回1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aq</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;     <span class="comment">//去掉一只奶牛后安全</span></span><br><span class="line">  m[x][y]=<span class="number">0</span>;     <span class="comment">//删除奶牛</span></span><br><span class="line">  <span class="keyword">return</span> qaq();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;h&gt;&gt;l&gt;&gt;n;</span><br><span class="line">  <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));<span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));     <span class="comment">//初始化 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[i].x&gt;&gt;a[i].y;     <span class="comment">//输入 </span></span><br><span class="line">    m[a[i].x][a[i].y]=i;     <span class="comment">//也可以赋值为1 </span></span><br><span class="line">    gets(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(qaq()) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;     <span class="comment">//如果全部安全，输出0，结束 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(aq(a[i].x,a[i].y)) <span class="comment">/*如果去掉后安全*/</span><span class="keyword">if</span>(!temp) <span class="comment">/*如果是第一次输出*/</span><span class="built_in">cout</span>&lt;&lt;i,temp++; <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;i; </span><br><span class="line">    m[a[i].x][a[i].y]=i;     <span class="comment">//这步非常重要，不然第二次执行的时候就删除了两只奶牛 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!temp) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>;     <span class="comment">//如果删掉任何一只奶牛都不安全，输出-1 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>信息竞赛</category>
      </categories>
      <tags>
        <tag>DTOJ</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2019/07/25/Hello%20Hexo/</url>
    <content><![CDATA[<p>今天，我创建了Hexo博客。但我太弱了，希望各位大佬多多指教。</p>
]]></content>
  </entry>
</search>
